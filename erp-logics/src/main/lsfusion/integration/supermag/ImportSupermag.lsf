MODULE ImportSupermag;

REQUIRE Item, ItemSize, LegalEntityBy, EDI, RangeCheck,
        Document, SupermagIntegration,
        PriceListOperation, PriceListBefore, Repricing, PriceListContract, PriceList,
        PurchaseOrder, PurchasePack, PurchaseInvoice, PurchaseShipment, PricingPurchase, PurchaseScheduleOrder, PurchaseScheduleOrderSeparation, PurchaseDemandItem, 
        PurchaseOrderStatus, PurchaseSaleOrder, PurchaseAutoOrder, PurchaseScheduleOrderContract,
        SaleOrder, SaleOrderStatus,
        ItemFood, ItemDescription, ItemStorage, StockReserve, ItemPart, ItemSize, StockContract;

PRIORITY SupermagIntegration;

idOrder (ItemGroup g) = GROUP CONCAT TEXT (order(ItemGroup gg)) + '.' IF level(g, gg), '' ORDER DESC level(g, gg); 

importItemGroup 'Импорт товарных групп' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL tree = ISTRING[100] (INTEGER);
    LOCAL name = ISTRING[250] (INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ID, TREE, NAME FROM Supermag.SACARDCLASS' TO file;
    
    IMPORT TABLE FROM file() TO id, tree, name;
    
    IF NOT itemGroup('all') THEN NEW g = ItemGroup {
        id(g) <- 'all';
        name(g) <- 'Все';
    }
    
    FOR id(INTEGER i) AND id(i) != 0 AND NOT itemGroup(TEXT (id(i))) DO NEW g = ItemGroup {
        id(g) <- ISTRING[100] (id(i));
    }
    
    LOCAL level = INTEGER (INTEGER);
    LOCAL parent = TEXT (INTEGER);
    LOCAL idOrder = ISTRING[20](ItemGroup);
    
    level(INTEGER i) <- wordCount(tree(i), '.') (-) 1 WHERE imported(i);
    parent(INTEGER i) <- left(tree(i), length(tree(i)) - length((getWord(tree(i), '.', level(i))) + '.')) WHERE imported(i);
    
    FOR level(INTEGER i) AND ItemGroup g = itemGroup(TEXT (id(i))) DO {
    
        name(g) <- name(i);
        order(g) <- INTEGER (getWord(tree(i), '.', level(i)));
        idOrder(g) <- tree(i);
    }
    FOR level(INTEGER i) AND ItemGroup g = itemGroup(TEXT (id(i))) ORDER level(i) DO {
        
        parent(g) <- OVERRIDE (GROUP MAX ItemGroup gg IF idOrder(gg) == parent(i)), itemGroup('all');
    }
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importItemGroup();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importItemGroup()); } }

importUOM 'Импорт единиц измерений' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL name = STRING[50] (INTEGER);
    LOCAL abb = STRING[100] (INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ID, NAME, ABBREV FROM Supermag.SAMEASUREMENT' TO file;
    
    IMPORT TABLE FROM file() TO id, name, abb;
    
    FOR id(INTEGER i) AND NOT UOM(TEXT (id(i))) DO NEW u = UOM {
        id(u) <- ISTRING[100] (id(i));
    }
    
    FOR UOM u = UOM(TEXT (id(INTEGER i))) DO {
        id(u) <- ISTRING[100] (id(i));
        name(u) <- name(i);
        shortName(u) <- abb(i);
        factor(u) <- 1;
        base(u) <- u;
    }
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importUOM();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importUOM()); } }

shortName 'Краткое наименование' = DATA ISTRING[250](Item) IN itemBase;

@defineItemAttribute(shortName, , 'Краткое наименование', itemBase);
@implementItemAttribute(shortName, 'Краткое наименование', String, itemShortName);

statusInSuperMag 'Статус в Супермаге' = DATA INTEGER (Item);

overImportItem ABSTRACT LIST ();

importItem 'Импорт товаров' () {
    
    LOCAL id = TEXT (INTEGER);
    LOCAL name = ISTRING[255] (INTEGER);
    LOCAL shortName = ISTRING[250] (INTEGER);
    LOCAL idMeasurement = INTEGER (INTEGER);
    LOCAL idClass = INTEGER (INTEGER);
    LOCAL country = TEXT (INTEGER);
    LOCAL accepted = INTEGER (INTEGER);
    LOCAL scale = STRING[1] (INTEGER);
    LOCAL width = NUMERIC[14,3] (INTEGER);
    LOCAL length = NUMERIC[14,3] (INTEGER);
    LOCAL height = NUMERIC[14,3] (INTEGER);
    LOCAL vat = NUMERIC[8,4] (INTEGER);
    
    LOCAL imported = BOOLEAN (Item);
    LOCAL imported = BOOLEAN (Barcode);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base()    
        EXEC 'SELECT card.ARTICLE, NAME, SHORTNAME, IDMEASUREMENT, IDCLASS, COUNTRY, ACCEPTED, SCALELOAD, WIDTH, LENGTH, HEIGHT, taxrate.TAXPERCENT AS VAT FROM Supermag.SMCARD card, SUPERMAG.SMTAXIDENTITY taxident, SUPERMAG.SMTAXGROUP taxgr, SUPERMAG.SMTAXRATE taxrate, SUPERMAG.SMCARDTAX cardtax WHERE taxident.IDENTID = 0 AND taxgr.TAXGROUPID = cardtax.TAXGROUPID AND taxgr.TAXID = taxident.TAXID AND taxrate.TAXID = taxident.TAXID AND taxrate.RATEID = taxgr.RATEID AND cardtax.ARTICLE = card.article AND cardtax.RGNID = 3  AND cardtax.datefrom = (SELECT MAX(crdtax.datefrom) FROM SUPERMAG.SMCARDTAX crdtax WHERE crdtax.article = card.article)' TO file;
    
    logToFile('importSupermag', 'importItem_1');
    
    IMPORT TABLE FROM file() TO id, name, shortName, idMeasurement, idClass, country, accepted, scale, width, length, height, vat;
    
    logToFile('importSupermag', 'importItem_2');
       
    FOR [GROUP SUM 1 IF id(INTEGER i) AND NOT item(id(i)) BY id(i)](ISTRING[100] id) DO NEW s = Item {
        id(s) <- id;
    }
   
    FOR Item s = item(id(INTEGER i)) DO {    
        caption(s) <- STRING[255](replace(name(i), '\t', ' '));
        shortName(s) <- shortName(i);
        UOM(s) <- UOM(TEXT (idMeasurement(i)));
        itemGroup(s) <- itemGroup(TEXT (idClass(i)));
        Item.country(s) <- GROUP MAX Country c IF upper(name(c)) == upper(country(i));
        width(s) <- max(min(width(i), 99999), -99999);
        length(s) <- max(min(length(i), 99999), -99999);
        height(s) <- max(min(height(i), 99999), -99999);
        inactive(s) <- accepted(i) != 1;
        passScales(s) <- scale(i) == '1';
        imported(s) <- TRUE;
        statusInSuperMag(s) <- accepted(i);
        VAT(s, Country c) <- GROUP MAX Tax.Range r IF valueRate(r) == vat(i) AND c = defaultCountry();        
    }
       
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT BARCODE, ARTICLE FROM Supermag.SVStoreUnits' TO file;
    
    IMPORT TABLE FROM file() TO name, id;
    
    name(INTEGER i) <- left(name(i), 15);
    //весовой товар 
    name(INTEGER i) <- substrFrom(name(i),3) WHERE substr(name(i),1,2) = '22' AND length(name(i)) = 7; 
     
    FOR imported(INTEGER i) AND NOT barcode(name(i)) DO NEW b = Barcode {
        id(b) <- ISTRING[15] (name(i));
    }
    FOR Barcode b = barcode(name(INTEGER i)) AND Item s = item(id(i)) DO {
        sku(b) <- s;
        transportPack(b) <- NULL;
        dataAmount(b) <- NULL;
        barcode(s) <- b;
        imported(b) <- TRUE;
    }
    
    // следующие 2 действия нужны, если штрих-код, который был упаковкой становится обычным штрих-кодом
    FOR Barcode b = barcode(name(INTEGER i)) AND Purchase.packBarcode(Sku s) = b DO {
        Purchase.packBarcode(s) <- NULL; 
    }

    FOR Barcode b = barcode(name(INTEGER i)) AND Purchase.barcodePack(Purchase.UserOrderDetail d) = b DO {
        Purchase.barcodePack(d) <- NULL;
    }
    
    logToFile('importSupermag', 'importItem_6');
    
    inactive(Item i ) <- TRUE WHERE i IS Item AND NOT imported(i);
    statusInSuperMag(Item i ) <- 2 WHERE i IS Item AND NOT imported(i);
//    DELETE Item i WHERE i IS Item AND NOT imported(i);
//    DELETE Barcode b WHERE b IS Barcode AND NOT transportPack(b) AND NOT imported(b);
    overImportItem();

    APPLY;
}

EXTEND FORM integrationData PROPERTIES importItem();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importItem()); } }

idItem = DATA LOCAL ISTRING[50] (INTEGER);
property = DATA LOCAL ISTRING[50] (INTEGER);
value = DATA LOCAL TEXT (INTEGER);

overImportItemAttribute ABSTRACT LIST ();

importItemAttribute 'Импорт доп. свойств товаров' () {
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT ARTICLE, PROPID, PROPVAL FROM Supermag.SVCARDPROPERTIES WHERE PROPID IN (\'packsize\', \'packsize2\', \'1\', \'17\', \'manufacturer\', \'manCountry\', \'expDate\', \'storeWetness\', \'storeTemperature\', \'packType\', \'supName\', \'alcoPercent\', \'Sys.Composition\', \'alcoYear\', \'alcoSugar\', \'alcoColor\', \'ekon_si\', \'brutto\', \'bruttoPack\', \'pack_height\', \'pack_length\', \'pack_width\', \'pack_pallet\', \'volume\')' TO file;
    // пока не импортируем, так как там ерунда - \'packbarcode\',         
    
    logToFile('importSupermag', 'importItemAttribute_1');
    
    IMPORT TABLE FROM file() TO idItem, property, value;
    
    logToFile('importSupermag', 'importItemAttribute_2');

    FOR property(INTEGER i) == 'packsize2' AND NUMERIC[14,3](trim(value(i))) > 0 AND NOT barcode(item(idItem(i)), TransportPack.outpack) DO NEW b = Barcode {
        sku(b) <- item(idItem(i));
        transportPack(b) <- TransportPack.outpack;
    }

    FOR property(INTEGER i) == 'packsize2' AND NUMERIC[14,3](trim(value(i))) > 0 AND Barcode b == barcode(item(idItem(i)), TransportPack.outpack) AND Item s = item(idItem(i)) DO {
        Purchase.packBarcode(s) <- b;
        amount(b) <- NUMERIC[14,3](trim(value(i)));
   }
    
    logToFile('importSupermag', 'importItemAttribute_3');
    
    FOR [GROUP SUM 1 IF property(INTEGER i) == '1' BY value(i)](TEXT name) AND name != '' AND NOT brandName(name) DO NEW b = Brand {
        name(b) <- ISTRING[50] (name);
    }
    FOR property(INTEGER i) == '1' DO {
        brand(Item s) <- brandName(value(i)) WHERE s == item(idItem(i));
    }
    
    logToFile('importSupermag', 'importItemAttribute_4');
    
    FOR [GROUP SUM 1 IF property(INTEGER i) == 'manufacturer' BY value(i)](TEXT name) AND name != '' AND NOT manufacturerName(name) DO NEW m = Manufacturer {
        name(m) <- ISTRING[200] (name);
    }
    FOR property(INTEGER i) == 'manufacturer' DO {
        manufacturer(Item s) <- manufacturerName(value(i)) WHERE s == item(idItem(i));
    }
    
    logToFile('importSupermag', 'importItemAttribute_5');
    
    FOR [GROUP SUM 1 IF property(INTEGER i) == 'manCountry' BY upper(value(i))](TEXT name) AND name != '' AND NOT (GROUP MAX Country c IF upper(name(c)) == name) DO NEW c = Country {
        name(c) <- ISTRING[50] (name);
    }
    FOR property(INTEGER i) == 'manCountry' DO {
        country(Item s) <- (GROUP MAX Country c IF upper(name(c)) == upper(value(i))) WHERE s == item(idItem(i));
    }
    
    logToFile('importSupermag', 'importItemAttribute_6');
    
    FOR property(INTEGER i) == '17' AND Item s = item(idItem(i)) DO {
        netWeight(s) <- NUMERIC[11,5](replace(trim(value(i)), ',', '.'));
        grossWeight(s) <- NUMERIC[11,5](replace(trim(value(i)), ',', '.'));
    }
    
    logToFile('importSupermag', 'importItemAttribute_7');
    
    FOR property(INTEGER i) == 'expDate' DO {
        expiryDays(Item s) <- INTEGER (getWord(value(i), ' ', 1)) WHERE s == item(idItem(i));
        expiryText(Item s) <- ISTRING[100] (value(i)) WHERE s = item(idItem(i));
    }
    
    logToFile('importSupermag', 'importItemAttribute_8');
    
    LOCAL condition = ISTRING[100](Item);
    
    FOR property(INTEGER i) == 'storeTemperature' DO {
        condition(Item s) <- ISTRING[100] (value(i)) WHERE s = item(idItem(i));
    }
    
    logToFile('importSupermag', 'importItemAttribute_9');
    
    FOR property(INTEGER i) == 'storeWetness' AND NOT value(i) == 'не обусловлено' AND NOT value(i) == 'не обусловлен' AND NOT value(i) == 'нет' AND NOT value(i) == ','
        AND NOT value(i) == '-' AND NOT value(i) == '"-"' AND NOT value(i) == '_' AND NOT value(i) == '/' AND NOT value(i) == '.' AND NOT value(i) == '--' DO {
        conditionsText(Item s) <- CONCAT '', condition(s), ', влажность: ' + ISTRING[100] (value(i)) WHERE s = item(idItem(i));
    }
    
    overImportItemAttribute();
    
    logToFile('importSupermag', 'importItemAttribute_10');
    
    FOR [GROUP SUM 1 IF property(INTEGER i) == 'packType' BY value(i)](TEXT name) AND name != '' AND NOT packTypeName(name) DO NEW t = PackType {
        name(t) <- ISTRING[200] (name);
    }
    FOR property(INTEGER i) == 'packType' DO {
        packType(Item s) <- packTypeName(value(i)) WHERE s = item(idItem(i));
    }
    
    logToFile('importSupermag', 'importItemAttribute_11');
    
    FOR property(INTEGER i) == 'supName' DO {
        originalCaption(Item s) <- ISTRING[100](value(i)) WHERE s = item(idItem(i));
    }
    
    logToFile('importSupermag', 'importItemAttribute_12');
    
    FOR [GROUP SUM 1 IF property(INTEGER i) == 'alcoPercent' BY value(i)](TEXT name) AND name != '' AND NOT alcoholName(name) DO NEW a = Alcohol {
        name(a) <- ISTRING[50] (name);
    }
    FOR property(INTEGER i) == 'alcoPercent' DO {
        alcohol(Item s) <- alcoholName(value(i)) WHERE s = item(idItem(i));
    }
    
    logToFile('importSupermag', 'importItemAttribute_13');
    
    FOR property(INTEGER i) == 'Sys.Composition' DO {
        description(Item s) <- value(i) WHERE s = item(idItem(i));
    }
    
    logToFile('importSupermag', 'importItemAttribute_20');
    
    FOR property(INTEGER i) == 'packsize' DO {
        MOQ(Item s) <- NUMERIC[15,4](value(i)) WHERE s = item(idItem(i));
    }
    FOR property(INTEGER i) == 'volume' DO {
        volume(Item s) <- NUMERIC[9,3](toNumeric(value(i))) WHERE s = item(idItem(i));
    }
    
    logToFile('importSupermag', 'importItemAttribute_14');
    
    FOR property(INTEGER i) == 'packbarcode' AND NOT barcode(item(idItem(i)), TransportPack.outpack) DO NEW b = Barcode {
        sku(b) <- item(idItem(i));
        transportPack(b) <- TransportPack.outpack;
    }
    FOR property(INTEGER i) == 'packbarcode' AND Barcode b == barcode(item(idItem(i)), TransportPack.outpack) DO {
        id(b) <- STRING[15](value(i));
    }
    logToFile('importSupermag', 'importItemAttribute_15');

    id(Barcode b) <- NULL WHERE transportPack(b) = TransportPack.outpack AND NOT [GROUP SUM 1 IF property(INTEGER i) = 'packbarcode' BY idItem(i)](id(sku(b))); 

    logToFile('importSupermag', 'importItemAttribute_15_1');
    
    FOR property(INTEGER i) == 'bruttoPack' AND Barcode b == barcode(item(idItem(i)), TransportPack.outpack) DO {
        weight(b) <- NUMERIC[11,5](replace(trim(value(i)), ',', '.'));
    }
    logToFile('importSupermag', 'importItemAttribute_16');
    FOR property(INTEGER i) == 'pack_height' AND Barcode b == barcode(item(idItem(i)), TransportPack.outpack) DO {
        height(b) <- NUMERIC[8,2](replace(trim(value(i)), ',', '.'));
    }
    logToFile('importSupermag', 'importItemAttribute_17');
    FOR property(INTEGER i) == 'pack_length' AND Barcode b == barcode(item(idItem(i)), TransportPack.outpack) DO {
        length(b) <- NUMERIC[8,2](replace(trim(value(i)), ',', '.'));
    }
    logToFile('importSupermag', 'importItemAttribute_18');
    FOR property(INTEGER i) == 'pack_width' AND Barcode b == barcode(item(idItem(i)), TransportPack.outpack) DO {
        width(b) <- NUMERIC[8,2](replace(trim(value(i)), ',', '.'));
    }
    logToFile('importSupermag', 'importItemAttribute_19');
    
    FOR property(INTEGER i) == 'pack_pallet' AND NUMERIC[14,3](replace(trim(value(i)), ',', '.')) > 0 AND NOT barcode(item(idItem(i)), TransportPack.oppl) DO NEW b = Barcode {
        sku(b) <- item(idItem(i));
        transportPack(b) <- TransportPack.oppl;
    }
    FOR property(INTEGER i) == 'pack_pallet' AND NUMERIC[14,3](replace(trim(value(i)), ',', '.')) > 0 AND Barcode b == barcode(item(idItem(i)), TransportPack.oppl) DO {
        amount(b) <- NUMERIC[14,3](replace(trim(value(i)), ',', '.'));
    }
    
    logToFile('importSupermag', 'importItemAttribute_21');
    APPLY;
    logToFile('importSupermag', 'importItemAttribute_22');
}

EXTEND FORM integrationData PROPERTIES importItemAttribute();
DESIGN integrationData { 
    supermagImportButtons { 
        NEW items {
            type = CONTAINERH;
            MOVE PROPERTY (importItem());
            MOVE PROPERTY (importItemAttribute());
        } 
    } 
}

idOrder (LegalEntityGroup g) = GROUP CONCAT TEXT (order(LegalEntityGroup gg)) + '.' IF level(g, gg), '' ORDER DESC level(g, gg); 

importSupplierGroup 'Импорт групп поставщиков' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL tree = ISTRING[100] (INTEGER);
    LOCAL name = ISTRING[100] (INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ID, TREE, NAME FROM Supermag.SASUPPLIERCLASS' TO file;
    
    IMPORT TABLE FROM file() TO id, tree, name;
    
    FOR id(INTEGER i) AND id(i) != 0 AND NOT legalEntityGroup('S' + id(i)) DO NEW g = LegalEntityGroup {
        id(g) <- 'S' + id(i);
    }
    
    LOCAL level = INTEGER (INTEGER);
    LOCAL parent = TEXT (INTEGER);
    
    level(INTEGER i) <- wordCount(tree(i), '.') (-) 1 WHERE imported(i);
    parent(INTEGER i) <- left(tree(i), length(tree(i)) - length((getWord(tree(i), '.', level(i))) + '.')) WHERE imported(i);
    
    FOR level(INTEGER i) AND LegalEntityGroup g = legalEntityGroup('S' + id(i)) ORDER level(i) DO {
    
        name(g) <- name(i);
        order(g) <- INTEGER (getWord(tree(i), '.', level(i)));
        parent(g) <- OVERRIDE (GROUP MAX LegalEntityGroup gg IF idOrder(gg) == parent(i)), legalEntityGroup('suppliers');
    }
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importSupplierGroup();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importSupplierGroup()); } }


importCustomerGroup 'Импорт групп покупателей' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL tree = ISTRING[100] (INTEGER);
    LOCAL name = ISTRING[100] (INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ID, TREE, NAME FROM Supermag.SACLIENTCLASS' TO file;
    
    IMPORT TABLE FROM file() TO id, tree, name;
    
    FOR id(INTEGER i) AND id(i) != 0 AND NOT legalEntityGroup('C' + id(i)) DO NEW g = LegalEntityGroup {
        id(g) <- 'C' + id(i);
    }
    
    LOCAL level = INTEGER (INTEGER);
    LOCAL parent = TEXT (INTEGER);
    
    level(INTEGER i) <- wordCount(tree(i), '.') (-) 1 WHERE imported(i);
    parent(INTEGER i) <- left(tree(i), length(tree(i)) - length((getWord(tree(i), '.', level(i))) + '.')) WHERE imported(i);
    
    FOR level(INTEGER i) AND LegalEntityGroup g = legalEntityGroup('C' + id(i)) ORDER level(i) DO {
    
        name(g) <- name(i);
        order(g) <- INTEGER (getWord(tree(i), '.', level(i)));
        parent(g) <- OVERRIDE (GROUP MAX LegalEntityGroup gg IF idOrder(gg) == parent(i)), legalEntityGroup('customers');
    }
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importCustomerGroup();
DESIGN integrationData { 
    supermagImportButtons { 
        NEW groups {
            type = CONTAINERH;
            MOVE PROPERTY (importSupplierGroup());
            MOVE PROPERTY (importCustomerGroup()); 
        }
    } 
}

importLegalEntity 'Импорт организаций' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL name = ISTRING[255] (INTEGER);
    LOCAL juname = ISTRING[255] (INTEGER);
    LOCAL shortName = ISTRING[255] (INTEGER);
    LOCAL inn = ISTRING[20] (INTEGER);
    LOCAL address = ISTRING[255] (INTEGER);
    LOCAL faddress = ISTRING[255] (INTEGER);
    LOCAL tel = ISTRING[40] (INTEGER);
    LOCAL fax = ISTRING[40] (INTEGER);
    LOCAL email = ISTRING[255] (INTEGER);
    LOCAL okpo = ISTRING[40] (INTEGER);
    LOCAL kpp = ISTRING[9] (INTEGER);
    LOCAL commentary = ISTRING[255] (INTEGER);
    LOCAL gln = ISTRING[13] (INTEGER);
    LOCAL own = ISTRING[1] (INTEGER);
    LOCAL clientClass = INTEGER (INTEGER);
    LOCAL supplierClass = INTEGER (INTEGER);
    LOCAL status = INTEGER (INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT ID, NAME, SHORTNAME, INN, ADDRESS, FADDRESS, nvl(TEL,FTEL) AS TEL, nvl(FAX, FFAX) AS FAX, nvl(EMAIL, FEMAIL) AS EMAIL, OKPO, KPP, COMMENTARY, GLN, OWNCLIENT, CLIENTCLASS, SUPPLIERCLASS, ACCEPTED FROM Supermag.SVCOMPANIES' TO file;

    IMPORT TABLE FROM file() TO id, name, shortName, inn, address, faddress, tel, fax, email, okpo, kpp, commentary, gln, own, clientClass, supplierClass, status;
    
    FOR id(INTEGER i) AND NOT legalEntity(TEXT (id(i))) DO NEW s = LegalEntity {
        id(s) <- ISTRING[100] (id(i));
        
        NEW w = Warehouse {
            name(w) <- ISTRING[150](shortName(i));
            address(w) <- ISTRING[150](faddress(i));
            id(w) <- ISTRING[100](id(i));
            legalEntity(w) <- s;
            stockGroup(w) <- warehouseGroup('external');
        }
    }
    
    FOR LegalEntity s = legalEntity(TEXT (id(INTEGER i))) DO {
        fullName(s) <- ISTRING[200] (OVERRIDE shortName(i), name(i));
        name(s) <- ISTRING[150] (name(i));
        UNP(s) <- STRING[9](left(inn(i), 9));
        
        IF NOT address(s, currentDate()) == address(i) THEN {
            dataAddress(s, DATE d) <- ISTRING[150] (address(i)) WHERE d == currentDate();
        }
        IF NOT postAddress(s, currentDate()) == faddress(i) THEN {
            dataPostAddress(s, DATE d) <- ISTRING[150] (faddress(i)) WHERE d == currentDate();
        }
        dataPhone(s, DATE d) <- CONCAT ', ', tel(i), fax(i) WHERE d == currentDate();
        email(s) <- email(i);
        OKPO(s) <- ISTRING[20] (okpo(i));
        note(s) <- commentary(i);
        GLN(s) <- gln(i);
        isCompany(s) <- own(i) == '1';
        isSupplier(s) <- TRUE IF supplierClass(i);
        isCustomer(s) <- TRUE IF clientClass(i);
        legalEntityGroup(s) <- OVERRIDE legalEntityGroup('companies') IF own(i) == '1', legalEntityGroup('S' + supplierClass(i)), legalEntityGroup('C' + clientClass(i));
        inactive(s) <- status(i) == 2;
    }
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importLegalEntity();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importLegalEntity()); } }

importStore 'Импорт магазинов' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL name = TEXT (INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ID, NAME FROM Supermag.SASTORECLASS' TO file;
    
    IMPORT TABLE FROM file() TO id, name;
    
    FOR id(INTEGER i) AND id(i) != 0 AND NOT stockGroup(TEXT (id(i))) DO NEW g = Store {
        id(g) <- ISTRING[100] (id(i));
        legalEntity(g) <- legalEntity('534');
    }
    
    FOR Store g = store(TEXT (id(INTEGER i))) DO {
        name(g) <- STRING[100](name(i));
    }
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importStore();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importStore()); } }

storeTypeInSupermag = DATA INTEGER (StoreType);

overImportStoreType ABSTRACT LIST ();

importStoreType 'Импорт форматов магазинов' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL name = TEXT (INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ID, TITLE FROM Supermag.SASTOREFORMATS' TO file;
    
    IMPORT TABLE FROM file() TO id, name;
    
    IF NOT chainStores('main') THEN NEW c = ChainStores {
        id(c) <- 'main';
    }
    
    FOR id(INTEGER i) AND NOT storeType('T' + id(i)) DO NEW g = StoreType {
        id(g) <- 'T' + id(i);
        chainStores(g) <- chainStores('main');
    }
    
    FOR StoreType g = storeType('T' + id(INTEGER i)) DO {
        name(g) <- STRING[100](name(i));
    }
    
    overImportStoreType();
    
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importStoreType();
DESIGN integrationData { 
    supermagImportButtons { 
        NEW stores {
            type = CONTAINERH;
            MOVE PROPERTY (importStore());
            MOVE PROPERTY (importStoreType());
        } 
    } 
}

idGroupWarehouseInSuperMag 'ид группы складов (вне магазинов)' = DATA INTEGER ();

overImportDepartmentStore ABSTRACT LIST ();

idParentStock = DATA LOCAL INTEGER (INTEGER);
idStocks = DATA LOCAL INTEGER (INTEGER);

importDepartmentStore 'Импорт отделов магазинов и складов' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL name = ISTRING[255] (INTEGER);
    LOCAL idClass = INTEGER (INTEGER);
    LOCAL address = ISTRING[255] (INTEGER);
    LOCAL idFormat = INTEGER (INTEGER);
    LOCAL idCompany = INTEGER (INTEGER);
 //   LOCAL idParentStock = INTEGER (INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT ID, NAME, IDCLASS, ADDRESS, FORMATID, l.CLIENTID AS COMPANYID, PARENTLOC FROM Supermag.SVGRANTEDLOCS g, Supermag.SMOWNCLIENTLOCS l WHERE g.ID = l.LOCID' TO file;
    
    IMPORT TABLE FROM file() TO id, name, idClass, address, idFormat, idCompany, idParentStock;
        
    FOR id(INTEGER i) AND NOT stock(TEXT (id(i))) AND NOT idClass(i) = idGroupWarehouseInSuperMag() DO NEW s = DepartmentStore {
        id(s) <- ISTRING[100] (id(i));
    }
    
    FOR DepartmentStore s = stock(TEXT (id(INTEGER i))) AND NOT idClass(i) = idGroupWarehouseInSuperMag() DO {        
        name(s) <- ISTRING[150](name(i));
        store(s) <- store(TEXT (idClass(i)));
    }
    
    FOR INTEGER i = [GROUP LAST INTEGER ii ORDER idFormat(ii), address(ii) BY store(TEXT (idClass(ii)))](Store st) DO {
        address(st) <- ISTRING[150](address(i));
        storeType(st) <- storeType('T' + idFormat(i));
        legalEntity(st) <- legalEntity(TEXT (idCompany(i)));
    }
    
    // это склады распределительного центра
    FOR id(INTEGER i) AND NOT stock(TEXT (id(i))) AND idClass(i) = idGroupWarehouseInSuperMag() DO NEW s = Warehouse {
        id(s) <- ISTRING[100] (id(i));
    }
    
    FOR Warehouse s = stock(TEXT (id(INTEGER i))) AND idClass(i) = idGroupWarehouseInSuperMag() DO {     
        name(s) <- ISTRING[150](name(i));
        fullName(s) <- ISTRING[150](name(i));
        stockGroup(s) <- warehouseGroup(TEXT (idGroupWarehouseInSuperMag()));
        address(s) <- OVERRIDE ISTRING[150](address(i)), '';
        legalEntity(s) <- legalEntity(TEXT (idCompany(i)));
    }
    
    idStocks(INTEGER i) <- id(i);
    overImportDepartmentStore();
    
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importDepartmentStore(), idGroupWarehouseInSuperMag();
DESIGN integrationData { supermagImportButtons {
    NEW importStore {
        type = CONTAINERH;
        MOVE PROPERTY (importDepartmentStore());
        MOVE PROPERTY (idGroupWarehouseInSuperMag());
    } 
}}

in 'Отм.' = DATA BOOLEAN (Stock);
stocks 'Склады для импорта' () = GROUP CONCAT id(Stock st) IF in(st), ',' ORDER id(st) CHARWIDTH 50;

FORM dialogDepartmentStores 'Склады'
    OBJECTS d = Stock
    PROPERTIES (d) in
    PROPERTIES (d) READONLY id, name, nameStore
    FILTERS d IS DepartmentStore OR isCompany(legalEntity(d))
    FILTERGROUP active FILTER 'Активные' active(d) DEFAULT
    FILTERGROUP in FILTER 'Отмеченные' in(d)
    ORDER nameStore(d), name(d)
;

DESIGN dialogDepartmentStores {
    size = (600, 600);
}

//---------------------------------------------------------------------------------------------------------------------импорт списков товаров
importSkuLists 'Импорт списков товаров' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL tree = ISTRING[100] (INTEGER);
    LOCAL name = ISTRING[250] (INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ID, TREE, NAME FROM Supermag.SACardAssort' TO file;
    
    IMPORT TABLE FROM file() TO id, tree, name;
    
    IF NOT list('all') THEN NEW g = List {
        id(g) <- 'all';
        name(g) <- 'Все';
    }
    
    FOR id(INTEGER i) AND id(i) != 0 AND NOT list(TEXT (id(i))) DO NEW g = List {
        id(g) <- ISTRING[100] (id(i));
    }
    
    LOCAL level = INTEGER (INTEGER);
    LOCAL parent = TEXT (INTEGER);
    LOCAL idOrder = ISTRING[20](List);
    
    level(INTEGER i) <- wordCount(tree(i), '.') (-) 1 WHERE imported(i);
    parent(INTEGER i) <- left(tree(i), length(tree(i)) - length((getWord(tree(i), '.', level(i))) + '.')) WHERE imported(i);
    
    FOR level(INTEGER i) AND List g = list(TEXT (id(i))) DO {
    
        name(g) <- name(i);
        order(g) <- INTEGER (getWord(tree(i), '.', level(i)));
        idOrder(g) <- tree(i);
    }
    FOR level(INTEGER i) AND List g = list(TEXT (id(i))) ORDER level(i) DO {
        
        parent(g) <- OVERRIDE (GROUP MAX List gg IF idOrder(gg) == parent(i)), list('all');
    }
    
    APPLY;
    
    LOCAL idList = INTEGER (INTEGER);
    LOCAL idItem = ISTRING[100] (INTEGER);
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT IDASSORT, ARTICLE FROM Supermag.SMCardAssort' TO file;
    
    IMPORT TABLE FROM file() TO idList, idItem;
    
    LOCAL imported = BOOLEAN (ListDetail);
    
    FOR Item s == item(idItem(INTEGER i)) AND List l = list(TEXT (idList(i))) AND NOT listDetail(s, l) DO NEW d = ListDetail {
        list(d) <- l;
        sku(d) <- s;
    }
    FOR Item s == item(idItem(INTEGER i)) AND List l = list(TEXT (idList(i))) AND ListDetail d = listDetail(s, l) DO {
        imported(d) <- TRUE;
    }
    
    DELETE ListDetail d WHERE d IS ListDetail AND NOT imported(d);
    
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importSkuLists();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importSkuLists()); } }

defaultCompany = DATA LegalEntity();
nameDefaultCompany 'Компания по умолчанию' () = name(defaultCompany());

EXTEND FORM options PROPERTIES nameDefaultCompany();

DESIGN options {
    commons {
        MOVE PROPERTY (nameDefaultCompany());
    }
}

importBank 'Импорт банков' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL name = STRING[255](INTEGER);
    LOCAL address = STRING[255](INTEGER);
    LOCAL bic = STRING[40](INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ID, TITLE, ADDRESS, BIC FROM Supermag.SABanks' TO file;
    
    IMPORT TABLE FROM file() TO id, name, address, bic;
    
    FOR id(INTEGER i) AND NOT bank(TEXT (id(i))) DO NEW b = Bank {
        id(b) <- STRING[100] (id(i));
    }
    
    FOR Bank b = bank(TEXT (id(INTEGER i))) DO {
        name(b) <- STRING[200](name(i));
        
        IF NOT address(b, currentDate()) == address(i) THEN {
            dataAddress(b, DATE d) <- STRING[150](address(i)) WHERE d == currentDate() AND NOT address(b, currentDate()) == address(i);
        }
        MFO(b) <- STRING[11](bic(i));
    }
    
    APPLY;
}

importAccount 'Импорт счетов' () {
    
    LOCAL idLegalEntity = INTEGER (INTEGER);
    LOCAL idBank = INTEGER (INTEGER);
    LOCAL account = STRING[40](INTEGER);
    LOCAL active = STRING[1](INTEGER);
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT IDCLIENT, BANKID, ACCOUNT, ISACTUAL FROM Supermag.SMClientBanks' TO file;
    
    IMPORT TABLE FROM file() TO idLegalEntity, idBank, account, active;
    
    FOR [GROUP SUM 1 IF legalEntity(TEXT (idLegalEntity(INTEGER i))) BY account(i), TEXT (idLegalEntity(i))](STRING[40] acc, STRING[100] id) 
        AND NOT accountID(acc, id) DO NEW a = Bank.Account {
        number(a) <- acc;
        legalEntity(a) <- legalEntity(id);
    }
    
    FOR Bank.Account a = accountID(account(INTEGER i), TEXT (idLegalEntity(i))) ORDER active(i) DO {
        bank(a) <- bank(TEXT (idBank(i)));
        inactive(a) <- active(i) == '0';
    }
    FOR LegalEntity l = legalEntity(TEXT (idLegalEntity(INTEGER i))) DO {
        userAccount(l) <- Bank.defaultAccount(l);
    }
    
    APPLY;
}

EXTEND FORM integrationData PROPERTIES () importBank, importAccount;
DESIGN integrationData { 
    supermagImportButtons { 
        NEW accounts {
            type = CONTAINERH;
            MOVE PROPERTY (importBank());
            MOVE PROPERTY (importAccount());
        } 
    } 
}

//---------------------------------------------------------------------------------------расчетные виды цен
importCalcPriceListType 'Импорт видов цен' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL name = ISTRING[50] (INTEGER);
    LOCAL formatid = INTEGER (INTEGER);
  
    LOCAL file = FILE ();
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ID, NAME, FORMATID FROM Supermag.SMPriceTypes WHERE WITHDUE = 1 AND NOT FORMATID IS NULL' TO file;

    IMPORT TABLE FROM file() TO id, name, formatid;
    
    FOR id(INTEGER i) AND NOT dataPriceListType('D' + TEXT (id(i))) DO NEW s = DataPriceListType {
        id(s) <- 'D' + ISTRING[100] (id(i));
    }
    
    FOR DataPriceListType t = dataPriceListType('D' + TEXT (id(INTEGER i))) DO {       
        name(t) <- name(i);
        includeVAT(t) <- TRUE;
        currency(t) <- defaultCurrency();
        roundCondition(t) <- GROUP MAX RoundCondition c IF priceRound(c) == 2 AND currency(c) == defaultCurrency();
    }
    
    FOR StoreType t = storeType('T' + TEXT (formatid(INTEGER i))) DO {
        retailPriceListType(t) <- priceListType('D' + TEXT (id(i)));
    }   
       
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ID, NAME, FORMATID FROM Supermag.SMPriceTypes WHERE WITHDUE = 1' TO file;
    
    IMPORT TABLE FROM file() TO id, name;
    
    FOR id(INTEGER i) AND NOT calcPriceListType('C' + TEXT (id(i))) DO NEW s = CalcPriceListType {
        id(s) <- 'C' + ISTRING[100] (id(i));
    }
    
    FOR CalcPriceListType t = calcPriceListType('C' +TEXT (id(INTEGER i))) DO {        
        name(t) <- name(i);
        includeVAT(t) <- TRUE;
        currency(t) <- defaultCurrency();
        roundCondition(t) <- GROUP MAX RoundCondition c IF priceRound(c) == 2 AND currency(c) == defaultCurrency();
        groupType(t) <- SystemGroupType.skuGroupType;  
    }  
    
    APPLY;
}

importCalcExrtaCharge 'Импорт надбавок по расчетным видам цен' () {
    LOCAL file = FILE ();
    
    LOCAL idGroup = INTEGER (INTEGER);
    LOCAL markup = NUMERIC[8,4] (INTEGER);
    LOCAL idType = INTEGER (INTEGER);
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT PRICETYPE, IDCLASS, EXTRACHARGE FROM Supermag.SMMARKUPCLASS WHERE NOT EXTRACHARGE IS NULL' TO file;
    
    IMPORT TABLE FROM file() TO idType, idGroup, markup;
    
    LOCAL idItemGroup = STRING[100](INTEGER);
    
    idItemGroup (INTEGER i) <- OVERRIDE 'all' IF idGroup(i) == 0, STRING[100](idGroup(i));
    
    FOR idType(INTEGER i) AND CalcPriceListType t = calcPriceListType('C' + TEXT (idType(i))) AND ItemGroup g = itemGroup(idItemGroup(i)) DO {
        dataMarkup(t, g) <- NUMERIC[8,2](markup(i));
    }
    
    dataMarkup(CalcPriceListType t, ItemGroup g) <- NULL WHERE NOT [GROUP SUM 1 BY calcPriceListType('C' + TEXT (idType(INTEGER i))), itemGroup(idItemGroup(i))](t, g);
    
    LOCAL idItem = STRING[15] (INTEGER);
    
    EXTERNAL  SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT PRICETYPE, ARTICLE, EXTRACHARGE FROM Supermag.SMExtraCharge WHERE NOT EXTRACHARGE IS NULL' TO file;
    
    IMPORT TABLE FROM file() TO idType, idItem, markup;
    
    FOR Item s = item(idItem(INTEGER i)) AND CalcPriceListType t == calcPriceListType('C' + TEXT (idType(i))) DO {
        dataMarkup(t, s) <- NUMERIC[8,2](markup(i));
    }
    
    dataMarkup(CalcPriceListType t, Item s) <- NULL WHERE NOT [GROUP SUM 1 BY calcPriceListType('C' + TEXT (idType(INTEGER i))), item(idItem(i))](t, s);
    
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importCalcPriceListType(), importCalcExrtaCharge();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importCalcPriceListType()); MOVE PROPERTY (importCalcExrtaCharge()); } }


//---------------------------------------------------------------------------------------------Договоры
factoring 'Факторинг' = DATA BOOLEAN (UserContractSku);

EXTEND FORM userContractSku PROPERTIES factoring(c);

DESIGN userContractSku { params {
        MOVE PROPERTY (factoring(c));
}}

userContractSku = GROUP MAX UserContractSku c BY supplier(c), customer(c);

paymentPeriod (INTEGER days, INTEGER bank) = GROUP MAX PaymentPeriod p IF percent(p) == 100 
    AND type(paymentCondition(p)) == AgreementPaymentType.prepayment AND bank == (OVERRIDE 1 IF bankingDays(p), 0) BY countDays(p);

regExp = '.*((3[01]|[12][0-9]|0[1-9])\\.(1[012]|0[1-9])\\.((?:19|20)\\d\{2\})).*';
dateFromString = FORMULA NULL STRING PG 'SELECT (regexp_match($1, $2))[1]';

daysSupplier 'Кол-во дней для синхронизации ПСЦ' = DATA INTEGER ();
dateFromS () = sum(currentDate(), -daysSupplier());
dateFromST () = toDateDDMMYY(dateFromS());

fieldDateSupplierPriceList 'Поле даты для синхронизации' = DATA STRING[10] ();
overfieldDateSupplierPriceList () = OVERRIDE fieldDateSupplierPriceList(), 'ENDSAT';

numberSupplierContract 'Номер контракта поставщика' = DATA STRING[20] ();

EXTEND FORM integrationData PROPERTIES () daysSupplier, numberSupplierContract;
DESIGN integrationData { supermagImportButtons { 
    NEW contractData {
        type = CONTAINERH;
        NEW contractButtons { };
        NEW contractConditions {
            MOVE PROPERTY (daysSupplier()) { caption = 'Кол-во дней синхронизации'; alignment = CENTER; }
            MOVE PROPERTY (numberSupplierContract()) { caption = 'или номер для импорта'; alignment = CENTER; }
        }       
    }
} }


contractTypeInSuperMag = DATA INTEGER (UserContractSku);
delayPaymentInSuperMag = DATA INTEGER (UserContractSku);
isBankDaysInSuperMag = DATA INTEGER (UserContractSku);
stateInSuperMag = DATA INTEGER (UserContractSku);

contractTypeInSuperMag = DATA INTEGER (UserPriceList);
delayPaymentInSuperMag = DATA INTEGER (UserPriceList);
isBankDaysInSuperMag = DATA INTEGER (UserPriceList);
stateInSuperMag = DATA INTEGER (PriceList);

id = DATA ISTRING[100](UserPriceListDetail) INDEXED;
userPriceListDetail = GROUP AGGR UserPriceListDetail d WHERE d IS UserPriceListDetail BY id(d);

id = DATA ISTRING[100](UserRepricingDetail) INDEXED;
userRepricingDetail = GROUP AGGR UserRepricingDetail d WHERE d IS UserRepricingDetail BY id(d);

overImportSupplierPrice ABSTRACT LIST ();

//надо ггрузить все одним действием в договоры и псц потому, что если делать разными действиями срабатывают CONSTRAINTы на соответствие
importContract 'Импорт из контрактов с поставщиками (в договоры и ПСЦ)' () { 
    LOCAL id = ISTRING[50] (INTEGER);
    LOCAL agrId = ISTRING[50] (INTEGER);
    LOCAL date = DATETIME (INTEGER);
    LOCAL posted = INTEGER (INTEGER);
    LOCAL begin = DATETIME (INTEGER);
    LOCAL end = DATETIME (INTEGER);
    LOCAL idContragent = INTEGER (INTEGER);
    LOCAL idCompany = INTEGER (INTEGER);
    LOCAL title = ISTRING[255] (INTEGER);
    LOCAL paymentDelay = INTEGER (INTEGER);
    LOCAL isCalendarDelay = ISTRING[1] (INTEGER);
    LOCAL contractType = INTEGER (INTEGER);
    LOCAL imported = BOOLEAN (UserPriceList);    
    LOCAL imported = BOOLEAN (UserContractSku);    
    LOCAL filterSql = TEXT ();
    
    LOCAL file = FILE ();
            
    filterSql() <- 'cc.ENDSAT >= TO_DATE(\'' + toDateISO(dateFromS()) + '\',\'YYYY-MM-DD\')'; 
    IF length(numberSupplierContract()) > 0 THEN
       filterSql() <- 'cc.id = \'' + numberSupplierContract() + '\''; 
               
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
    EXEC 'SELECT cc.ID, cc.CREATEDAT, cc.DOCSTATE, cc.BEGINSAT, cc.ENDSAT, cc.CLIENTINDEX, cc.OURSELFCLIENT, cc.TITLE, cc.PAYMENTDELAY, cc.ISCALENDARDELAY, cc.CONTRACTTYPE FROM Supermag.SVDocumentsCO cc WHERE '+filterSql() TO file;
    
    IMPORT TABLE FROM file() TO id, date, posted, begin, end, idContragent, idCompany, title, paymentDelay, isCalendarDelay, contractType;

    //  дополняем базу условиями отсрочки
    LOCAL isBankDays = INTEGER (INTEGER);
    isBankDays(INTEGER i) <- CASE WHEN isCalendarDelay(i) = '1' THEN 0 ELSE 1 WHERE imported(i);
    
    FOR [GROUP SUM 1 IF imported(INTEGER i) BY paymentDelay(i), isBankDays(i)](INTEGER d, INTEGER b)  AND NOT paymentPeriod(d, b)  DO NEW p = PaymentCondition {
        type(p) <- AgreementPaymentType.prepayment;
        bankingDays(p) <- b = 1;
               
        NEW pp = PaymentPeriod {
            paymentCondition(pp) <- p;
            percent(pp) <- 100;
            countDays(pp) <- d;
        }
    }

    // создаем новые договоры
    FOR id(INTEGER i) AND NOT userContractSku(id(i)) DO NEW p = UserContractSku { id(p) <- id(i); }
    
    // обновляем договоры    
    FOR UserContractSku c == userContractSku(id(INTEGER i)) DO {
        contractTypeInSuperMag(c) <- contractType(i);
        stateInSuperMag(c) <- posted(i); 
        delayPaymentInSuperMag(c) <- paymentDelay(i);
        isBankDaysInSuperMag(c) <- isBankDays(i);       
        type(c) <- ContractSkuType.sale;
        number(c) <- ISTRING[28] (id(i));
        dateFrom(c) <- DATE (begin(i));
        dateTo(c) <- DATE (end(i));       
        supplier(c) <- legalEntity(TEXT (idContragent(i)));
        customer(c) <- defaultCompany();        
        note(c) <- STRING[100] (title(i));
        paymentCondition(c) <- paymentCondition(paymentPeriod(paymentDelay(i), isBankDays(i))) WHERE paymentDelay(i) > 0;      
        currency(c) <- OVERRIDE currency(supplier(c)), defaultCurrency();  
        imported(c) <- TRUE;              
    }

    // создаем новые ПСЦ
    FOR id(INTEGER i) AND NOT userPriceList(id(i)) DO NEW p = UserPriceList {  id[UserPriceList](p) <- id(i);  }
    // обновляем ПСЦ
    FOR UserPriceList p == userPriceList(id(INTEGER i)) DO {
        contractTypeInSuperMag(p) <- contractType(i);
        operation(p) <- PriceList.operation('supplier');
        number(p) <- ISTRING[28] (id(p));
        date(p) <- DATE(date(i));
        time(p) <- 00:00;
        isPosted(p) <- posted(i) = 3 OR posted(i) = 0;
        stateInSuperMag(p) <- posted(i); 
        fromTime(p) <- 00:00;
        toDate(p) <- DATE(end(i));
        contractSku(p) <- userContractSku(TEXT (id(i)));
        company(p) <- supplier(contractSku(p));
        note(p) <- title(i);
        fromDate(p) <- MAX DATE(begin(i)), dateFrom(contractSku(p)) ;
        delayPaymentInSuperMag(p) <- paymentDelay(i);
        isBankDaysInSuperMag(p) <- isBankDays(i);
        allStocks(p) <- NULL;
        imported(p) <- TRUE;        
    }   
     
     // указываем какие магазины входят в ПСЦ            
    LOCAL idStock = INTEGER (INTEGER);    
    LOCAL idDoc = ISTRING[50] (INTEGER);    

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT cc.ID, cl.locationid FROM  Supermag.SVDocumentsCO cc, Supermag.SvDocNoPriceCQ q, Supermag.SMContractLocations cl WHERE cc.doctype=\'CO\' AND q.docco = cc.id AND cl.id = q.id AND ' + filterSql() TO file;

    IMPORT TABLE FROM file() TO idDoc, idStock;

    FOR [GROUP SUM 1 BY userPriceList(idDoc(INTEGER i))](UserPriceList p) DO {
        dataIn(p, Stock s) <- TRUE IF [GROUP SUM 1 BY userPriceList(idDoc(INTEGER i)), stock(TEXT (idStock(i)))](p, s);
    }     
    
    overImportSupplierPrice();

    //загружаем спецификаци    
    LOCAL type = ISTRING[2](INTEGER);
    LOCAL specItem = INTEGER (INTEGER);
    LOCAL idItem = ISTRING[50](INTEGER);
    LOCAL packSize = NUMERIC[14,3](INTEGER);
    LOCAL price = NUMERIC[19,4](INTEGER);
    LOCAL imported = BOOLEAN (UserPriceListDetail);

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT cc.DOCTYPE, cc.ID, cc.CREATEDAT, cd.SPECITEM, cd.ARTICLE, cd.packSize, cd.itemPrice FROM Supermag.SVDocumentsCO cc, Supermag.SVSpecCO cd WHERE cc.doctype=\'CO\' AND cd.docid=cc.id AND cd.doctype=\'CO\' AND ' + filterSql() TO file;

    IMPORT TABLE FROM file() TO type, idDoc, date, specItem, idItem, packSize, price;

    id(INTEGER i) <- CONCAT '', 'S', type(i), idDoc(i), specItem(i) WHERE imported(i); 

    FOR userPriceList(idDoc(INTEGER i)) AND NOT userPriceListDetail(id(i)) DO NEW d = UserPriceListDetail {
        id(d) <- id(i);
        userPriceList(d) <- userPriceList(idDoc(i));
    }

    FOR UserPriceListDetail d = userPriceListDetail(id(INTEGER i)) DO {
        sku(d) <- item(idItem(i));  
        price(d, LedgerPriceListType t) <- NUMERIC[16,4](price(i)) WHERE t == dataPriceListType(id(operation(userPriceList(d))));
        imported(d) <- TRUE;
        dataIndex(d) <- specItem(i);
    }

//    IF overfieldDateContract() = 'ENDSAT' THEN {
//       DELETE UserPriceList p WHERE toDate(p) >= dateFromS() AND (id(operation(p)) == 'supplier' OR id(operation(d)) = 'supplierakcia') AND NOT imported(p);
//       DELETE UserPriceListDetail d WHERE  toDate(d) >= dateFromS() AND (id(operation(d)) = 'supplier' OR id(operation(d)) = 'supplierakcia') AND NOT imported(d);
    APPLY;
}

//importContractFromCompanies 'Импорт договоров из карточек контрагентов' () { 
//   
//    LOCAL id = INTEGER (INTEGER);
//    LOCAL file = FILE ();
//    
//    //определяем условия оплаты в договоры из свойств контрагентов
//    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
//        EXEC 'SELECT ID, PAYMENTDELAY, SUPPLIERFLAGS FROM Supermag.SVCompanies' TO file;
//    
//    LOCAL delay = INTEGER (INTEGER);
//    LOCAL bankings = INTEGER (INTEGER);
//    
//    IMPORT TABLE FROM file() TO id, delay, bankings;
//    
//    // добавляем новые условия сроков оплаты
//    LOCAL bank = INTEGER (INTEGER);
//    bank(INTEGER i) <- CASE WHEN bankings(i) == 26 THEN 1 ELSE 0 WHERE imported(i);
//    FOR [GROUP SUM 1 IF imported(INTEGER i) BY delay(i), bank(i)](INTEGER d, INTEGER b)  AND NOT paymentPeriod(d, b)  DO NEW p = PaymentCondition {
//        type(p) <- AgreementPaymentType.prepayment;
//        bankingDays(p) <- b == 1;
//        
//        NEW pp = PaymentPeriod {
//            paymentCondition(pp) <- p;
//            percent(pp) <- 100;
//            countDays(pp) <- d;
//        }
//    }
//    // записываем условия сроков оплаты контрагентам
//    LOCAL paymentCondition = PaymentCondition (LegalEntity);    
//    FOR LegalEntity l = legalEntity(TEXT (id(INTEGER i)))  DO {
//        paymentCondition(l) <- paymentCondition(paymentPeriod(delay(i), bank(i)));
//    }      
//    
//    // импорт договоров
//    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT IDCLIENT, PROPID, PROPVAL FROM Supermag.SMClientProperties' TO file;
//    
//    IMPORT TABLE FROM file() TO id, property, value;
//    
//    // находим контрагентов у кторых есть свойство факторинг
//    LOCAL factoring = BOOLEAN (LegalEntity);
//    FOR LegalEntity l = legalEntity(TEXT (id(INTEGER i)))  AND property(i) == 'factor' DO {
//        factoring(l) <- value(i) == 'факторинг';
//    }   
//    
//    // для всех контрагентов у которых есть свойство договор создаем договоры 
//    FOR LegalEntity l = legalEntity(TEXT (id(INTEGER i))) AND NOT userContractSku(l, defaultCompany()) AND property(i) == '3' DO NEW c = UserContractSku {
//        supplier(c) <- l;
//        customer(c) <- defaultCompany();
//    }
//    
//    LOCAL dateFromStr = STRING (INTEGER);
//    
//    dateFromStr(INTEGER i) <- OVERRIDE dateFromString(value(i),regExp()), '01.01.2001' WHERE property(i) == '3';
//    
//    // обновляем данные договоров
//    FOR UserContractSku c == userContractSku(legalEntity(TEXT (id(INTEGER i))), defaultCompany()) AND property(i) == '3' DO {
//        note(c) <- STRING[100](value(i));
//        currency(c) <- OVERRIDE currency(supplier(c)), defaultCurrency();
//        type(c) <- ContractSkuType.sale;
//        dateFrom(c) <- IF length(dateFromStr(i))=10  THEN toDateFormat(dateFromStr(i), 'DD.MM.YYYY') ELSE 2001_01_01;
//        number(c) <- STRING[28](replace(trim(getWord(value(i), 'от', 1)), '№', ''));
//        paymentCondition(c) <- paymentCondition(supplier(c));
//        factoring(c) <- factoring(supplier(c));
////        dataInCustomer(Stock s, c) <- TRUE IF isCompany(s);
//    }   
//    APPLY;
//}

EXTEND FORM integrationData PROPERTIES importContract();
DESIGN integrationData { contractButtons { MOVE PROPERTY (importContract()); } }

DOWM (INTEGER n) = GROUP MAX DOW d IF (numberM(d) + 1) == n;

dateFromSeparation 'Дата с' = DATA DATE ();

importSeparation 'Импорт признаков разделения' () {
    
    LOCAL id = STRING[50] (INTEGER);
    LOCAL idLegalEntity = INTEGER (INTEGER);
    LOCAL name = STRING[50] (INTEGER);
    
    LOCAL file = FILE ();
    LOCAL filterSql = TEXT ();
    //фильтр на отбор
    filterSql() <- 'cc.CONTRACTTYPE = 0 AND cc.DOCSTATE > 0 AND cc.ENDSAT >= TO_DATE(\'' + toDateISO(dateFromS()) + '\',\'YYYY-MM-DD\')'; 
    IF length(numberSupplierContract()) > 0 THEN
       filterSql() <- 'cc.id = \'' + numberSupplierContract() + '\''; 
    
    // загружаем признаки разделения из свойства "товар" контракта с поставщиком
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT cc.ID, cc.CLIENTINDEX, COALESCE(dl.valstr, cc.title) FROM Supermag.SVDocumentsCO cc, Supermag.SVDocLabels dl WHERE dl.docid(+) = cc.id AND dl.name(+) = \'товар\' AND ' + filterSql() TO file;
        
    IMPORT TABLE FROM file() TO id, idLegalEntity, name;
    
    FOR [GROUP SUM 1 IF imported(INTEGER i) BY id(i)](STRING[100] id) AND NOT separation(id) DO NEW s = Separation {
        id(s) <- id;
    }
    
    FOR INTEGER i = [GROUP MIN INTEGER ii IF imported(ii) BY id(ii)](STRING[100] id) AND Separation s = separation(id) DO {
        name(s) <- name(i);
        legalEntity(s) <- legalEntity(TEXT (idLegalEntity(i)));
    }
    
    // товары из договора помечаем в признак разделения
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT s.DOCID, s.ARTICLE FROM Supermag.SVSpecCO s, Supermag.SVDocumentsCO cc WHERE cc.doctype=\'CO\' AND s.docid = cc.id AND s.doctype=\'CO\' AND ' + filterSql() TO file;
    
    IMPORT TABLE FROM file() TO id, idItem;
    
    dataSeparation(LegalEntity l, Item sk) <- NULL;
    
    FOR INTEGER i = [GROUP LAST INTEGER ii IF imported(ii) ORDER DESC id(ii), ii BY idItem(ii)](STRING[100] id) DO {
        dataSeparation(LegalEntity l, Item sk) <- separation(id(i)) WHERE sk == sku(id) AND l == legalEntity(separation(id(i)));
    }
    
    APPLY;
}

EXTEND FORM integrationData PROPERTIES () importSeparation, dateFromSeparation;
DESIGN integrationData { supermagImportButtons { 
        contractButtons {
            MOVE PROPERTY (importSeparation()) { caption ='Импорт признаков разделения';};
        } 
    } 
}

scheduleOrderTime (scheduleOrder, orderDOW) = GROUP AGGR ScheduleOrderTime scheduleOrderTime BY scheduleOrder (scheduleOrderTime), orderDOW (scheduleOrderTime);

shipmentSM = DATA STRING (ScheduleOrderTime ) IN id; 
orderSM = DATA STRING (ScheduleOrderTime ) IN id; 

//--------------------------------------------------------------графики заказов
importScheduleOrder 'Импорт графиков заказов' () {
    
    LOCAL id = INTEGER (INTEGER);
    LOCAL docId = STRING[50] (INTEGER);
    LOCAL idSep = STRING[50] (INTEGER);
    LOCAL idSupplier = INTEGER (INTEGER);
    LOCAL idCustomer = INTEGER (INTEGER);
    LOCAL orderDOW = STRING[1] (INTEGER);
    LOCAL orderDOWM = STRING[1] (INTEGER);
    LOCAL shipmentDOW = STRING[7] (INTEGER);
    LOCAL startDate = DATETIME (INTEGER);
    LOCAL endDate = DATETIME (INTEGER);
    LOCAL days = INTEGER (INTEGER);
    LOCAL note = STRING[100] (INTEGER);
    LOCAL shipmentDay = INTEGER (INTEGER);
    LOCAL idStock = INTEGER (INTEGER);    
    LOCAL imported = BOOLEAN (Purchase.ScheduleOrder);
    LOCAL imported = BOOLEAN (Purchase.ScheduleOrderTime);  
    
    LOCAL file = FILE ();
    LOCAL filterSql = TEXT ();
    //фильтр на отбор
    filterSql() <- 'cc.CONTRACTTYPE = 0 AND cc.DOCSTATE > 0 AND cc.ENDSAT >= TO_DATE(\'' + toDateISO(dateFromS()) + '\',\'YYYY-MM-DD\')'; 
    IF length(numberSupplierContract()) > 0 THEN
       filterSql() <- 'cc.id = \'' + numberSupplierContract() + '\''; 
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT d.ID, d.DOCTID, q.docco, cc.CLIENTINDEX, ao.client, ao.weekday, q.deliverydays, q.BEGINSAT, q.ENDSAT, ao.dayinterval, dl.valstr FROM Supermag.SVDocumentsCO cc, Supermag.SvDocNoPriceCQ q, Supermag.scautoorderdoc d, Supermag.scautoorder ao, Supermag.SVDocLabels dl WHERE q.docco = cc.ID AND d.DOCTID = q.ID AND ao.id = d.id AND dl.docid(+) = q.docco AND dl.name(+) = \'товар\' AND ' + filterSql() TO file;
        
    IMPORT TABLE FROM file() TO id, docId, idSep, idSupplier, idCustomer, orderDOW, shipmentDOW, startDate, endDate, days, note;
       
    FOR [GROUP SUM 1 IF imported(INTEGER i) BY docId(i)](STRING[100] id) AND NOT scheduleOrder(id) DO NEW s = Purchase.ScheduleOrder {
        id(s) <- id;
    }
    
    FOR INTEGER i = [GROUP MIN INTEGER ii IF imported(ii) BY docId(ii)](STRING[100] id) AND Purchase.ScheduleOrder s = scheduleOrder(id) DO {
        createUserOrderAuto(s) <- TRUE;
        id(s) <- docId(i);
        supplier(s) <- legalEntity(TEXT (idSupplier(i)));
        supplierStock(s) <- minStock(legalEntity(TEXT (idSupplier(i))));
        customer(s) <- legalEntity(TEXT (idCustomer(i)));
        startDate(s) <- DATE (startDate(i));
        endDate(s) <- DATE(endDate(i));
        period(s) <- days(i) / 7;
        note(s) <- note(i);
        type(s) <- GenType.genDayMonth;
        operation(s) <- Purchase.operation('purchaseStoreSupplier');
        separation(s) <- separation(idSep(i));
        contractSku(s) <- userContractSku(TEXT (idSep(i)));
        imported(s) <- TRUE;
    }

// не работает т.к. в СМ есть различные варианты не подходящие в Fusion, например два дня заказа на один день поставки, или два одинаковых дня заказа на два разных дня поставки
// задача 2 этапа, в BIGZZ заказ идет через стороннее дополнение к СМ

    // в Супермаге могут быть две записи с одним днем заказа WEEKDAY тогда у нас срабатывает constraint надо выбрать только одну запись 
//    FOR [GROUP SUM 1 IF imported(INTEGER i) BY docId(i), orderDOW(i)](STRING[57] docId, STRING[1] weekday) AND NOT scheduleOrderTime(scheduleOrder(docId), DOWM(INTEGER (weekday))) DO NEW d = Purchase.ScheduleOrderTime {
//        scheduleOrder(d) <- scheduleOrder(docId);
//        orderDOW(d) <- DOWM(INTEGER (weekday));        
//    }
//
//    FOR INTEGER i = [GROUP MIN INTEGER ii IF imported(ii) BY docId(ii), orderDOW(ii)](STRING[57] docId, STRING[1] weekday) AND Purchase.ScheduleOrderTime d = scheduleOrderTime(scheduleOrder(docId), DOWM(INTEGER (weekday))) DO {
//            shipmentSM(d) <- shipmentDOW(i);
//            orderSM(d) <- orderDOW(i);
//            shipmentDay(i) <- GROUP MIN INTEGER j IF right(left(shipmentDOW(i)+shipmentDOW(i), j), 1) == '1' AND iterate(j, INTEGER (orderDOW(i))+1, 14);            
//            shipmentDay(i) <- shipmentDay(i) - 7 WHERE shipmentDay(i) > 7;              
//            shipmentDOW(d) <- DOWM(shipmentDay(i));
//            imported(d) <- TRUE;            
//    }

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT qd.id, q.ID AS DOCID, cl.locationid FROM Supermag.SVDocumentsCO cc, Supermag.SvDocNoPriceCQ q, Supermag.SMContractLocations cl, Supermag.scautoorderdoc qd WHERE q.docco = cc.id AND q.id = cl.id AND qd.DOCTID = q.ID AND ' + filterSql() TO file;

    IMPORT TABLE FROM file() TO id, docId, idStock;

    dataIn(Purchase.ScheduleOrder o, Stock st) <- NULL WHERE id(o) AND st IS Stock;
    
    FOR Purchase.ScheduleOrder s = scheduleOrder(docId(INTEGER i)) AND Stock st = stock(TEXT (idStock(i))) DO {
        dataIn(s, st) <- TRUE;
    }
    
    LOCAL endDate = DATE (Purchase.ScheduleOrderTime);
    LOCAL operation = Purchase.Operation (Purchase.ScheduleOrderTime);
    
    endDate(Purchase.ScheduleOrderTime d) <- endDate(scheduleOrder(d));   
    operation(Purchase.ScheduleOrderTime d) <- operation(scheduleOrder(d));   
    
    DELETE Purchase.ScheduleOrderTime d WHERE endDate(d) >= dateFromS() AND operation(d) = Purchase.operation('purchaseStoreSupplier') AND NOT imported(d);
    DELETE Purchase.ScheduleOrder o WHERE endDate(o) >= dateFromS() AND operation(o) = Purchase.operation('purchaseStoreSupplier') AND NOT imported(o);

    APPLY;
} 

EXTEND FORM integrationData PROPERTIES () importScheduleOrder;
DESIGN integrationData { supermagImportButtons { 
        contractButtons {
            MOVE PROPERTY (importScheduleOrder()) { caption = 'Импорт графиков заказов';};
        } 
    } 
}

//---------------------------------------------------------------------------------------------------------акты переоценки
daysRepricing 'дней для импорта' = DATA INTEGER ();
dateFromRepricing() = sum(currentDate(), -daysRepricing());
dateFromRepricingT() = toDateDDMMYYYY(dateFromRepricing());

withoutPrice 'Импорт только с товарами без цен' = DATA BOOLEAN ();

imported 'Импортируемая' = DATA BOOLEAN (Repricing.Operation);

EXTEND FORM Repricing.operation PROPERTIES imported(o);
DESIGN Repricing.operation {
    paramsContainer {
        MOVE PROPERTY (imported(o));
    }
}

lastStatusSupermag '' = DATA INTEGER (UserRepricing);

importRepricingRetail 'Импорт актов переоценки' () {
    
    LOCAL id = ISTRING[50] (INTEGER);
    LOCAL dateTime = DATETIME (INTEGER);
    LOCAL reason = INTEGER (INTEGER);
    LOCAL docstate = INTEGER (INTEGER);
    LOCAL idStore = INTEGER (INTEGER);
    LOCAL comment = ISTRING[255] (INTEGER);
    LOCAL imported = BOOLEAN (UserRepricing);
    LOCAL filterSql = TEXT ();
                                                                                                                                                                                   // a.Reason = 0 переоценка по приходу, у нас акт расценки               
    filterSql () <- 'd.location IN ('+ ImportSupermag.stocks() + ') AND TRUNC(nvl(a.ExecTime,a.ExecDate)) >= TO_DATE(\'' + toDateISO(ImportSupermag.dateFromRepricing()) + '\',\'YYYY-MM-DD\') AND d.DocState IN (0,2,3) AND a.Reason > 0';
    IF length(numberSupplierContract()) > 0 THEN
       filterSql() <- 'd.id = \'' + numberSupplierContract() + '\''; 
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT d.ID, nvl(a.EXECTIME,a.EXECDATE) AS EXECDATE, a.REASON, d.DOCSTATE, d.LOCATION, d.COMMENTARY FROM Supermag.SMActs a, Supermag.SMDocuments d WHERE d.DocType = \'AC\' AND a.Id = d.Id AND ' + filterSql() TO file;
    
    IMPORT TABLE FROM file() TO id, dateTime, reason, docstate, idStore, comment;

    FOR [GROUP SUM 1 BY reason(INTEGER i)](INTEGER i) AND NOT Repricing.operation(TEXT (i)) DO NEW o = Repricing.Operation {
        id(o) <- ISTRING[100](i);
        name(o) <- ISTRING[100](i);
        allRoles(o) <- TRUE;
        imported(o) <- TRUE;
    }
   
    FOR id(INTEGER i) AND NOT Repricing.userRepricing(id(i)) DO NEW r = Repricing.UserRepricing {
        id(r) <- id(i);
    }
        
    FOR Repricing.UserRepricing rep == Repricing.userRepricing(id(INTEGER i)) DO {       
        operation(rep) <- Repricing.operation(TEXT (reason(i)));
        Repricing.number(rep) <- ISTRING[28] (id(rep));
        date(rep) <- DATE (dateTime(i));
        time(rep) <- TIME (dateTime(i));
        note(rep) <- comment(i);
        departmentStore(rep) <- departmentStore(TEXT (idStore(i)));
        imported(rep) <- TRUE;
        IF NOT lastStatusSupermag(rep) = docstate(i) AND docstate(i) < 3 THEN isPosted(rep) <- NULL;
        IF NOT lastStatusSupermag(rep) = docstate(i) AND docstate(i) < 3 THEN isClosed(rep) <- NULL;
        lastStatusSupermag(rep) <- docstate(i);
    }
    
    LOCAL type = ISTRING[2](INTEGER);
    LOCAL idDoc = ISTRING[50](INTEGER);
    LOCAL specItem = INTEGER (INTEGER);
    LOCAL quantity = NUMERIC[16,5](INTEGER);   
    LOCAL price = NUMERIC[16,4](INTEGER);
    LOCAL oldPrice = NUMERIC[16,4](INTEGER);
    LOCAL idItem = ISTRING[50](INTEGER);
    LOCAL actReason = INTEGER (INTEGER);
    LOCAL priceType = INTEGER (INTEGER);
    LOCAL imported = BOOLEAN (UserRepricingDetail);
    LOCAL skip = BOOLEAN (INTEGER);

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT d.DocType, d.Id, dd.SpecItem, dd.Article, dd.ItemPrice,  ad.OldPrice, dd.Quantity, a.Reason, a.PriceType FROM Supermag.SMDocuments d, Supermag.SMActs a, Supermag.SMSpec dd, Supermag.SMSpecActs ad WHERE d.DocType = \'AC\' AND a.Id = d.Id AND dd.DocId = d.Id AND dd.DocType = \'AC\' AND ad.DocId = d.Id AND ad.DocType = \'AC\' AND ad.SpecItem = dd.SpecItem AND ' + filterSql() TO file;
       
    IMPORT TABLE FROM file() TO type, idDoc, specItem, idItem, price, oldPrice, quantity, actReason, priceType;
    
    id(INTEGER i) <- CONCAT '', 'R', type(i), idDoc(i), specItem(i) WHERE imported(i); 

//    IF withoutPrice() THEN {
//        skip(INTEGER i) <- imported(i) AND NOT (GROUP SUM 1 IF in(userPriceList(idDoc(i)), DepartmentStore st) AND NOT prevPriceA(dataPriceListType('retail'), item(idItem(i)), st, 2030_01_01_00:00));
//    }

    FOR userRepricing(idDoc(INTEGER i)) AND NOT userRepricingDetail(id(i)) AND NOT skip(i) DO {        
        NEW d = UserRepricingDetail {
            id(d) <- id(i);
            userRepricing(d) <- userRepricing(idDoc(i));
        }       
    }

    FOR UserRepricingDetail d = userRepricingDetail(id(INTEGER i)) AND NOT skip(i) DO {
        sku(d) <- item(idItem(i));
        quantity(d) <- quantity(i);
        curRetailPrice(d) <- oldPrice(i);
        retailPrice(d) <- price(i);
        imported(d) <- TRUE;
        dataIndex(d) <- specItem(i);
    }
    
//    IF NOT withoutPrice() THEN {
//        DELETE UserRepricing p WHERE date(p) >= df AND date(p) <= dt AND imported(operation(p)) AND NOT imported(p);
//        DELETE UserRepricingDetail d WHERE date(d) >= df AND date(d) <= dt AND imported(operation(d)) AND NOT imported(d);
//    }

    // импорт документов оснований
    LOCAL baseId = ISTRING[50] (INTEGER);
    LOCAL baseType = ISTRING[50] (INTEGER);
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
    EXEC 'Select d.ID, cb.BASEID, cb.BASEDOCTYPE from Supermag.SMDocuments d, Supermag.SMActs a, Supermag.SMCommonBases cb where a.DocType(+)= D.DocType and a.ID(+)= D.ID AND cb.ID(+) = a.ID AND ' + filterSql() TO file;
        
    IMPORT TABLE FROM file() TO id, baseId, baseType;
    
    FOR id(INTEGER i) AND (baseType(i) = 'AB' OR baseType(i) = 'MA') DO {  
        basisDoc(Repricing.UserRepricing o, Document d) <- NULL WHERE o = Repricing.userRepricing(id(i));
        basisDoc(Repricing.UserRepricing o, Document d) <- TRUE WHERE o = Repricing.userRepricing(id(i)) AND d = userPriceList(baseId(i)); 
    }

    APPLY;       
}

EXTEND FORM integrationData PROPERTIES () importRepricingRetail, daysRepricing;

DESIGN integrationData { supermagImportButtons { 
        NEW supermagRepricing {
            type = CONTAINERH;
            MOVE PROPERTY (importRepricingRetail());
            MOVE PROPERTY (daysRepricing());
        } 
}}

//---------------------------------------------------------------------------------------------------------------розничные прайсы (ведомости базовых цен)
daysPriceList 'дней для импорта' = DATA INTEGER ();
dateFromPriceList () = sum(currentDate(), -daysPriceList());
dateFromPriceListT () = toDateDDMMYYYY(dateFromPriceList());

imported 'Импортируемая' = DATA BOOLEAN (PriceList.Operation);

EXTEND FORM PriceList.operation PROPERTIES imported(o);

DESIGN PriceList.operation { paramsContainer {
        MOVE PROPERTY (imported(o));
}}

importPriceListRetail 'Импорт розничных прайсов' () {

    LOCAL id = ISTRING[50] (INTEGER);
    LOCAL dateTime = DATETIME (INTEGER);
    LOCAL reason = INTEGER (INTEGER);
    LOCAL status = INTEGER (INTEGER);
    LOCAL idStore = INTEGER (INTEGER);
    LOCAL comment = ISTRING[255] (INTEGER);
    LOCAL imported = BOOLEAN (UserPriceList);
    LOCAL idPricetype = INTEGER (INTEGER);
    LOCAL filterSql = TEXT();
    LOCAL file = FILE ();
    
    filterSql() <- 'TRUNC(nvl(a.EXECTIME,a.EXECDATE)) >= TO_DATE(\'' + toDateISO(dateFromPriceList()) + '\',\'YYYY-MM-DD\') AND d.docState IN (0,2,3)';  
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT d.ID, nvl(a.EXECTIME,a.EXECDATE) AS EXECDATE, a.REASON, d.DOCSTATE, d.COMMENTARY, a.pricetype FROM Supermag.SMDocuments d , Supermag.SMActs a WHERE d.DocType = \'AB\' AND a.id = d.id AND ' + filterSql() TO file;

    IMPORT TABLE FROM file() TO id, dateTime, reason, status, comment, idPricetype;
     
    // создаем новые прайслисты 
    FOR id(INTEGER i) AND NOT userPriceList(id(i)) DO {
        NEW p = UserPriceList {
            id(p) <- id(i);
        }
    }

    FOR UserPriceList p == userPriceList(id(INTEGER i)) DO {       
        operation(p) <- PriceList.operation('retail');
        number(p) <- ISTRING[28] (id(p));
        date(p) <- DATE (dateTime(i));
        time(p) <- TIME (dateTime(i));
        fromDate(p) <- DATE (dateTime(i));
        fromTime(p) <- TIME (IF reason(i) = 5 THEN sumSeconds(dateTime(i), 1) ELSE dateTime(i));
        isPosted(p) <- status(i) = 3;
        note(p) <- comment(i);
        in(p, DataPriceListType t) <- id(t) == 'D' + TEXT (idPricetype(i));
        dataIn(p, StockGroup s) <- NULL;
        dataIn(p, Stock s) <- NULL;
        allStocks(p) <- NULL;
        dataIn(p, StockGroup s) <- id(retailPriceListType[StoreType](s)) == 'D' + TEXT (idPricetype(i));       
        imported(p) <- TRUE;
    } 
      
    // спецификации
    LOCAL type = ISTRING[2](INTEGER);
    LOCAL idDoc = ISTRING[50](INTEGER);
    LOCAL specItem = INTEGER (INTEGER);
    LOCAL price = NUMERIC[19,4](INTEGER);
    LOCAL idItem = ISTRING[50](INTEGER);
    LOCAL aReason = INTEGER (INTEGER);
    LOCAL imported = BOOLEAN (UserPriceListDetail);
    LOCAL imported = BOOLEAN (UserRepricingDetail);
    LOCAL skip = BOOLEAN (INTEGER);

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
            EXEC 'SELECT d.DOCTYPE, d.ID, dd.SPECITEM, dd.ITEMPRICE, dd.ARTICLE, a.REASON, a.pricetype FROM Supermag.SMDocuments d, Supermag.SMActs a, Supermag.SMSpec dd, Supermag.SMSpecActs ad WHERE d.DocType = \'AB\' AND d.id = a.id AND dd.docid = d.id AND dd.DocType = \'AB\' AND ad.docid = dd.docid AND ad.DocType = \'AB\' AND ad.SpecItem = dd.SpecItem AND ' + filterSql() TO file;

    IMPORT TABLE FROM file() TO type, idDoc, specItem, price, idItem, aReason, idPricetype;

    id(INTEGER i) <- CONCAT '', 'R', type(i), idDoc(i), specItem(i) WHERE imported(i); 

    IF withoutPrice() THEN {
        skip(INTEGER i) <- imported(i) AND NOT (GROUP SUM 1 IF in(userPriceList(idDoc(i)), DepartmentStore st) AND NOT prevPriceA(dataPriceListType('retail'), item(idItem(i)), st, 2030_01_01_00:00));
    }

    FOR userPriceList(idDoc(INTEGER i)) AND NOT userPriceListDetail(id(i)) AND NOT skip(i) DO {
        NEW d = UserPriceListDetail {
            id(d) <- id(i);
            userPriceList(d) <- userPriceList(idDoc(i));
        }       
    }

    FOR UserPriceListDetail d = userPriceListDetail(id(INTEGER i)) AND NOT skip(i) DO {
        sku(d) <- item(idItem(i));
        price(d, LedgerPriceListType t) <- NUMERIC[16,4](price(i)) WHERE t == dataPriceListType('D' + TEXT (idPricetype(i)));
        imported(d) <- TRUE;
        dataIndex(d) <- specItem(i);
    }

    APPLY;
}

EXTEND FORM integrationData PROPERTIES () importPriceListRetail, daysPriceList, withoutPrice;
DESIGN integrationData { supermagImportButtons { 
        NEW supermagPriceList {
            type = CONTAINERH;
            MOVE PROPERTY (importPriceListRetail());
            MOVE PROPERTY (daysPriceList()) { alignment = CENTER; }
        } 
//        MOVE PROPERTY (withoutPrice());
}}

//----------------------------------------------маркетинговые (акционные) прайслисты
daysPromotion 'дней для импорта' = DATA INTEGER ();
dateFromPromotion () = sum(currentDate(), -daysPromotion());
dateFromPromotionT () = toDateDDMMYY(dateFromPromotion());

importPriceListPromotion 'Импорт акционных прайсов' () {
    
    LOCAL id = ISTRING[50] (INTEGER);
    LOCAL date = DATETIME (INTEGER);
    LOCAL begin = DATETIME (INTEGER);
    LOCAL end = DATETIME (INTEGER);
    LOCAL posted = INTEGER (INTEGER);
    LOCAL name = ISTRING[255] (INTEGER);
    LOCAL imported = BOOLEAN (UserPriceList);
    
    LOCAL file = FILE ();
    LOCAL filterSql = TEXT ();
    
    filterSql() <- 'DATEEND >= TO_DATE(\'' + toDateISO(dateFromPromotion()) + '\',\'YYYY-MM-DD\') AND ma.DOCSTATE IN (0,2,3)';
      
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT ma.ID, ma.CREATEDAT, ma.DATEBEGIN, ma.DATEEND, ma.DOCSTATE, NAME FROM Supermag.SVDocumentsMA ma WHERE ' + filterSql() TO file;
    
    IMPORT TABLE FROM file() TO id, date, begin, end, posted, name;
    
    FOR id(INTEGER i) AND NOT userPriceList(id(i)) DO NEW p = UserPriceList {
        id(p) <- id(i);
    }
    
    FOR UserPriceList p == userPriceList(id(INTEGER i)) DO {
        
        operation(p) <- PriceList.operation('promotion');
        number(p) <- ISTRING[28] (id(p));
        date(p) <- DATE (date(i));
        time(p) <- 00:00;
        isPosted(p) <- posted(i) != 1;
        fromDate(p) <- DATE (begin(i));
        fromTime(p) <- TIME (begin(i));
        toDate(p) <- DATE (end(i));
        toTime(p) <- TIME (end(i));
        note(p) <- name(i);
        fromPriceBeforeDate(p) <- sum(DATE (begin(i)), -1);
        fromPriceBeforeTime(p) <- 00:00;
        toPriceBeforeDate(p) <- sum(DATE (end(i)), 1);
        allStocks(p) <- NULL;
        imported(p) <- TRUE;
    }
    
    LOCAL idDoc = ISTRING[50](INTEGER);
    LOCAL specItem = INTEGER (INTEGER);
    LOCAL idItem = ISTRING[50](INTEGER);
    LOCAL price = NUMERIC[19,4](INTEGER);
    LOCAL imported = BOOLEAN (UserPriceListDetail);
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
            EXEC 'SELECT DOCID, SPECITEM, ARTICLE, ITEMPRICE FROM Supermag.SVSpecMA d, Supermag.SVDocumentsMA ma WHERE d.DOCID = ma.id AND ' + filterSql() TO file;
    
    IMPORT TABLE FROM file() TO idDoc, specItem, idItem, price;
    
    id(INTEGER i) <- CONCAT '', 'P', idDoc(i), specItem(i) WHERE imported(i); 
    
    FOR userPriceList(idDoc(INTEGER i)) AND NOT userPriceListDetail(id(i)) DO NEW d = UserPriceListDetail {
        id(d) <- id(i);
        userPriceList(d) <- userPriceList(idDoc(i));
    }
    
    FOR UserPriceListDetail d = userPriceListDetail(id(INTEGER i)) DO {
        sku(d) <- item(idItem(i));
        imported(d) <- TRUE;
        dataIndex(d) <- specItem(i);
        priceBefore(d) <- OVERRIDE (GROUP MAX prevPriceA(dataPriceListType('retail'), item(idItem(i)), Stock st, fromDateTime(userPriceList(idDoc(i)))) IF in(userPriceList(idDoc(i)), st)), 0.0;
        price(d, LedgerPriceListType t) <- NUMERIC[16,4](price(i)) WHERE t == dataPriceListType('promotion');
    }
    
    LOCAL idStock = INTEGER (INTEGER);
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT a.AUCID, a.LOCID FROM Supermag.SVAuctionAtoms a, Supermag.SVDocumentsMA ma WHERE a.AUCID = ma.id AND ' + filterSql()  TO file;
    
    IMPORT TABLE FROM file() TO idDoc, idStock;
       
    FOR [GROUP SUM 1 BY userPriceList(idDoc(INTEGER i))](UserPriceList p) DO {
        dataIn(p, DepartmentStore s) <- TRUE IF [GROUP SUM 1 BY userPriceList(idDoc(INTEGER i)), departmentStore(TEXT (idStock(i)))](p, s);
    }
    
    APPLY NESTED LOCAL;
    
    DELETE UserPriceList p WHERE toDate(p) >= dateFromPromotion() AND id(operation(p)) == 'promotion' AND NOT imported(p);
    DELETE UserPriceListDetail d WHERE  toDate(d) >= dateFromPromotion() AND id(operation(d)) == 'promotion' AND NOT imported(d);
    
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importPriceListPromotion(), daysPromotion();
DESIGN integrationData { supermagImportButtons { 
        NEW supermagPromotion {
            type = CONTAINERH;
            MOVE PROPERTY (importPriceListPromotion());
            MOVE PROPERTY (daysPromotion()) { alignment = CENTER; }
        } 
} }

id = DATA STRING[100](Range.Range);
range = GROUP AGGR Range.Range r WHERE r IS Range.Range BY id(r);

nameImport 'Наименование для импорта' = DATA STRING[50](Store);

EXTEND FORM stores PROPERTIES READONLYIF isReadonly() nameImport(s);
EXTEND FORM store PROPERTIES nameImport(s);

DESIGN store {
    headerExtraParams {
        MOVE PROPERTY (nameImport(s));
    }
}

//---------------------------------------------------------------------------------------------------------------матрицы
importRange 'Импорт ассортиментных матриц' () {
    
    LOCAL itemId = STRING[50] (INTEGER);
    LOCAL id = INTEGER (INTEGER);
    LOCAL name = ISTRING[50] (INTEGER);
    LOCAL store = Store(INTEGER);
    LOCAL rangeRev = RangeRev(INTEGER);
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT sa.id, sa.name FROM Supermag.SACardMatrix sa' TO file;
    
    IMPORT TABLE FROM file() TO id, name;    
   
    FOR id(INTEGER i) AND NOT range(STRING[100] (id(i))) DO NEW r =  Range.Range {
        id(r) <- STRING[100] (id(i));
        name(r) <- name(i);      
        inData(r, ItemGroup g) <- TRUE IF itemGroupRoot(g, 2) == g; 
        NEW rr = RangeRev {
            range(rr) <- r;
            dateTime(rr) <- 2001_01_01_00:00;
        }     
    }
    
    FOR Range.RangeRev rv AND rv IS RangeRev DO {
        include(rv, Store st, Item s) <- NULL;    
    }
        
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT sm.article, sa.id, sa.name FROM Supermag.SMCardMatrix sm, Supermag.SACardMatrix sa WHERE sm.idMatrix = sa.id' TO file;
                                                          
    IMPORT TABLE FROM file() TO itemId, id, name;

    store (INTEGER i) <- GROUP MAX Store s IF isISubstring(nameImport(s), replace(name(i), ' nS', ''));

//    rangeRev(INTEGER i) <- GROUP LAST RangeRev rr ORDER dateTime(rr), rr IF isParent(ItemGroup g, item(itemId(i))) AND level(g, itemGroup(id(range(rr))));
    rangeRev(INTEGER i) <- GROUP LAST RangeRev rr ORDER dateTime(rr), rr IF id(range(rr)) = STRING[100] (id(i));

    FOR [GROUP SUM 1 BY rangeRev(INTEGER i)](RangeRev r) DO {
        include(r, Store st, Item s) <- TRUE IF [GROUP SUM 1 BY rangeRev(INTEGER i), store(i), item(itemId(i))](r, st, s);
    }

    APPLY;
}

EXTEND FORM integrationData PROPERTIES importRange();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importRange()); } }

rangeRev (SkuGroup g) = GROUP LAST RangeRev rr ORDER dateTime(rr), rr IF inData(range(rr), g);

WHEN CHANGED (skuGroup2(Item i)) AND rangeRev(PREV (skuGroup2(i))) DO {
    include(RangeRev rr, Store st, i) <- TRUE IF include(rangeRev(PREV (skuGroup2(i))), st, i) AND rr == rangeRev(skuGroup2(i));
    include(RangeRev rr, Store st, i) <- NULL WHERE rr IS RangeRev AND NOT rr == rangeRev(skuGroup2(i));
}

//---------------------------------------------------------------------------------------импорт остатков
scriptImportInit 'Скрипт импорта остатков' = DATA TEXT ();
useConstraint 'Сохранять, даже если есть ограничения' = DATA BOOLEAN ();

date 'Дата ТТН' = DATA LOCAL DATETIME (INTEGER);
num 'Номер ТТН' = DATA LOCAL STRING[28](INTEGER);
series 'Серия ТТН' = DATA LOCAL STRING[2](INTEGER);
spec 'Код для импорта' = DATA LOCAL INTEGER (INTEGER);

idSupplierInt 'Код поставщика'= DATA LOCAL INTEGER (INTEGER);
idSupplier 'Код поставщика'= DATA LOCAL ISTRING[100] (INTEGER);
idCustomerStockInt 'Код склада покупателя'= DATA LOCAL INTEGER (INTEGER);
idCustomerStock 'Код склада покупателя'= DATA LOCAL ISTRING[100] (INTEGER);

id 'Код накладной'(INTEGER i) = OVERRIDE (CONCAT '', idCustomerStock(i), series(i), num(i)), 'nodoc' IF imported(i);
idDetail 'Код строки'(INTEGER i) = OVERRIDE (CONCAT '', idCustomerStock(i), series(i), num(i), spec(i)), 'nodoc' IF imported(i);

idSku 'Код товара'= DATA LOCAL STRING[100](INTEGER);

quantity 'Количество' = DATA LOCAL NUMERIC[16,5](INTEGER);
price 'Цена' = DATA LOCAL NUMERIC[16,4](INTEGER);
retailPrice 'Цена' = DATA LOCAL NUMERIC[19,4](INTEGER);
vat 'Ставка НДС поставщика' = DATA LOCAL NUMERIC[10,5](INTEGER);

skipSetContractSku(Purchase.UserInvoice i) += idOperation(i) == 'initial';

deleteInvoiceDetails 'Удалять строки, которых нет в импорте' = DATA BOOLEAN ();

importInit 'Импорт остатков' ()  {
    
    logToFile('importSupermag', 'importInit_0');
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC replace(scriptImportInit(), 'STOCK_LIST', stocks()) TO file;
    
    logToFile('importSupermag', 'importInit_1');
    
    IMPORT TABLE FROM file() TO idCustomerStockInt, idSku, num, series, spec, idSupplierInt, vat, price, quantity, retailPrice, date;
       
    logToFile('importSupermag', 'importInit_2');
    
    idSupplier(INTEGER r) <- OVERRIDE ISTRING[100] (idSupplierInt(r)), 'nosup' WHERE imported(r);
    idCustomerStock(INTEGER r) <- ISTRING[100] (idCustomerStockInt(r)) WHERE imported(r);
    date(INTEGER r) <- DATETIME (2018_01_01) WHERE imported(r) AND NOT date(r);
    retailPrice(INTEGER r) <- NULL WHERE imported(r) AND stock(ISTRING[100] (idCustomerStockInt(r))) IS Warehouse;
    
    LOCAL supplier = LegalEntity(INTEGER);
    supplier(INTEGER r) <- legalEntity(idSupplier(r)) WHERE imported(r); 

    LOCAL incl =  BOOLEAN (Purchase.UserInvoiceDetail);
    
    //шапки
    FOR [GROUP SUM 1 BY id(INTEGER r)](ISTRING[100] id) AND NOT Purchase.userInvoice(id) DO NEW i = Purchase.UserInvoice {
        id(i) <- id;
    }
    FOR INTEGER r == [GROUP MIN INTEGER ir BY id(ir)](ISTRING[100] id) AND Purchase.UserInvoice i == Purchase.userInvoice(id) DO {
        
        supplier(i) <- OVERRIDE supplier(r), legalEntity(stock(idCustomerStock(r)));
        supplierStock(i) <- IF supplier(r) THEN minStock(supplier(r)) ELSE stock(idCustomerStock(r));
        customer(i) <- legalEntity(stock(idCustomerStock(r)));
        customerStock(i) <- stock(idCustomerStock(r));
        number(i) <- num(r);
        date(i) <- DATE (date(r));
        time(i) <- 00:00;
        isPosted(i) <- TRUE;
        operation(i) <- Purchase.operation('initial');
        createShipment(i) <- createShipment(Purchase.operation('initial')); 
        createPricing(i) <- createPricing(Purchase.operation('initial')); 
        isClosed(i) <- TRUE;
    }
    
    logToFile('importSupermag', 'importInit_3');
    
    //строки
    FOR imported(INTEGER r) AND NOT Purchase.userInvoiceDetail(idDetail(r)) NEW d = Purchase.UserInvoiceDetail DO {
        id(d) <- idDetail(r);
    }
        
    FOR Purchase.UserInvoiceDetail d == Purchase.userInvoiceDetail(idDetail(INTEGER r)) INLINE DO {
        userInvoice(d) <- Purchase.userInvoice(id(r));
        sku(d) <- sku(idSku(r));
        quantity(d) <- quantity(r);
        shipmentQuantity(d) <- quantity(r);
        VAT(d) <- valueCurrentVAT(defaultCountry(), vat(r)); 
        valueVAT(d) <- vat(r);
        retailVAT(d) <- VAT(sku(idSku(r)));
        valueRetailVAT(d) <- valueVAT(sku(idSku(r)));
        price(d) <- NUMERIC[16,4](price(r));
        retailPrice(d) <- NUMERIC[16,4](retailPrice(r));
        shipmentPrice(d) <- NUMERIC[16,4](OVERRIDE retailPrice(r), price(r));
        incl(d) <- TRUE;
        dataIndex(d) <- spec(r);
    }
    
    logToFile('importSupermag', 'importInit_4');
    
    FOR [GROUP SUM 1 IF imported(INTEGER in) BY idCustomerStock(in)](id(Stock st)) DO {
        
        IF NOT  deleteInvoiceDetails() THEN {
            quantity(Purchase.UserInvoiceDetail d) <- 0.0 WHERE operation(d) == Purchase.operation('initial') AND st = customerStock(d) AND NOT incl(d);
            shipmentQuantity(Purchase.UserInvoiceDetail d) <- 0.0 WHERE operation(d) == Purchase.operation('initial') AND st = customerStock(d) AND NOT incl(d);
            shipmentSum(Purchase.UserInvoiceDetail d) <- 0.0 WHERE operation(d) == Purchase.operation('initial') AND st = customerStock(d) AND NOT incl(d); 
        }
        ELSE DELETE Purchase.UserInvoiceDetail d WHERE operation(d) == Purchase.operation('initial') AND st = customerStock(d) AND NOT incl(d);    
    } 
        
    disableDocumentLog() <- TRUE;
    IF useConstraint() THEN {
        setNoCancelInTransaction();             
    }     
    
    logToFile('importSupermag', 'importInit_5');
    APPLY; 
    logToFile('importSupermag', 'importInit_6');
} 

EXTEND FORM integrationData PROPERTIES () scriptImportInit, useConstraint, importInit, disableDocumentLog, deleteInvoiceDetails, stocks ON CHANGE { SHOW dialogDepartmentStores; };

DESIGN integrationData {
    supermag {
        type = CONTAINERH;
        NEW supermag1 {
            type = CONTAINERH;
            NEW supermagLeft {
                MOVE supermagParams { fill = 1; }
                MOVE supermagExportButtons { fill = 1; }
                MOVE supermagImportButtons { fill = 1; }
            }
            NEW supermagRight {
                fill = 1;
                NEW stocks {
                    caption = 'Склады для импорта';
                    alignment = STRETCH;
                    MOVE PROPERTY (stocks()) { caption = ''; alignment = STRETCH; }
                }
                NEW importBalance {
                    caption = 'Импорт остатков';
                    fill = 1;
                    NEW supermagTopRight {
                        type = CONTAINERH;
                        MOVE PROPERTY (disableDocumentLog()) { alignment = CENTER; }
                        MOVE PROPERTY (useConstraint()) { alignment = CENTER; }
                        MOVE PROPERTY (deleteInvoiceDetails()) { alignment = CENTER; }
                        MOVE PROPERTY (importInit());
                    }
                    NEW supermagScript {
                        fill = 1;
                        caption = 'Скрипт для импорта остатков';
                        MOVE PROPERTY (scriptImportInit()) { 
                            caption = ''; 
                            fill = 1;
                            charWidth = 100; 
                        }
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------------------------------------заказы закупка
daysOrder 'Дней для синхронизации заказов' = DATA INTEGER ();
dateFromOrder () = sum(currentDate(), -daysOrder());
numberOrder 'Номер заказа' = DATA STRING[20] ();
stateInSuperMag 'Статус в супермаг' = DATA INTEGER (Purchase.UserOrder);
prevStateInSuperMag 'Пред. статус в супермаг' = DATA INTEGER (Purchase.UserOrder);
EXTEND FORM Purchase.orders PROPERTIES stateInSuperMag(o);

overImportPurchaseOrder ABSTRACT LIST ();

importPurchaseOrder 'Импорт заказов (закупка)' () {
    
    LOCAL id = ISTRING[50] (INTEGER);
    LOCAL docstate = INTEGER (INTEGER);
    LOCAL idSupplier = INTEGER (INTEGER);
    LOCAL idStock = INTEGER (INTEGER);
    LOCAL comment = ISTRING[255] (INTEGER);
    LOCAL date = DATETIME (INTEGER);
    LOCAL supplyDate = DATETIME (INTEGER);
    LOCAL supplyTimeMin = INTEGER (INTEGER);
    LOCAL supplyTimeTillMin = INTEGER (INTEGER);
    LOCAL idSeparation = STRING[100] (INTEGER);
    LOCAL filterSql = TEXT ();
    LOCAL file = FILE ();
    
    filterSql() <- 'd.docstate IN (0, 2, 3) AND d.location IN ('+ stocks() + ') AND dd.SupplyDate >= TO_DATE(\'' + toDateISO(dateFromOrder()) + '\',\'YYYY-MM-DD\')'; 
    IF length(numberOrder()) > 0 THEN 
        filterSql() <- 'd.id = \'' + numberOrder() + '\''; 
           
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
    EXEC 'Select d.ID, d.DocState, d.ClientIndex, d.Location, d.Commentary, dd.OrderDate, dd.SupplyDate, dd.SupplyTime as SupplyTimeMinutes, DD.SupplyTimeTill as SupplyTimeTillMinutes from Supermag.SMDocuments d, Supermag.SMDocOR dd WHERE dd.DocType(+) = d.DocType AND d.DocType = \'OR\' AND dd.ID(+) = d.ID AND ' + filterSql() TO file;   
   
    IMPORT TABLE FROM file() TO id, docstate, idSupplier, idStock, comment, date, supplyDate, supplyTimeMin, supplyTimeTillMin;
    
    FOR [GROUP SUM 1 BY id(INTEGER i)](STRING[50] id) AND NOT Purchase.userOrder(id) DO NEW o = Purchase.UserOrder {
        id(o) <- id;
    }
    
    FOR Purchase.UserOrder o == Purchase.userOrder(id(INTEGER i)) DO {       
        number[Document](o) <- STRING[28](id(i));
        operation(o) <- Purchase.operation('purchaseStoreSupplier');
        isPosted(o) <- docstate(i) == 2 OR docstate(i) == 3;
        isRejected(o) <- docstate(i) == 0;
        isClosed(o) <- docstate(i) == 3 OR docstate(i) == 0;
        stateInSuperMag(o) <- docstate(i);
        supplier(o) <- legalEntity(ISTRING[100] (idSupplier(i)));
        supplierStock(o) <- stock(ISTRING[100] (idSupplier(i)));
        customerStock(o) <- stock(ISTRING[100] (idStock(i)));
        customer(o) <- legalEntity(stock(ISTRING[100] (idStock(i))));
        date(o) <- DATE (date(i));
        time(o) <- 00:00;
        shipmentDate(o) <- DATE (supplyDate(i));
        shipmentTime(o) <- sumMinutes(00:00, supplyTimeMin(i));
    }  
    
    //импорт спецификаций
    LOCAL type = ISTRING[2](INTEGER);
    LOCAL idDoc = ISTRING[50](INTEGER);
    LOCAL specItem = INTEGER (INTEGER);
    LOCAL price = NUMERIC[19,4](INTEGER);
    LOCAL totalPrice = NUMERIC[19,4](INTEGER);
    LOCAL quantity = NUMERIC[14,3](INTEGER);
    LOCAL idItem = ISTRING[50](INTEGER);
    LOCAL imported = BOOLEAN (Purchase.UserOrderDetail);

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
            EXEC 'SELECT d.DOCTYPE, ds.DOCID, ds.SPECITEM, ds.ARTICLE, ds.QUANTITY, ds.ITEMPRICE, ds.TOTALPRICE FROM Supermag.SMSpecOR ds, Supermag.SMDocOR dd, Supermag.SMDocuments d WHERE dd.DocType(+)= d.DocType AND d.DocType = \'OR\' AND ds.DocType = \'OR\' AND ds.DOCID = dd.id AND dd.id = d.id AND ' + filterSql() TO file;
    
    IMPORT TABLE FROM file() TO type, idDoc, specItem, idItem, quantity, price, totalPrice;
    
    id(INTEGER i) <- CONCAT '', 'O', type(i), idDoc(i), specItem(i) WHERE imported(i); 

    FOR Purchase.userOrder(idDoc(INTEGER i)) AND NOT Purchase.userOrderDetail(id(i)) DO NEW d = Purchase.UserOrderDetail {
        id(d) <- id(i);
        userOrder(d) <- Purchase.userOrder(idDoc(i));
    }
    
    FOR Purchase.UserOrderDetail d = Purchase.userOrderDetail(id(INTEGER i)) DO {
        sku(d) <- item(idItem(i));
        quantity(d) <- quantity(i);
        price (d) <- NUMERIC[16,4](price(i));
        invoicePrice(d) <- NUMERIC[16,4](price(i));
        invoiceSum(d) <- NUMERIC[16,4](totalPrice(i));        
        dataIndex(d) <- specItem(i);
        imported(d) <- TRUE;
    }

    VAT(Purchase.UserOrderDetail d) <- VAT(Purchase.sku[Purchase.UserOrderDetail](d), country(supplierStock(d))) WHERE [GROUP SUM 1 BY Purchase.userOrderDetail(id(INTEGER i))](d);
    valueVAT(Purchase.UserOrderDetail d) <- valueRate(VAT(d), date(d)) WHERE [GROUP SUM 1 BY Purchase.userOrderDetail(id(INTEGER i))](d);
    price (Purchase.UserOrderDetail d) <- round2(invoicePrice(d) * 100/(100 + calcValueVAT(d))) WHERE [GROUP SUM 1 BY Purchase.userOrderDetail(id(INTEGER i))](d);         

    overImportPurchaseOrder();
    
    APPLY;       
}

EXTEND FORM integrationData PROPERTIES importPurchaseOrder(), daysOrder(), numberOrder();
DESIGN integrationData { 
    supermagImportButtons { 
        NEW importOrders {
            type = CONTAINERV;
            MOVE PROPERTY (importPurchaseOrder());
            MOVE PROPERTY (daysOrder()) { alignment = CENTER; }
            MOVE PROPERTY (numberOrder()) { alignment = CENTER; }            
        } 
    } 
}

//------------------------------------------------------------------------------------заказы складские требования
stateInSuperMag 'Статус в супермаг' = DATA INTEGER (Sale.UserOrder);
prevStateInSuperMag 'Пред. статус в супермаг' = DATA INTEGER (Sale.UserOrder);
EXTEND FORM Sale.orders PROPERTIES stateInSuperMag(o);

importStockOrder 'Импорт заказов (складских требования)' () {
    
    LOCAL id = ISTRING[50] (INTEGER);
    LOCAL docstate = INTEGER (INTEGER);
    LOCAL idCustomerStock = INTEGER (INTEGER);
    LOCAL idSupplierStock = INTEGER (INTEGER);
    LOCAL comment = ISTRING[255] (INTEGER);
    LOCAL date = DATETIME (INTEGER);
    LOCAL deliveryDate = DATETIME (INTEGER);
    LOCAL deliveryTime = INTEGER (INTEGER);
    LOCAL filterSql = TEXT ();
    LOCAL file = FILE ();
    
    //входящие заказы - продажа
    filterSql() <- 'd.docstate IN (0, 2, 3) AND dd.location IN ('+ ImportSupermag.stocks() + ') AND dd.DeliveryDate >= TO_DATE(\'' + toDateISO(dateFromOrder()) + '\',\'YYYY-MM-DD\')'; 
    IF length(ImportSupermag.numberOrder()) > 0 THEN 
        filterSql() <- 'd.id = \'' + ImportSupermag.numberOrder() + '\''; 
                   
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base()  
    EXEC 'Select D.ID, D.DocState, D.createdat, D.Location, D.Commentary, DD.DeliveryDate, DD.DeliveryTime, DD.location AS supplierStock from Supermag.SMDocuments d, Supermag.SMStoreOrders dd WHERE DD.DocType(+)= D.DocType AND D.DocType = \'SO\' AND DD.ID(+)= D.ID AND ' + filterSql() TO file;   
    
    IMPORT TABLE FROM file() TO id, docstate, date, idCustomerStock, comment, deliveryDate, deliveryTime, idSupplierStock;   
    
    FOR [GROUP SUM 1 BY id(INTEGER i)](STRING[50] id) AND NOT Sale.userOrder(id) DO NEW o = Sale.UserOrder {
        id(o) <- id;
    }
    
    FOR Sale.UserOrder o == Sale.userOrder(id(INTEGER i)) DO {       
        number(o) <- STRING[28](id(i));
        isPosted(o) <- docstate(i) == 2 OR docstate(i) == 3;
        isClosed(o) <- docstate(i) == 3 OR docstate(i) == 0;
        isRejected(o) <- docstate(i) == 0;     
        stateInSuperMag(o) <- docstate(i);
        supplier(o) <- legalEntity(stock(ISTRING[100] (idSupplierStock(i))));
        supplierStock(o) <- stock(ISTRING[100] (idSupplierStock(i)));
        customer(o) <- legalEntity(stock(ISTRING[100] (idCustomerStock(i))));
        customerStock(o) <- stock(ISTRING[100] (idCustomerStock(i)));
        date(o) <- DATE (date(i));  
        time(o) <- 00:00;
        shipmentDate(o) <- DATE (deliveryDate(i));
        shipmentTime(o) <- sumMinutes(00:00, deliveryTime(i));
    }  

    FOR Sale.UserOrder o == Sale.userOrder(id(INTEGER i)) DO {       
       operation(o) <- CASE 
            WHEN     id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND     id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Sale.operation('saleWarehouseWarehouse')
            WHEN     id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND NOT id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Sale.operation('saleStoreWarehouse')
            WHEN NOT id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND     id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Sale.operation('saleWarehouseStore')
            WHEN NOT id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND NOT id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Sale.operation('saleStoreStore')
            ELSE Sale.operation('saleStoreStore');
    } 
    
    //импорт спецификаций
    LOCAL type = ISTRING[2](INTEGER);
    LOCAL idDoc = ISTRING[50](INTEGER);
    LOCAL specItem = INTEGER (INTEGER);
    LOCAL price = NUMERIC[19,4](INTEGER);
    LOCAL totalPrice = NUMERIC[19,4](INTEGER);
    LOCAL quantity = NUMERIC[14,3](INTEGER);
    LOCAL idItem = ISTRING[50](INTEGER);
    LOCAL imported = BOOLEAN (Sale.UserOrderDetail);

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base()  
            EXEC 'SELECT d.DOCTYPE, ds.DOCID, ds.SPECITEM, ds.ARTICLE, ds.QUANTITY, ds.ITEMPRICE, ds.TOTALPRICE FROM Supermag.SMDocuments d, Supermag.SMStoreOrders dd, Supermag.SMSpec ds WHERE DD.DocType(+)= D.DocType AND D.DocType = \'SO\' AND ds.DocType = \'SO\' AND ds.DOCID = dd.id AND dd.id = d.id AND ' + filterSql() TO file;
    
    IMPORT TABLE FROM file() TO type, idDoc, specItem, idItem, quantity, price, totalPrice;

    id(INTEGER i) <- CONCAT '', 'O', type(i), idDoc(i), specItem(i) WHERE imported(i); 

    FOR Sale.userOrder(idDoc(INTEGER i)) AND NOT Sale.userOrderDetail(id(i)) DO NEW d = Sale.UserOrderDetail {
        id(d) <- id(i);
        userOrder(d) <- Sale.userOrder(idDoc(i));
    }
    
    FOR Sale.UserOrderDetail d = Sale.userOrderDetail(id(INTEGER i)) DO {
        sku(d) <- item(idItem(i));
        quantity(d) <- quantity(i);
        price(d) <- NUMERIC[16,4](price(i));
        sum(d) <- NUMERIC[16,4](totalPrice(i));
        dataIndex(d) <- specItem(i);
        imported(d) <- TRUE;
    }
    
    APPLY;
    
    // заказы исходящие от магазина - закупка
    filterSql() <- 'd.docstate IN (0, 2, 3) AND d.location IN ('+ ImportSupermag.stocks() + ') AND dd.DeliveryDate >= TO_DATE(\'' + toDateISO(dateFromOrder()) + '\',\'YYYY-MM-DD\')'; 
    IF length(ImportSupermag.numberOrder()) > 0 THEN 
        filterSql() <- 'd.id = \'' + ImportSupermag.numberOrder() + '\''; 
                   
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base()  
    EXEC 'Select D.ID, D.DocState, D.createdat, D.Location, D.Commentary, DD.DeliveryDate, DD.DeliveryTime, DD.location AS supplierStock from Supermag.SMDocuments d, Supermag.SMStoreOrders dd where DD.DocType(+)= D.DocType AND D.DocType = \'SO\' AND DD.ID(+)= D.ID AND ' + filterSql() TO file;   
    
    IMPORT TABLE FROM file() TO id, docstate, date, idCustomerStock, comment, deliveryDate, deliveryTime, idSupplierStock;   
    
    FOR [GROUP SUM 1 BY id(INTEGER i)](STRING[50] id) AND NOT Purchase.userOrder(id) DO NEW o = Purchase.UserOrder {
        id(o) <- id;
    }
    
    FOR Purchase.UserOrder o == Purchase.userOrder(id(INTEGER i)) DO {       
        number[Document](o) <- STRING[28](id(i));
        isPosted(o) <- docstate(i) == 2 OR docstate(i) == 3;
        isClosed(o) <- docstate(i) == 3 OR docstate(i) == 0;
        isRejected(o) <- docstate(i) == 0;
        stateInSuperMag(o) <- docstate(i);
        supplier(o) <- legalEntity(stock(ISTRING[100] (idSupplierStock(i))));
        supplierStock(o) <- stock(ISTRING[100] (idSupplierStock(i)));
        customer(o) <- legalEntity(stock(ISTRING[100] (idCustomerStock(i))));
        customerStock(o) <- stock(ISTRING[100] (idCustomerStock(i)));
        date(o) <- DATE (date(i));  
        time(o) <- 00:00;
        shipmentDate(o) <- DATE (deliveryDate(i));
        shipmentTime(o) <- sumMinutes(00:00, deliveryTime(i));
        createSale(o) <- NULL;       
    }  
        
    FOR Purchase.UserOrder o == Purchase.userOrder(id(INTEGER i)) DO {       
       operation(o) <- CASE 
            WHEN     id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND     id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Purchase.operation('purchaseWarehouseWarehouse')
            WHEN     id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND NOT id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Purchase.operation('purchaseWarehouseStore')
            WHEN NOT id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND     id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Purchase.operation('purchaseStoreWarehouse')
            WHEN NOT id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND NOT id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Purchase.operation('purchaseStoreStore')
            ELSE Purchase.operation('purchaseStoreStore');
    } 
    
    IF length(ImportSupermag.numberOrder()) > 0 THEN {
        FOR Purchase.UserOrder o == Purchase.userOrder(id(INTEGER i)) DO {
            MESSAGE id(stockGroup(customerStock(o))) + ' ' +id(stockGroup(supplierStock(o))) + '=' + id(Purchase.operation(o));      
        }       
    } 
    
    
    //импорт спецификаций
    LOCAL imported = BOOLEAN (Purchase.UserOrderDetail);

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base()  
            EXEC 'SELECT d.DOCTYPE, ds.DOCID, ds.SPECITEM, ds.ARTICLE, ds.QUANTITY, ds.ITEMPRICE, ds.TOTALPRICE FROM Supermag.SMDocuments d, Supermag.SMStoreOrders dd, Supermag.SMSpec ds WHERE DD.DocType(+)= D.DocType AND D.DocType = \'SO\' AND ds.DocType = \'SO\' AND ds.DOCID = dd.id AND dd.id = d.id AND ' + filterSql() TO file;
    
    IMPORT TABLE FROM file() TO type, idDoc, specItem, idItem, quantity, price, totalPrice;

    id(INTEGER i) <- CONCAT '', 'O', type(i), idDoc(i), specItem(i) WHERE imported(i); 

    FOR Purchase.userOrder(idDoc(INTEGER i)) AND NOT Purchase.userOrderDetail(id(i)) DO NEW d = Purchase.UserOrderDetail {
        id(d) <- id(i);
        Purchase.userOrder(d) <- Purchase.userOrder(idDoc(i));
    }
    
    FOR Purchase.UserOrderDetail d = Purchase.userOrderDetail(id(INTEGER i)) DO {
        sku(d) <- item(idItem(i));
        quantity(d) <- quantity(i);
        price(d) <- NUMERIC[16,4](price(i));
        sum(d) <- NUMERIC[16,4](totalPrice(i));
        dataIndex(d) <- specItem(i);
        imported(d) <- TRUE;
    }
    
    APPLY;           
}

EXTEND FORM integrationData PROPERTIES importStockOrder();
DESIGN integrationData { 
    supermagImportButtons { 
        importOrders {
            MOVE PROPERTY (importStockOrder()) AFTER PROPERTY (importPurchaseOrder());
        } 
    } 
}

//------------------------------------------------------------------------------------накладные перемещения
stateInSuperMag 'Статус в супермаг' = DATA INTEGER (Purchase.UserInvoice);
prevStateInSuperMag 'Пред. статус в супермаг' = DATA INTEGER (Purchase.UserInvoice);
stateInSuperMag 'Статус в супермаг' = DATA INTEGER (Sale.UserInvoice);
prevStateInSuperMag 'Пред. статус в супермаг' = DATA INTEGER (Sale.UserInvoice);
EXTEND FORM Purchase.invoices PROPERTIES stateInSuperMag(i);
EXTEND FORM Sale.invoices PROPERTIES stateInSuperMag(i);

importStockInternalInvoice 'Импорт накладные перемещения на магазин' () {
    
    LOCAL id = ISTRING[50] (INTEGER);
    LOCAL docstate = INTEGER (INTEGER);
    LOCAL opercode = INTEGER (INTEGER);
    LOCAL idCustomerStock = INTEGER (INTEGER);
    LOCAL idSupplierStock = INTEGER (INTEGER);
    LOCAL comment = ISTRING[255] (INTEGER);
    LOCAL date = DATETIME (INTEGER);
    LOCAL deliveryDate = DATE (INTEGER);
    LOCAL deliveryTime = INTEGER (INTEGER);
    LOCAL filterSql = TEXT ();
    LOCAL file = FILE ();
    LOCAL imported = BOOLEAN (Sale.UserInvoice);
       
    //  накладные созданые в СМ где получатели склады импорта, загружаем в Sale чтобы ТО потом руками созал свой приход, по стандартной схеме Fusion
    filterSql() <- 'b.DocType(+)= D.DocType AND D.DocType = \'IW\' AND D.opcode = 4 AND b.id = d.id AND d.docstate IN (0, 2, 3) AND d.locationto IN ('+ ImportSupermag.stocks() + ') AND NOT d.locationfrom IN ('+ ImportSupermag.stocks() + ') AND d.CreateDat >= TO_DATE(\'' + toDateISO(dateFromOrder()) + '\',\'YYYY-MM-DD\')'; 
    IF length(ImportSupermag.numberOrder()) > 0 THEN 
        filterSql() <- 'b.DocType(+)= D.DocType AND D.DocType = \'IW\' AND b.id = d.id AND d.id = \'' + ImportSupermag.numberOrder() + '\''; 
       
   // MESSAGE 'Select D.ID, D.DocState, D.createdat, D.opcode, D.Locationfrom AS supplierStock, D.Locationto, D.Commentary from Supermag.SMDocuments d, Supermag.SMInternalWayBills b where ' + filterSql();               
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base()  
    EXEC 'Select D.ID, D.DocState, D.createdat, D.opcode, D.Locationfrom AS supplierStock, D.Locationto, D.Commentary from Supermag.SMDocuments d, Supermag.SMInternalWayBills b where ' + filterSql() TO file;   
    
    IMPORT TABLE FROM file() TO id, docstate, date, opercode, idSupplierStock, idCustomerStock, comment;   
    
    FOR [GROUP SUM 1 BY id(INTEGER i)](STRING[50] id) AND NOT Sale.userInvoice(id) DO NEW o = Sale.UserInvoice {
        id(o) <- id;
    }
    
    FOR Sale.UserInvoice o == Sale.userInvoice(id(INTEGER i)) DO {       
        number[Document](o) <- STRING[28](id(i));
        isPosted(o) <- docstate(i) == 2 OR docstate(i) == 3;
        isClosed(o) <- docstate(i) == 3 OR docstate(i) == 0;
        stateInSuperMag(o) <- docstate(i);
        supplier(o) <- legalEntity(stock(ISTRING[100] (idSupplierStock(i))));
        supplierStock(o) <- stock(ISTRING[100] (idSupplierStock(i)));
        customer(o) <- legalEntity(stock(ISTRING[100] (idCustomerStock(i))));
        customerStock(o) <- stock(ISTRING[100] (idCustomerStock(i)));
        date(o) <- DATE (date(i));  
        time(o) <- 00:00;
        imported(o) <- TRUE;
    }  
        
    FOR Sale.UserInvoice o == Sale.userInvoice(id(INTEGER i)) DO {       
       operation(o) <- CASE 
            WHEN     id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND     id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Sale.operation('saleWarehouseWarehouse')
            WHEN     id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND NOT id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Sale.operation('saleStoreWarehouse')
            WHEN NOT id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND     id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Sale.operation('saleWarehouseStore')
            WHEN NOT id(stockGroup(customerStock(o))) = STRING (idGroupWarehouseInSuperMag()) AND NOT id(stockGroup(supplierStock(o))) = STRING (idGroupWarehouseInSuperMag()) THEN Sale.operation('saleStoreStore')
            ELSE Sale.operation('saleStoreStore');
    } 
    
    IF length(ImportSupermag.numberOrder()) > 0 THEN {
        FOR Sale.UserInvoice o == Sale.userInvoice(id(INTEGER i)) DO {
            MESSAGE id(stockGroup(customerStock(o))) + ' ' +id(stockGroup(supplierStock(o))) + '=' + id(Sale.operation(o));      
        }       
    }  
     
    //импорт спецификаций
    LOCAL type = ISTRING[2](INTEGER);
    LOCAL idDoc = ISTRING[50](INTEGER);
    LOCAL specItem = INTEGER (INTEGER);
    LOCAL price = NUMERIC[19,4](INTEGER);
    LOCAL totalPrice = NUMERIC[19,4](INTEGER);
    LOCAL quantity = NUMERIC[14,3](INTEGER);
    LOCAL idItem = ISTRING[50](INTEGER);
    LOCAL imported = BOOLEAN (Sale.UserInvoiceDetail);

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base()  
            EXEC 'SELECT d.DOCTYPE, ds.DOCID, ds.SPECITEM, ds.ARTICLE, ds.QUANTITY, ds.ITEMPRICE, ds.TOTALPRICE FROM Supermag.SMDocuments d, Supermag.SMInternalWayBills b, Supermag.SMSpec ds WHERE ds.DocType = \'IW\' AND ds.DOCID = d.id  AND ' + filterSql() TO file;
    
    IMPORT TABLE FROM file() TO type, idDoc, specItem, idItem, quantity, price, totalPrice;

    id(INTEGER i) <- CONCAT '', 'I', type(i), idDoc(i), specItem(i) WHERE imported(i); 

    FOR Sale.userInvoice(idDoc(INTEGER i)) AND NOT Sale.userInvoiceDetail(id(i)) DO NEW d = Sale.UserInvoiceDetail {
        id(d) <- id(i);
        Sale.userInvoice(d) <- Sale.userInvoice(idDoc(i));
    }
    
    FOR Sale.UserInvoiceDetail d = Sale.userInvoiceDetail(id(INTEGER i)) DO {
        sku(d) <- item(idItem(i));
        quantity(d) <- quantity(i);
        price(d) <- NUMERIC[16,4](price(i));
        sum(d) <- NUMERIC[16,4](totalPrice(i));
        dataIndex(d) <- specItem(i);
        imported(d) <- TRUE;
    }
    
    APPLY;           
}

EXTEND FORM integrationData PROPERTIES importStockInternalInvoice();
DESIGN integrationData { 
    supermagImportButtons { 
        NEW importInvoicess {
            MOVE PROPERTY (importStockInternalInvoice());
        } 
    } 
}


//-----------------------------------------------------------------------------------------------------------------------------заказы продажа
importSaleOrder 'Импорт заказов (продажа)' () {
    
    LOCAL id = ISTRING[50] (INTEGER);
    LOCAL docstate = INTEGER (INTEGER);
    LOCAL idCustomer = INTEGER (INTEGER);
    LOCAL idSupplierStock = INTEGER (INTEGER);
    LOCAL comment = ISTRING[255] (INTEGER);
    LOCAL date = DATETIME (INTEGER);
    LOCAL supplyDate = DATETIME (INTEGER);
    LOCAL supplyTime = INTEGER (INTEGER);
    LOCAL filterSql = TEXT ();
    LOCAL file = FILE ();

    filterSql() <- 'd.docstate IN (0, 2, 3) AND d.location IN ('+ ImportSupermag.stocks() + ') and dd.SupplyDate >= TO_DATE(\'' + toDateISO(ImportSupermag.dateFromOrder()) + '\',\'YYYY-MM-DD\')'; 
    IF length(ImportSupermag.numberOrder()) > 0 THEN 
        filterSql() <- 'd.id = \'' + ImportSupermag.numberOrder() + '\''; 

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
    EXEC 'Select D.ID, D.DocState, D.ClientIndex, D.Location, D.Commentary, DD.OrderDate, DD.SupplyDate, DD.SupplyTime from Supermag.SMDocuments D, Supermag.SMDocOc DD where DD.DocType(+)= D.DocType and D.DocType = \'OC\' and DD.ID(+)= D.ID AND ' + filterSql() TO file;   

    IMPORT TABLE FROM file() TO id, docstate, idCustomer, idSupplierStock, comment, date, supplyDate, supplyTime;

    FOR [GROUP SUM 1 BY id(INTEGER i)](STRING[50] id) AND NOT Sale.userOrder(id) DO NEW o = Sale.UserOrder {
        id(o) <- id;
    }

    FOR Sale.UserOrder o == Sale.userOrder(id(INTEGER i)) DO {       
        number(o) <- STRING[28](id(i));
        operation(o) <- Sale.operation('saleStoreCustomer');
        isPosted(o) <- docstate(i) == 2 OR docstate(i) == 3;
        isClosed(o) <- docstate(i) == 3 OR docstate(i) == 0;
        stateInSuperMag(o) <- docstate(i);
        supplier(o) <- legalEntity(stock(ISTRING[100] (idSupplierStock(i))));
        supplierStock(o) <- stock(ISTRING[100] (idSupplierStock(i)));
        customer(o) <- legalEntity(stock(ISTRING[100] (idCustomer(i))));
        customerStock(o) <- stock(ISTRING[100] (idCustomer(i)));
        date(o) <- DATE (date(i));  
        time(o) <- 00:00;
        shipmentDate(o) <- DATE(supplyDate(i));
        shipmentTime(o) <- sumMinutes(00:00, supplyTime(i));
    }  

    //импорт спецификаций
    LOCAL type = ISTRING[2](INTEGER);
    LOCAL idDoc = ISTRING[50](INTEGER);
    LOCAL specItem = INTEGER (INTEGER);
    LOCAL price = NUMERIC[19,4](INTEGER);
    LOCAL totalPrice = NUMERIC[19,4](INTEGER);
    LOCAL quantity = NUMERIC[14,3](INTEGER);
    LOCAL idItem = ISTRING[50](INTEGER);
    LOCAL imported = BOOLEAN (Sale.UserOrderDetail);

    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base()  
            EXEC 'SELECT d.DOCTYPE, ds.DOCID, ds.SPECITEM, ds.ARTICLE, ds.QUANTITY, ds.ITEMPRICE, ds.TOTALPRICE FROM Supermag.SMDocuments d, Supermag.SMDocOc dd, Supermag.SMSpec ds WHERE DD.DocType(+)= D.DocType and D.DocType = \'OC\' and ds.DocType = \'OC\' and ds.DOCID = dd.id AND dd.id = d.id AND ' + filterSql() TO file;

    IMPORT TABLE FROM file() TO type, idDoc, specItem, idItem, quantity, price, totalPrice;

    id(INTEGER i) <- CONCAT '', 'O', type(i), idDoc(i), specItem(i) WHERE imported(i); 

    FOR Sale.userOrder(idDoc(INTEGER i)) AND NOT Sale.userOrderDetail(id(i)) DO NEW d = Sale.UserOrderDetail {
        id(d) <- id(i);
        userOrder(d) <- Sale.userOrder(idDoc(i));
    }

    FOR Sale.UserOrderDetail d = Sale.userOrderDetail(id(INTEGER i)) DO {
        sku(d) <- item(idItem(i));
        quantity(d) <- quantity(i);
        price(d) <- NUMERIC[16,4](price(i));
        sum(d) <- NUMERIC[16,4](totalPrice(i));
        dataIndex(d) <- specItem(i);
        imported(d) <- TRUE;
    }

    APPLY;
}

EXTEND FORM integrationData PROPERTIES importSaleOrder();
DESIGN integrationData { 
    supermagImportButtons { 
        importOrders {
            MOVE PROPERTY (importSaleOrder()) AFTER PROPERTY (importPurchaseOrder());
        } 
    } 
}

//-------------------------------------------------------------------------------------------------------------------сверка остатков
dateCheckBalance 'Дата сверки' = DATA DATE ();
synchronizeBalance 'Привести остатки к данным Супермага' = DATA BOOLEAN ();

hostBalance 'Хост для сверки остатков' = DATA LOCAL ISTRING[100]();
    
checkBalance 'Сверить остатки' () {
    
    LOCAL idItem = ISTRING[50](INTEGER);
    LOCAL idStock = INTEGER (INTEGER);
    LOCAL quantity = NUMERIC[19,4](INTEGER);
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ (OVERRIDE hostBalance(), host()) + '/' + base() 
            EXEC 'SELECT ARTICLE, STORELOC, CAST(QUANTITY AS numeric(16,4)) FROM Supermag.SVGOODSWITHOPER WHERE STORELOC IN (' + stocks() + ')' TO file;

    IMPORT TABLE FROM file() TO idItem, idStock, quantity;
    
    LOCAL balanceB = NUMERIC[16,5](Sku, Stock);
    LOCAL balanceS = NUMERIC[16,5](Sku, Stock);
    
    balanceB(Sku sk, Stock st) <-  balanceB(sk, st, dateCheckBalance()) WHERE in(st);
    balanceS(Sku sk, Stock st) <-  [GROUP MAX quantity(INTEGER i) BY item(idItem(i)), stock(TEXT (idStock(i)))](sk, st);
    
    FOR (balanceB(Sku sk, Stock st) OR balanceS(sk, st)) AND NOT (OVERRIDE balanceB(sk, st), 0.0) == balanceS(sk, st) DO {
        logToFile('checkBalance', CONCAT ' ', toDateDDMMYY(dateCheckBalance()), 'Товар: ' + id(sk) +  ' - ' + nameSkuGroup(sk) + ' / ' + name(sk), 'Склад: ' + id(st), 'Остаток (фьюжн): ' + balanceB(sk, st), 'Остаток (супермаг): ' + balanceS(sk, st));
    }
    
    IF synchronizeBalance() THEN {
    
        FOR synchronizeBalance() AND [GROUP SUM 1 BY stock(TEXT (idStock(INTEGER i)))](Stock st) AND NOT Purchase.userInvoice('equal_balance_' + id(st)) DO NEW i = Purchase.UserInvoice {
            id(i) <- 'equal_balance_' + id(st);
            operation(i) <- Purchase.operation('initial');
            customer(i) <- legalEntity(st);
            customerStock(i) <- st;
            isPosted(i) <- TRUE;
            date(i) <- 2010_01_01;
        }
        
        FOR (balanceB(Sku sk, Stock st) OR balanceS(sk, st)) AND NOT (OVERRIDE balanceB(sk, st), 0.0) == balanceS(sk, st) 
            AND NOT [GROUP MAX Purchase.UserInvoiceDetail dd BY Purchase.userInvoice(dd), sku(dd)](Purchase.userInvoice('equal_balance'), sk) DO NEW d = Purchase.UserInvoiceDetail {
            userInvoice(d) <- Purchase.userInvoice('equal_balance_' + id(st));
            sku(d) <- sk;
        }
            
        FOR (balanceB(Sku sk, Stock st) OR balanceS(sk, st)) AND NOT (OVERRIDE balanceB(sk, st), 0.0) == balanceS(sk, st) 
            AND Purchase.UserInvoiceDetail d == [GROUP MAX Purchase.UserInvoiceDetail dd BY Purchase.userInvoice(dd), sku(dd)](Purchase.userInvoice('equal_balance_' + id(st)), sk) DO {
            
            quantity(d) <- quantity(d) (+) balanceS(sk, st) (-) balanceB(sk, st);
        }
        
        APPLY;
    }
}

EXTEND FORM integrationData PROPERTIES () dateCheckBalance, synchronizeBalance, checkBalance;

DESIGN integrationData {
    supermagRight {
        NEW check {
            caption = 'Сверка остатков';
            type = CONTAINERH;
            alignment = STRETCH;
            MOVE PROPERTY (checkBalance());
            MOVE PROPERTY (dateCheckBalance()) { alignment = CENTER; }
            MOVE PROPERTY (synchronizeBalance()) { alignment = CENTER; }
        }
    }
}

idStock = DATA LOCAL INTEGER (INTEGER);
numeric = DATA LOCAL NUMERIC[14,3] (INTEGER);

overImportShelfReserve ABSTRACT LIST();

importShelfReserve 'Импорт полки' () {
        
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() EXEC 'SELECT ARTICLE, STORELOC, SHOWLEVEL FROM Supermag.smstocklevels' TO file;
    
    IMPORT TABLE FROM file() TO idItem, idStock, numeric;
    
    overImportShelfReserve();
    
    APPLY;
}

overImportFillRateShelf ABSTRACT LIST();
overImportFillRateAps ABSTRACT LIST();

importFillRate 'Импорт заполненности' () {
        
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT STORELOC, PROPVAL FROM Supermag.smstoreproperties  WHERE PROPID = \'k_showlevel\'' TO file;
    
    IMPORT TABLE FROM file() TO idStock, value;
    
    overImportFillRateShelf();
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT STORELOC, PROPVAL FROM Supermag.smstoreproperties  WHERE PROPID = \'k_showrequest\'' TO file;
    
    IMPORT TABLE FROM file() TO idStock, value;
    
    overImportFillRateAps();
    
    APPLY;
}

overImportBufferAps ABSTRACT LIST();

importBufferAps 'Импорт ДМП' () {
        
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT ARTICLE, STORELOC, SHOWREQUEST FROM Supermag.smstocklevels WHERE SHOWREQUEST > 0' TO file;
    
    IMPORT TABLE FROM file() TO idItem, idStock, numeric;
    
    overImportBufferAps();
    
    APPLY;
}

overImportPlanTurnover ABSTRACT LIST();

idItemGroup = DATA LOCAL INTEGER (INTEGER);
    
importPlanTurnover 'Импорт плановой оборачиваемости' () {
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT CLASSID, TURNOVER FROM Supermag.AMCLASSTURNOVER' TO file;
    
    IMPORT TABLE FROM file() TO idItemGroup, numeric;
    
    overImportPlanTurnover();
    
    APPLY;
}

//docType = DATA LOCAL ISTRING[10](INTEGER);
idDoc = DATA LOCAL ISTRING[50](INTEGER);
dateFrom = DATA DATETIME (INTEGER);
dateTo = DATA DATETIME (INTEGER);

overImportBufferApsAdDocs ABSTRACT LIST();
overImportBufferApsAdStocks ABSTRACT LIST();
overImportBufferApsAdQuantity ABSTRACT LIST();

importBufferApsAd 'Импорт рекламных кампаний' () {
        
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT ID, STARTDATE, ENDDATE FROM SuperMag.SVDocNoPricePA' TO file;
    
    IMPORT TABLE FROM file() TO idDoc, dateFrom, dateTo;
    
    overImportBufferApsAdDocs();
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'SELECT ID, LOCATIONID FROM Supermag.SMPromoLocations' TO file;
    
    IMPORT TABLE FROM file() TO idDoc, idStock;
    
    overImportBufferApsAdStocks();
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
        EXEC 'select DOCID, ARTICLE, QUANTITY from Supermag.SVItemsPA' TO file;
    
    IMPORT TABLE FROM file() TO idDoc, idItem, numeric;
    
    overImportBufferApsAdQuantity();
    
    APPLY;
}

EXTEND FORM integrationData PROPERTIES () importShelfReserve, importFillRate, importBufferAps, importPlanTurnover, importBufferApsAd;
DESIGN integrationData { 
    supermagImportButtons { 
        NEW bufferAps {
            type = CONTAINERH;
            MOVE PROPERTY (importShelfReserve());
            MOVE PROPERTY (importFillRate());
            MOVE PROPERTY (importBufferAps());
        } 
        MOVE PROPERTY (importPlanTurnover());
        MOVE PROPERTY (importBufferApsAd());
    } 
}

userShipment (Stock st) = GROUP MAX Purchase.UserShipment s IF id(s) == ('init_' + id(customerStock(s))) BY customerStock(s);
userShipmentDetail (Stock st, Sku sk) = GROUP MAX Purchase.UserShipmentDetail d IF userShipment(d) == userShipment(st) BY sku(d);

importBalanceShipment 'Импорт остатков (поставки)' () {
    
    LOCAL balance = NUMERIC[16,4] (INTEGER);
    
    LOCAL file = FILE ();
    
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ (OVERRIDE hostBalance(), host()) + '/' + base() 
        EXEC 'SELECT ARTICLE, STORELOC, CAST(QUANTITY AS numeric(16,4)) FROM Supermag.SVGOODSWITHOPER WHERE STORELOC IN (' + stocks() + ')' TO file;
        
    IMPORT TABLE FROM file() TO idItem, idStock, balance;
    
    FOR INTEGER i = [GROUP MIN INTEGER ii IF NOT userShipment(stock(TEXT (idStock(ii)))) BY stock(TEXT (idStock(ii)))](Stock st) DO NEW s = Purchase.UserShipment {
        id(s) <- 'init_' + id(stock(TEXT (idStock(i))));
        operation(s) <- Purchase.operation('initial');
        customerStock(s) <- stock(TEXT (idStock(i)));
        customer(s) <- legalEntity(stock(TEXT (idStock(i))));
        isPosted(s) <- TRUE;
        date(s) <- 2010_01_01;
    }
    
    FOR [GROUP SUM 1 IF imported(INTEGER i) AND NOT userShipmentDetail(stock(TEXT (idStock(i))), item(idItem(i))) AND NOT balance(i) == 0 
        BY stock(TEXT (idStock(i))), item(idItem(i))](Stock st, Item sk) DO NEW d = Purchase.UserShipmentDetail {
        userShipment(d) <- userShipment(st);
        sku(d) <- sk;
    }
    
    FOR Purchase.UserShipmentDetail d == userShipmentDetail(stock(TEXT (idStock(INTEGER i))), item(idItem(i))) DO {
        quantity(d) <- balance(i);
    }
    
    FOR Purchase.UserShipmentDetail d  == userShipmentDetail(Stock st, Sku sk) AND (OVERRIDE quantity(d), 0) == 0 DO {
        DELETE d;
    }
    
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importBalanceShipment();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importBalanceShipment()); } }

importReserveDays 'Импорт страхового запаса в днях' () {
    
    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ (OVERRIDE hostBalance(), host()) + '/' + base() 
        EXEC 'SELECT ARTICLE, STORELOC, MINDAYS FROM Supermag.SMStockLevels WHERE STORELOC IN(' + stocks() + ')' TO file;
        
    IMPORT TABLE FROM file() TO idItem, idStock, quantity;
    
    FOR Item sk = sku(idItem(INTEGER i)) AND Stock st = stock(TEXT (idStock(i))) DO {
        dataStockReserveDays(st, sk) <- NUMERIC[14,3](quantity(i));
    }
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importReserveDays();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importReserveDays()); } }

dateFromPurchase 'Дата перемещения' = DATA DATE (Store);

EXTEND FORM stores PROPERTIES READONLYIF isReadonly() dateFromPurchase(s);
EXTEND FORM store PROPERTIES dateFromPurchase(s);

DESIGN store {
    headerExtraParams {
        MOVE PROPERTY (dateFromPurchase(s));
    }
}

importPurchaseStore 'Импорт документов перемещения' ()  {
    
    LOCAL type = ISTRING[2](INTEGER);
    LOCAL id = ISTRING[50] (INTEGER);
    LOCAL idSupplierStockInt = INTEGER (INTEGER);
    LOCAL docstate = INTEGER (INTEGER);
    LOCAL imported = BOOLEAN (Purchase.UserInvoice);
    LOCAL stocks = TEXT ();
    
    FOR dateFromPurchase(Store s) DO {
        
        stocks() <- NULL;
        stocks() <- GROUP CONCAT id(DepartmentStore st) IF store(st) == s, ',' ORDER st;
        
        EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
            EXEC 'SELECT DOCTYPE, ID, CREATEDAT, LOCATIONFROM, LOCATIONTO, DOCSTATE FROM SuperMag.SVDocumentsIW WHERE CREATEDAT >= TO_DATE(\''
            + toDateISO(dateFromPurchase(s)) + '\',\'YYYY-MM-DD\') AND LOCATIONTO IN(' + stocks() + ')' TO file;
        
        IMPORT TABLE FROM file() TO type, id, date, idSupplierStockInt, idCustomerStockInt, docstate;
        
        FOR id(INTEGER i) AND NOT Purchase.userInvoice(id(i)) DO NEW ui = Purchase.UserInvoice {
            id(ui) <- id(i);
        }
        
        FOR Purchase.UserInvoice ui = Purchase.userInvoice(id(INTEGER i)) DO {
            number(ui) <- STRING[28](id(i));
            supplierStock(ui) <- stock(TEXT (idSupplierStockInt(i)));
            supplier(ui) <- legalEntity(stock(TEXT (idSupplierStockInt(i))));
            customerStock(ui) <- stock(TEXT (idCustomerStockInt(i)));
            customer(ui) <- legalEntity(stock(TEXT (idCustomerStockInt(i))));
            operation(ui) <- CASE WHEN stock(TEXT (idSupplierStockInt(i))) IS DepartmentStore THEN Purchase.operation('purchaseStoreStore')
                                  ELSE Purchase.operation('purchaseStoreWarehouse');
            date(ui) <- DATE (date(i));
            time(ui) <- 00:00;
            isPosted(ui) <- TRUE;
            createShipment(ui) <- NULL;
            imported(ui) <- TRUE;
        }
        
        LOCAL sum = NUMERIC[16,4](INTEGER);
        LOCAL idDetail = ISTRING[100](INTEGER);
        LOCAL imported = BOOLEAN (Purchase.UserInvoiceDetail);
    
        EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ host() + '/' + base() 
            EXEC 'SELECT s.DOCTYPE, s.DOCID, s.SPECITEM, s.ARTICLE, s.QUANTITY, s.ITEMPRICE, s.TOTALPRICE FROM SuperMag.SVSpecIW s, SuperMag.SVDocumentsIW d WHERE s.docid = d.id AND d.CREATEDAT >= TO_DATE(\''
            + toDateISO(dateFromPurchase(s)) + '\',\'YYYY-MM-DD\') AND LOCATIONTO IN(' + stocks() + ')' TO file;
        
        IMPORT TABLE FROM file() TO type, id, spec, idItem, quantity, price, sum;
        
        idDetail(INTEGER i) <- CONCAT '-', type(i), id(i), spec(i) WHERE imported(i);
        
        //строки
        FOR imported(INTEGER r) AND NOT Purchase.userInvoiceDetail(idDetail(r)) DO 
            NEW d = Purchase.UserInvoiceDetail {
            id(d) <- idDetail(r);
        }
            
        FOR Purchase.UserInvoiceDetail d == Purchase.userInvoiceDetail(idDetail(INTEGER r)) INLINE DO {
            userInvoice(d) <- Purchase.userInvoice(id(r));
            sku(d) <- sku(idItem(r));
            quantity(d) <- quantity(r);
            shipmentQuantity(d) <- quantity(r);
            VAT(d) <- VAT(sku(idItem(r))); 
            valueVAT(d) <- valueVAT(sku(idItem(r)));
            price(d) <- NUMERIC[16,4](price(r));
            retailPrice(d) <- NUMERIC[16,4](price(r));
            sum(d) <- sum(r);
            retailVAT(d) <- VAT(sku(idItem(r)));
            valueRetailVAT(d) <- valueVAT(sku(idItem(r)));
            dataIndex(d) <- spec(r);
            imported(d) <- TRUE;
        }
        
        DELETE Purchase.UserInvoice i WHERE (operation(i) == Purchase.operation('purchaseStoreStore') OR operation(i) == Purchase.operation('purchaseStoreWarehouse')) AND NOT date(i) < dateFromPurchase(s) AND NOT imported(i);
        DELETE Purchase.UserInvoiceDetail d WHERE(operation(d) == Purchase.operation('purchaseStoreStore') OR operation(d) == Purchase.operation('purchaseStoreWarehouse')) AND NOT date(d) < dateFromPurchase(s) AND NOT imported(d);
    }
    APPLY;
} 

EXTEND FORM integrationData PROPERTIES () importPurchaseStore;
DESIGN integrationData { 
    supermagImportButtons { 
        NEW saleWarehouse {
            MOVE PROPERTY (importPurchaseStore());
        } 
    } 
}

@defineLogRotate(checkBalance, 5, weekly);
@defineLogRotate(importSupermag, 5, weekly);

part (Item set, Item item) = GROUP MAX Part p BY set(p), item(p);

importItemPart 'Импорт комплектов' () {

    LOCAL idSet = ISTRING[50] (INTEGER);
    LOCAL quantity = NUMERIC[16,3] (INTEGER);
    LOCAL percent = NUMERIC[16,2] (INTEGER);

    LOCAL file = FILE ();
    EXTERNAL SQL 'jdbc:oracle:thin:' + login() + '/' + password() + '@//'+ (OVERRIDE hostBalance(), host()) + '/' + base() 
        EXEC 'select ca.ComplexArticle,ca.Article,ca.Amount,ca.PricePercent from Supermag.SVComplexCompositeArt ca' TO file;
        
    IMPORT TABLE FROM file() TO idSet, idItem, quantity, percent;
    
    FOR [GROUP SUM 1 BY sku(idSet(INTEGER i)), sku(idItem(i))](Item set, Item item) AND NOT part(set, item) DO NEW p = Part {
        set(p) <- set;
        item(p) <- item;
        skuType(set) <- SkuType.skuTypeSet;
    }
    
    FOR Part p = part(sku(idSet(INTEGER i)), sku(idItem(i))) DO {
        quantity(p) <- quantity(i);
        percent(p) <- percent(i);
    }
    
    APPLY;
}

EXTEND FORM integrationData PROPERTIES importItemPart();
DESIGN integrationData { supermagImportButtons { MOVE PROPERTY (importItemPart()); } }
