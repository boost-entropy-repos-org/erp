MODULE PriceListBefore;

REQUIRE PriceList, PriceListOperation;

NAMESPACE PriceList;


inPriceListBeforeDataPriceListType 'Изменять цены (до)' = ABSTRACT BOOLEAN (PriceList, DataPriceListType) PERSISTENT;
inUserPriceListBeforeDataPriceListType 'Изменять цены (до)' = DATA BOOLEAN (UserPriceList, DataPriceListType);
inPriceListBeforeDataPriceListType (priceList, dataPriceListType) += inUserPriceListBeforeDataPriceListType(priceList, dataPriceListType);

countBeforeDataPriceListTypesPriceList = GROUP SUM 1 IF inPriceListBeforeDataPriceListType(p,t) BY p;
countBeforeDataPriceListTypesUserPriceList = GROUP SUM 1 IF inUserPriceListBeforeDataPriceListType(p,t) BY p;

changeBeforeDataPriceListTypeOperation 'Изменять цены (до)' = DATA BOOLEAN (DataPriceListType, Operation);

inUserPriceListBeforeDataPriceListType(priceList, dataPriceListType) <- changeBeforeDataPriceListTypeOperation(dataPriceListType, operationUserPriceList(priceList))
    WHEN CHANGED(operationUserPriceList(priceList));
    
EXTEND FORM operation
    PROPERTIES(pt, o) changeBeforeDataPriceListTypeOperation TODRAW pt FORCE GRID AFTER showPriceListTypeOperation(pt, o)
    
;

priceBeforePriceListDetail 'Цена до' = ABSTRACT NUMERIC[14,2] (PriceListDetail);
priceBeforeUserPriceListDetail 'Цена до' = DATA NUMERIC[14,2] (UserPriceListDetail);
priceBeforePriceListDetail(d) += priceBeforeUserPriceListDetail(d);

priceListTypeBeforeUserPriceList 'Вид цены для цены до' = DATA DataPriceListType (UserPriceList);

showPriceBeforePriceList 'Цена до' =  ABSTRACT BOOLEAN (PriceList);   
showPriceBeforeUserPriceList 'Цена до' =  DATA BOOLEAN (UserPriceList);  
showPriceBeforeUserPriceListDetail (d) = showPriceBeforeUserPriceList(userPriceListUserPriceListDetail(d));
showPriceBeforePriceList(p) += showPriceBeforeUserPriceList(p);

EXTEND FORM userPriceList 
    PROPERTIES(p) showPriceBeforeUserPriceList
    PROPERTIES(p,t) FORCE GRID inUserPriceListBeforeDataPriceListType SHOWIF showPriceBeforeUserPriceList(p)        
    PROPERTIES(d) priceBeforeUserPriceListDetail SHOWIF showPriceBeforeUserPriceList(p) BEFORE viewPriceUserPriceListDetailPriceListType(d,to)
    ;
    
DESIGN userPriceList {
    param{
        MOVE PROPERTY (showPriceBeforeUserPriceList(p));
    }
}

priceListTypeBeforeOperation 'Вид цены для цены до' = DATA DataPriceListType (PriceList.Operation);
   
showPriceBeforeOperation 'Цена до' = DATA BOOLEAN (PriceList.Operation);
showPriceBeforeUserPriceList(priceList) <- showPriceBeforeOperation(operationUserPriceList(priceList))
    WHEN CHANGED(operationUserPriceList(priceList));
skipConstraintPriceBeforeOperation 'Может быть не задана Цена до' = DATA BOOLEAN (PriceList.Operation);
    
EXTEND FORM operation PROPERTIES(o) showPriceBeforeOperation, skipConstraintPriceBeforeOperation;
DESIGN operation {
    showContainer {
        MOVE PROPERTY(showPriceBeforeOperation(o));
        MOVE PROPERTY(skipConstraintPriceBeforeOperation(o));
    }
}

@defineDocumentInterfaceHeaderTimePrefix(PriceList, fromPriceBefore, ' c (Цена до)');
@deriveDocumentHeaderTimePrefix(UserPriceList, fromPriceBefore);

@defineDocumentInterfaceHeaderTimePrefix(PriceList, toPriceBefore, ' по (Цена до)');
@deriveDocumentHeaderTimeBeforePrefix(UserPriceList, toPriceBefore);

CONSTRAINT showPriceBeforeUserPriceList(p) AND isPostedUserPriceList(p) AND
            ((fromPriceBeforeDateTimeUserPriceList(p) >= fromDateTimeUserPriceList(p) AND fromPriceBeforeDateTimeUserPriceList(p) <= toDateTimeUserPriceList(p)) OR
            (toPriceBeforeDateTimeUserPriceList(p) >= fromDateTimeUserPriceList(p) AND toPriceBeforeDateTimeUserPriceList(p) <= toDateTimeUserPriceList(p))) 
    MESSAGE 'Дата с (Цена до) и Дата по (Цена до)не могут быть в интервале самого прайса.';
    
CONSTRAINT showPriceBeforeUserPriceList(p) AND isPostedUserPriceList(p) AND NOT skipConstraintPriceBeforeOperation(operationUserPriceList(p)) AND 
            (NOT fromPriceBeforeDateTimeUserPriceList(p) OR NOT toPriceBeforeDateTimeUserPriceList(p))
    MESSAGE 'Дата с (Цена до) и Дата по (Цена до) должны быть заданы для прайса';
    
CONSTRAINT showPriceBeforeUserPriceList(userPriceListUserPriceListDetail(d)) AND isPostedUserPriceList(userPriceListUserPriceListDetail(d))
            AND NOT skipConstraintPriceBeforeOperation(operationUserPriceListDetail(d)) AND NOT priceBeforeUserPriceListDetail(d)
    MESSAGE 'Цена до должна быть задана для строки прайса.';
    
EXTEND FORM userPriceList
    PROPERTIES (p) SHOWIF showPriceBeforeUserPriceList(p) fromPriceBeforeDateUserPriceList, fromPriceBeforeTimeUserPriceList, toPriceBeforeDateUserPriceList, toPriceBeforeTimeUserPriceList
;

DESIGN userPriceList{
    midContainer {
        type = CONTAINERV;
        NEW timePriceBeforeContainer{
            caption = 'Период действия (Цена до)';
            type = CONTAINERH;
            MOVE PROPERTY (fromPriceBeforeDateUserPriceList(p));
            MOVE PROPERTY (fromPriceBeforeTimeUserPriceList(p));
            MOVE PROPERTY (toPriceBeforeDateUserPriceList(p));
            MOVE PROPERTY (toPriceBeforeTimeUserPriceList(p));
        }
    }
}

CLASS PriceListBeforeLedger : PriceListLedger;
TABLE priceListBeforeLedger(PriceListBeforeLedger);

needPriceBeforePriceListDetail(d) = priceBeforePriceListDetail(d) AND countBeforeDataPriceListTypesPriceList(priceListPriceListDetail(d))
    AND fromPriceBeforeDateTimePriceList(priceListPriceListDetail(d)) AND toPriceBeforeDateTimePriceList(priceListPriceListDetail(d));

@defineAggregation(priceListDetail, priceListBeforeLedger, needPriceBefore);

inPriceListLedgerLedgerPriceListType(l, t) += inPriceListBeforeDataPriceListType(priceListPriceListDetail(priceListDetailPriceListBeforeLedger(l)), t);

descriptionPriceListLedger(l) += descriptionUserPriceList(priceListPriceListDetail(priceListDetailPriceListBeforeLedger(l))) + ' (цена до)' ;

pricePriceListLedgerLedgerPriceListType(l, t) += priceBeforePriceListDetail(priceListDetailPriceListBeforeLedger(l)) IF inPriceListBeforeDataPriceListType(priceListPriceListDetail(priceListDetailPriceListBeforeLedger(l)), t);

fromDateTimePriceListLedger(l) += fromPriceBeforeDateTimePriceList(priceListPriceListDetail(priceListDetailPriceListBeforeLedger(l)));
toDateTimePriceListLedger(l) += toPriceBeforeDateTimePriceList(priceListPriceListDetail(priceListDetailPriceListBeforeLedger(l)));

isPostedPriceListLedger(l) += isPostedPriceList(priceListPriceListDetail(priceListDetailPriceListBeforeLedger(l)));

skuPriceListLedger(l) += skuPriceListDetail(priceListDetailPriceListBeforeLedger(l));

companyPriceListLedger(l) += companyPriceList(priceListPriceListDetail(priceListDetailPriceListBeforeLedger(l)));

inPriceListLedgerStock(l,st) += inPriceListStock(priceListPriceListDetail(priceListDetailPriceListBeforeLedger(l)),st);

// todo: после запуска у  всех клиентов удалить
isDataBeforeDataPriceListType = DATA BOOLEAN ();
onStarted() += ACTION () {
    IF NOT isDataBeforeDataPriceListType() THEN {
        inUserPriceListBeforeDataPriceListType(p,t) <- TRUE WHERE priceListTypeBeforeUserPriceList(p) == t;    
        changeBeforeDataPriceListTypeOperation(t,o) <- TRUE WHERE priceListTypeBeforeOperation(o) == t;
        isDataBeforeDataPriceListType() <- TRUE;
        apply();
    }    
}

// Расчет цены до для склада и sku
lastBeforePriceListLedgerLedgerPriceListTypeSkuStock 'Цена' (type, sku, stock) =
    GROUP LAST ledger
          BY type, skuPriceListLedgerLedgerPriceListTypeStock(ledger, type, stock), stock
          ORDER fromDateTimePriceListLedgerLedgerPriceListTypeStock(ledger, type, stock), ledger
          WHERE activePriceListLedgerLedgerPriceListTypeStock(ledger, type, stock) AND ledger IS PriceListBeforeLedger;

priceBeforeLedgerPriceListTypeSkuStock 'Цена до' (type, sku, stock) = priceBeforePriceListDetail(lastBeforePriceListLedgerLedgerPriceListTypeSkuStock(type, sku, stock));
