MODULE PriceListCalc;

REQUIRE Integration, PriceListLedger, StockTax;

NAMESPACE PriceList;

CLASS CalcPriceListType 'Расчетный вид цены' : PriceListType;
TABLE calcPriceListType (CalcPriceListType);

@defineExternalizable(calcPriceListType, VARSTRING[100]);
idPriceListType (p) += idCalcPriceListType(p);

nameCalcPriceListType 'Наименование' = DATA VARISTRING[50](CalcPriceListType);
namePriceListType(type) += nameCalcPriceListType(type) IF type IS CalcPriceListType;

basePriceListTypeCalcPriceListType(type) = DATA BasePriceListType (CalcPriceListType);
nameBasePriceListTypeCalcPriceListType 'Базовый вид цены' (type) = nameBasePriceListType(basePriceListTypeCalcPriceListType(type));

ledgerPriceListTypePriceListType(type) += basePriceListTypeCalcPriceListType(type) AS LedgerPriceListType;

includeVATCalcPriceListType 'Цена с НДС' = DATA BOOLEAN (CalcPriceListType);
includeVATPriceListType(type) += includeVATCalcPriceListType(type);

countryCalcPriceListType 'Страна' = DATA Country(CalcPriceListType);
nameCountryCalcPriceListType 'Страна' (t) = nameCountry(countryCalcPriceListType(t));

addVATCalcPriceListType 'Добавлять НДС' (t) = includeVATCalcPriceListType(t) AND NOT includeVATPriceListType(basePriceListTypeCalcPriceListType(t)) PERSISTENT;  

@defineDocumentHeaderCurrency(calcPriceListType);
currencyPriceListType(calcPriceListType) += currencyCalcPriceListType(calcPriceListType);

parentCalcPriceListType = DATA CalcPriceListType (CalcPriceListType);
nameParentCalcPriceListType 'Родительский вид цены' = nameCalcPriceListType(parentCalcPriceListType(t));

// ---------------- Надбавка по классификатору ------------------- //

groupTypeCalcPriceListType = DATA GroupType (CalcPriceListType);
nameGroupTypeCalcPriceListType 'Тип классификатора' (type) = nameGroupType(groupTypeCalcPriceListType(type));

TABLE calcPriceListTypeGroup (CalcPriceListType, Group);
TABLE sessionCalcPriceListTypeGroup (Session, CalcPriceListType, Group);
dataMarkupCalcPriceListTypeGroup 'Надбавка, %' = DATA NUMERIC[8,2] (CalcPriceListType, Group);

TABLE calcPriceListTypeSku (CalcPriceListType, Sku);
TABLE sessionCalcPriceListTypeSku (Session, CalcPriceListType, Sku);
dataMarkupCalcPriceListTypeSku 'Надбавка, %' = DATA NUMERIC[8,2] (CalcPriceListType, Sku);

levelParentMarkupGroup (calcPriceListType, group) = GROUP MIN levelGroupGroup(group, parent) IF dataMarkupCalcPriceListTypeGroup(calcPriceListType, parent)
                                                              BY calcPriceListType, group PERSISTENT;
nearestParentGroup (calcPriceListType, group) = groupGroupLevel(group, levelParentMarkupGroup(calcPriceListType, group));
nearestMarkupCalcPriceListTypeGroup 'Расчетная надбавка, %' (calcPriceListType, group) =
    dataMarkupCalcPriceListTypeGroup(calcPriceListType, nearestParentGroup(calcPriceListType, group)) PERSISTENT;

markupCalcPriceListTypeGroup 'Надбавка, %' (type, group) =
    OVERRIDE nearestMarkupCalcPriceListTypeGroup(type, group), dataMarkupCalcPriceListTypeGroup(type, group) PERSISTENT;
    
extraMarkupCalcPriceListTypeSku = ABSTRACT NUMERIC[8,2] (CalcPriceListType, Sku);  
    
overMarkupCalcPriceListTypeSku 'Надбавка, % (перегруженная)' = OVERRIDE 
    markupCalcPriceListTypeGroup(type, groupGroupTypeSku(groupTypeCalcPriceListType(type), sku)),
    extraMarkupCalcPriceListTypeSku(type, sku),
    dataMarkupCalcPriceListTypeSku(type, sku) PERSISTENT;

markupCalcPriceListTypeSku 'Надбавка, %' (type, sku) = OVERRIDE
    overMarkupCalcPriceListTypeSku(parentCalcPriceListType(type), sku),
    overMarkupCalcPriceListTypeSku(type, sku) PERSISTENT;
    
multiplierCalcPriceListTypeSku (type, sku) = NUMERIC[10,4]((100.0 + markupCalcPriceListTypeSku(type, sku)) / 100.0) PERSISTENT;

VATCalcPriceListTypeSkuDate(type, sku, date) = IF addVATCalcPriceListType(type) THEN (100.0 + valueVATSkuCountryDate(sku, countryCalcPriceListType(type), date)) / 100.0 ELSE 1.0 IF sku IS Sku AND type IS CalcPriceListType AND date IS DATE;


//-- Условие округления
dataRoundConditionCalcPriceListTypeGroup = DATA RoundCondition (CalcPriceListType, Group);
nameDataRoundConditionCalcPriceListTypeGroup 'Условие округления' (type, group) = nameRoundCondition(dataRoundConditionCalcPriceListTypeGroup(type, group));
CONSTRAINT currencyRoundCondition(dataRoundConditionCalcPriceListTypeGroup(type, group)) != currencyPriceListType(type)
           CHECKED BY dataRoundConditionCalcPriceListTypeGroup
           MESSAGE 'Валюта документа должна совпадать с валютой условия округления цены';
           
levelParentRoundConditionCalcPriceListTypeGroup (calcPriceListType, group) = GROUP MIN levelGroupGroup(group, parent) IF dataRoundConditionCalcPriceListTypeGroup(calcPriceListType, parent)
                                                              BY calcPriceListType, group PERSISTENT;
nearestParentRoundConditionCalcPriceListTypeGroup (calcPriceListType, group) = groupGroupLevel(group, levelParentRoundConditionCalcPriceListTypeGroup(calcPriceListType, group));
nearestRoundConditionCalcPriceListTypeGroup  (calcPriceListType, group) =
    dataRoundConditionCalcPriceListTypeGroup(calcPriceListType, nearestParentRoundConditionCalcPriceListTypeGroup(calcPriceListType, group)) PERSISTENT;
    
nameNearestRoundConditionCalcPriceListTypeGroup 'Расчетное условие округления' (type, group) = nameRoundCondition(OVERRIDE roundConditionPriceListType(type) IF group IS Group,
                                                                                                                nearestRoundConditionCalcPriceListTypeGroup(type, group));

roundConditionCalcPriceListTypeGroup 'Условие округления' (type, group) =
    OVERRIDE nearestRoundConditionCalcPriceListTypeGroup(type, group), 
             dataRoundConditionCalcPriceListTypeGroup(type, group) PERSISTENT;
            
roundConditionCalcPriceListTypeSku (type, sku) = OVERRIDE roundConditionPriceListType(type) IF type IS CalcPriceListType AND sku IS Sku,
                                                          roundConditionCalcPriceListTypeGroup(type, groupGroupTypeSku(groupTypeCalcPriceListType(type), sku));            
nameRoundConditionCalcPriceListTypeSku 'Условие округления' (type, sku)= nameRoundCondition(roundConditionCalcPriceListTypeSku(type, sku));    
        
// --------------- Расчет значения цены --------------- //

priceBBasePriceListTypeCalcPriceListTypeSkuStockDateTime(base, type, sku, stock, dateTime) =
    roundPriceRoundCondition(priceBBasePriceListTypeSkuStockDateTime(base, sku, stock, dateTime) * multiplierCalcPriceListTypeSku(type, sku) * VATCalcPriceListTypeSkuDate(type, sku, DATE(dateTime)), roundConditionCalcPriceListTypeSku(type, sku)) COMPLEX;
priceABasePriceListTypeCalcPriceListTypeSkuStockDateTime(base, type, sku, stock, dateTime) =
    roundPriceRoundCondition(priceABasePriceListTypeSkuStockDateTime(base, sku, stock, dateTime) * multiplierCalcPriceListTypeSku(type, sku) * VATCalcPriceListTypeSkuDate(type, sku, DATE(dateTime)), roundConditionCalcPriceListTypeSku(type, sku)) COMPLEX;

priceBCalcPriceListTypeSkuStockDateTime(type, sku, stock, dateTime) =
    priceBBasePriceListTypeCalcPriceListTypeSkuStockDateTime(basePriceListTypeCalcPriceListType(type), type, sku, stock, dateTime) COMPLEX;
priceACalcPriceListTypeSkuStockDateTime(type, sku, stock, dateTime) =
    priceABasePriceListTypeCalcPriceListTypeSkuStockDateTime(basePriceListTypeCalcPriceListType(type), type, sku, stock, dateTime) COMPLEX;

priceBCalcPriceListTypeBatchStockDateTime(type, batch, stock, dateTime) =
    roundPriceRoundCondition(priceBBasePriceListTypeBatchStockDateTime(basePriceListTypeCalcPriceListType(type), batch, stock, dateTime) * multiplierCalcPriceListTypeSku(type, skuBatch(batch)) * VATCalcPriceListTypeSkuDate(type, skuBatch(batch), DATE(dateTime)), roundConditionCalcPriceListTypeSku(type, skuBatch(batch))) COMPLEX;
priceACalcPriceListTypeBatchStockDateTime(type, batch, stock, dateTime) =
    roundPriceRoundCondition(priceABasePriceListTypeBatchStockDateTime(basePriceListTypeCalcPriceListType(type), batch, stock, dateTime) * multiplierCalcPriceListTypeSku(type, skuBatch(batch)) * VATCalcPriceListTypeSkuDate(type, skuBatch(batch), DATE(dateTime)) , roundConditionCalcPriceListTypeSku(type, skuBatch(batch))) COMPLEX;

priceBPriceListTypeSkuStockDateTime(type, sku, stock, dateTime) += priceBCalcPriceListTypeSkuStockDateTime(type, sku, stock, dateTime);
priceAPriceListTypeSkuStockDateTime(type, sku, stock, dateTime) += priceACalcPriceListTypeSkuStockDateTime(type, sku, stock, dateTime);

priceBPriceListTypeBatchStockDateTime(type, batch, stock, dateTime) += priceBCalcPriceListTypeBatchStockDateTime(type, batch, stock, dateTime);
priceAPriceListTypeBatchStockDateTime(type, batch, stock, dateTime) += priceACalcPriceListTypeBatchStockDateTime(type, batch, stock, dateTime);

// ------------------------------------- Формы ---------------------------------- //

backgroundMarkup 'Цвет' (calcPriceListType, group) = RGB(255,160,160) IF dataMarkupCalcPriceListTypeGroup(calcPriceListType, group);

FORM calcPriceListType 'Расчетный вид цен'
    OBJECTS c = CalcPriceListType FIXED PANEL
    PROPERTIES(c) nameCalcPriceListType, idCalcPriceListType SHOWIF showIDs(), includeVATPriceListType, nameCurrencyCalcPriceListType, nameCountryCalcPriceListType, nameBasePriceListTypeCalcPriceListType,
                  nameRoundConditionPriceListType, nameGroupTypeCalcPriceListType, nameParentCalcPriceListType

    TREE treeGroup g=Group PARENT parentGroup
    PROPERTIES READONLY orderGroup(g), nameGroup(g)
    FILTERS groupTypeGroup(g) == groupTypeCalcPriceListType(c)
    ORDER BY orderGroup(g), nameGroup(g)
    FILTERGROUP inactive FILTER 'Активные' activeGroup(g) 'F5' DEFAULT
    PROPERTIES(c, g) dataMarkupCalcPriceListTypeGroup , nearestMarkupCalcPriceListTypeGroup, nameDataRoundConditionCalcPriceListTypeGroup, nameNearestRoundConditionCalcPriceListTypeGroup READONLY 

    OBJECTS s = Sku
    PROPERTIES(s) READONLY nameSku, idBarcodeSku
    FILTERS isParentGroupSku(g, s) OR s IS Sku AND NOT g
    PROPERTIES(c, s) dataMarkupCalcPriceListTypeSku, overMarkupCalcPriceListTypeSku, nameRoundConditionCalcPriceListTypeSku

    EDIT CalcPriceListType OBJECT c
;

DESIGN calcPriceListType {
    MOVE c.box{
        type = CONTAINERH;
        MOVE PROPERTY(nameCurrencyCalcPriceListType(c));
        MOVE PROPERTY(nameRoundConditionPriceListType(c));
    }
    NEW groupContainer {
        fill = 1;
        MOVE PROPERTY(nameGroupTypeCalcPriceListType(c));
        NEW treeContainer{
            fill = 1;
            type = SPLITH;
            MOVE treeGroup.tree.box { caption = 'Группы товаров';}
            MOVE s.box {
                fill = 2;
            }
        }
    }
    MOVE functions.box;
}

FORM calcPriceListTypes 'Расчетный вид цены'
    OBJECTS p = CalcPriceListType
    PROPERTIES(p) READONLY nameCalcPriceListType, nameCurrencyCalcPriceListType, nameRoundConditionPriceListType
    PROPERTIES(p) READONLY includeVATCalcPriceListType

    DIALOG CalcPriceListType OBJECT p
;

addCalcPriceListType 'Добавить расчетную цену' = ACTION ADDFORM CalcPriceListType;
editCalcPriceListType 'Редактировать' = ACTION EDITFORM CalcPriceListType;
editPriceListType(priceListType) += ACTION editCalcPriceListType(priceListType);

overCopyPriceListType (priceListType) += ACTION (priceListType) NEWSESSION {
    IF priceListType IS CalcPriceListType THEN {
        FOR ADDOBJ p = CalcPriceListType DO {
            includeVATCalcPriceListType(p) <- includeVATCalcPriceListType(priceListType);
            countryCalcPriceListType(p) <- countryCalcPriceListType(priceListType);            
            currencyCalcPriceListType(p) <- currencyCalcPriceListType(priceListType);            
            roundConditionPriceListType(p) <- roundConditionPriceListType(priceListType);            
            basePriceListTypeCalcPriceListType(p) <- basePriceListTypeCalcPriceListType(priceListType);
            parentCalcPriceListType(p) <- parentCalcPriceListType(priceListType);
           // pricingBaseCalcPriceListType(p) <- pricingBaseCalcPriceListType(p);
            groupTypeCalcPriceListType(p) <- groupTypeCalcPriceListType(priceListType);
            
            dataMarkupCalcPriceListTypeGroup(p, group) <- dataMarkupCalcPriceListTypeGroup(priceListType, group) WHERE dataMarkupCalcPriceListTypeGroup(priceListType, group);    
            dataRoundConditionCalcPriceListTypeGroup(p, group) <- dataRoundConditionCalcPriceListTypeGroup(priceListType, group) WHERE dataRoundConditionCalcPriceListTypeGroup(priceListType, group);    
            dataMarkupCalcPriceListTypeSku(p, sku) <- dataMarkupCalcPriceListTypeSku(priceListType, sku) WHERE dataMarkupCalcPriceListTypeSku(priceListType, sku);    
            
            FORM calcPriceListType OBJECTS c=p MANAGESESSION DOCKEDMODAL; 
        }
    }
}

EXTEND FORM priceListTypes
    PROPERTIES() TODRAW pt FORCE PANEL addCalcPriceListType
//    PROPERTIES(pt) SHOWIF showIDs() READONLY idCalcPriceListType
;