MODULE PurchaseReturnShipment;

REQUIRE Shipment, PurchaseReturnInvoice, OrderShipment, InvoiceShipment, PriceListLedger, StockDocumentSkuLedger, PurchaseLedger;

PRIORITY Purchase, Operation;

NAMESPACE PurchaseReturn;

//----------------------------------------------- Поставка ---------------------------------------------------//
@defineShipment('Возвраты', ' (закупка-возврат)', customer, supplier, company, company, PurchaseReturn);
@extendFormFilterAccessStock(Shipment, s, shipments, customerStock, company);
@extendFormFilterAccessStock(Shipment, s, shipments, supplierStock, supplier);
@extendFormFilterAccessLegalEntity(Shipment, s, shipments, customer, company);
@extendFormFilterAccessLegalEntity(Shipment, s, shipments, supplier, supplier);

@defineShipmentBatch(customerStock);
@implementDocumentBatch(shipment);

@defineShipmentBatchDialogStock(customerStock, Out);

expiryDate(UserShipmentDetail detail) <- expiryDate(batch(detail)) WHEN CHANGED (batch(detail));

@defineShipmentStockDestination(customerStock, supplierStock);

@defineOrderShipment(' (закупка-возврат)', customerStock);
@defineInvoiceShipment(' (закупка-возврат)', customerStock, company, PurchaseReturn);
@defineInvoiceShipmentAction(' (закупка-возврат)');

@defineInvoiceShipmentBatch();

//----------------------------------------------- Операции -----------------------------------------------------//

@defineDocumentOperationContainer(shipment, s, overName);
operation[Shipment.Shipment](Shipment s)+=operation(s);
@extendFormFilterRoleAccess(shipment, s, shipments);
@defineDocumentOperationConstraint(shipment, 'поставка (закупка-возврат)', PurchaseReturn);

@defineDocumentOperationLegalEntity(userShipment, supplier, 'Поставщик');
@deriveDocumentOperationLegalEntity(userShipment, supplier, userShipment);
@defineDocumentOperationLegalEntity(userShipment, customer, 'Покупатель');
@deriveDocumentOperationLegalEntity(userShipment, customer, userShipment);
@defineDocumentOperationStock(userShipment, supplier, 'Склад поставщика');
@deriveDocumentOperationStock(userShipment, supplier, userShipment);
@defineDocumentOperationStock(userShipment, customer, 'Склад покупателя');
@deriveDocumentOperationStock(userShipment, customer, userShipment);

@defineDocumentOperationRole(userShipment);

@deriveDocumentOperationProperty(UserInvoice, createShipment);

overFillInvoice(UserShipment s, Invoice i) += ACTION {
    ASSIGN operation(s) <- operation(i);
}

operation(InvoiceShipment shipment) += operation(invoice(shipment));

// Добавляем в копирование поставок
overCopy(Shipment s, UserShipment d) += ACTION {
    ASSIGN operation(d) <- operation(s);
}
@defineOperationFilterProperty(shipment, s, shipments, nameFilterShipmentSupplier);
//------------------------------ Ограничение на выбор контрагентов -----------------------------//

CONSTRAINT supplier(UserShipment userShipment) AND NOT isSupplier(supplier(userShipment))
    CHECKED BY supplier[UserShipment] MESSAGE 'Для поставки выбрано в качестве поставщика организация, не являющаяся поставщиком: закупка-возврат';
CONSTRAINT customer(UserShipment userShipment) AND NOT isCompany(customer(userShipment))
    CHECKED BY customer[UserShipment] MESSAGE 'Для поставки выбрано в качестве покупателя организация, не являющаяся компанией: закупка-возврат';
       
CONSTRAINT filterShipmentSupplier() AND NOT isSupplier(filterShipmentSupplier())
    CHECKED BY filterShipmentSupplier[] MESSAGE 'Для фильтра в поставке выбрана в качестве поставщика организация, не являющаяся поставщиком';
CONSTRAINT filterShipmentCustomer() AND NOT isCompany(filterShipmentCustomer())
    CHECKED BY filterShipmentCustomer[] MESSAGE 'Для фильтра в поставке выбрана в качестве покупателя организация, не являющаяся компанией';  
CONSTRAINT filterShipmentCustomerStock() AND NOT isCompany(filterShipmentCustomerStock())
    CHECKED BY filterShipmentCustomerStock[] MESSAGE 'Для фильтра в поставке выбран в качестве склада покупателя склад, который не принадлежит компании';   
        
CONSTRAINT filterShipmentSupplier() AND filterShipmentSupplierStock() AND NOT in(filterShipmentSupplier(), filterShipmentSupplierStock())
    CHECKED BY filterShipmentSupplierStock[] MESSAGE 'Поставщик и склад поставщика в фильтре для поставки не имеют связи';
CONSTRAINT filterShipmentCustomer() AND filterShipmentCustomerStock() AND NOT in(filterShipmentCustomer(), filterShipmentCustomerStock())
    CHECKED BY filterShipmentCustomerStock[] MESSAGE 'Покупатель и склад покупателя в фильтре для поставки не имеют связи';      
//------------------------------ Ввод в упаковках -----------------------------//

@defineDocumentPack(shipment, s);
packQuantity[Shipment.ShipmentDetail](ShipmentDetail detail) += packQuantity(detail);
DESIGN userShipment {
    headerExtraParams {
        NEW headerPack {
            caption = 'Упаковка';
            MOVE PROPERTY(showPack(s));
        }
    }
}

@deriveDocumentOperationProperty(UserShipment, showPack);

@defineOrderShipmentPack();
@defineInvoiceShipmentPack();

//------------------------------ Автоматическое проставление свойств -----------------------------//

@defineDocumentSupplierCustomerStockAccess(UserShipment, supplier, company, userShipment);

//------------------------------ Расширение формы -----------------------------//

EXTEND FORM userShipment

    FILTERGROUP filter
        FILTER 'С остатком ' prevCurrentBalance(ks, s) 'F10'
        FILTER 'В документе ' quantityUserShipmentDetail(ks, s) 'F9'
    FILTERGROUP filter2
        FILTER 'С поступлением ' quantityPurchaseSupplier(supplier(s), ks) 'F8'
//        FILTER 'В прайсе ' 'F7' companyALedgerPriceListTypeSkuStockDateTime(priceListTypeUserShipmentSku(s, ks), ks, customerStockUserShipment(s), dateTimeUserShipment(s)) == supplierUserShipment(s)
;
EXTEND FORM userShipment

    FILTERGROUP filter3
        FILTER 'С остатком ' prevCurrentBalance(b, s) 'F10'
        FILTER 'В документе ' quantityUserShipmentDetail(b, s) 'F9'
    FILTERGROUP filter4
        FILTER 'С поступлением ' quantityPurchaseSupplier(supplier(s), sku(b)) 'F8'
//        FILTER 'В прайсе ' 'F7' companyALedgerPriceListTypeBatchStockDateTime(priceListTypeUserShipmentBatch(s, b), b, customerStockUserShipment(s), dateTimeUserShipment(s)) == supplierUserShipment(s)
;

// Резервы
@extendFormDocumentSkuOrderLedger(userShipment, userShipment, s, customerStock);
@extendFormDocumentSkuOrderLedgerAll(userShipment, userShipment, s);

@extendFormDocumentBatchOrderLedger(userShipment, userShipment, s, customerStock);
@extendFormDocumentBatchOrderLedgerAll(userShipment, userShipment, s);

// --------------------------- Расчет учетной цены для поставки --------------------- //

// Для поставки
@deriveDocumentDetailPriceSystemLedgerPriceListTypeBatch (userShipment, accountPriceListType, sku, customerStock);

// Для накладной
@deriveDocumentDetailPriceSystemLedgerPriceListTypeBatch (userInvoice, accountPriceListType, shipment, , sku, customerStock);
//shipmentPriceUserInvoiceDetail(detail) <- calcShipmentPriceUserInvoiceDetail(detail) (+) extraShipmentPriceUserInvoiceDetail(detail) WHEN
//    (CHANGED(calcShipmentPriceUserInvoiceDetail(detail)) OR CHANGED(extraShipmentPriceUserInvoiceDetail(detail)) OR CHANGED(createShipmentUserInvoiceDetail(detail)))
//        AND createShipmentUserInvoiceDetail(detail);

// ------------------------------- Проведение по товарному отчету ------------------------ //
@implementStockDocumentLedgerOut(Shipment, customerStock);
type(Shipment l) += 'Закупка-возврат' IF l IS Shipment;
sumItem (Shipment ledger) += sumItemShipmentDetail(ledger);
sumContainer (Shipment ledger) += sumContainerShipmentDetail(ledger);

legalEntity(Shipment ledger) += supplier(ledger);  
legalEntityStock(Shipment ledger) += supplierStock(ledger);
  
operation[StockDocumentLedger](Shipment ledger) += operation(ledger);
isReturn(Shipment ledger) += ledger IS Shipment;

edit[StockDocumentLedger](Shipment l) += ACTION edit(l);
close[StockDocumentLedger](Shipment l) += ACTION close(l);

// ------------------------------- Проведение по регистру остатков ------------------------ //
@implementSkuLedgerOutFIFO(ShipmentDetail, sku, customerStock);
quantity[OutFIFOSkuLedger] (ShipmentDetail ledger) += quantity(ledger);
batch[SkuLedger](ShipmentDetail ledger) += batch(ledger);
@implementSkuLedgerOutFIFOBatchBalance(shipmentDetail, customerStock);
sum[OutSkuLedger] (ShipmentDetail ledger) += sum(ledger);

cost(ShipmentDetail detail, Batch batch) += cost[SkuLedger,Batch](detail, batch) IF detail IS ShipmentDetail;
cost(InvoiceDetail ledger, Batch batch) += -cost (ledger, batch); 

edit[SkuLedger](ShipmentDetail d) += ACTION edit(d);

// ------------------------------- Проведение по товарному отчету ------------------------ //

stockDocumentLedger(ShipmentDetail ledger) += shipment(ledger);

//-- Запрет на изменение документа другим пользователем
@defineOperationChangesDocument(shipment, UserShipment, preventChangesDocument, created);

overShowEdit (Shipment i) += showEditDeleteUser(i) AND isOpened(i) AND NOT skipShowEdit(i);
overShowDelete (UserShipment i) += showEditDeleteUser(i) AND isUserOpened(i) AND NOT skipShowDelete(i); 

// --------------- Проведение по регистру закупок ------------- //
shipmentQuantity[PurchaseLedger] (InvoiceDetail ledger) += -shipmentQuantity(ledger);


NAVIGATOR {
    purchaseStockNavigator {
        ADD shipments;
    }
}
CONSTRAINT isPosted(ShipmentDetail d) AND isShipmentPrice(operation(d)) AND NOT price(d)
    MESSAGE 'Для документа (закупка-возврат) должна быть задана учетная цена';
    
shipmentDateTime(InvoiceDetail l) += shipmentDateTime(l);