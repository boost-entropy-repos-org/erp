MODULE PurchaseInvoice;

REQUIRE Utils, PurchaseOrder, OrderInvoice, PurchaseOperation, PriceListLedger;

NAMESPACE Purchase;

//----------------------------------------------- Накладная ---------------------------------------------------//
@defineInvoice(' (закупка)', customer, supplier, company, , Purchase);

idCustomerStockInvoice(invoice) = idStock(customerStockInvoice(invoice));
idSupplierStockInvoice(invoice) = idStock(supplierStockInvoice(invoice));
//
//numberByTime(i) = [=GROUP LAST 1 BY supplierInvoice(i) ORDER timeInvoice(i)](supplierInvoice(i)); 
//
@extendFormFilterAccessStock(Invoice, i, invoices, customerStock, company);
@extendFormFilterAccessStock(Invoice, i, invoices, supplierStock, supplier);
@extendFormFilterAccessLegalEntity(Invoice, i, invoices, customer, company);
@extendFormFilterAccessLegalEntity(Invoice, i, invoices, supplier, supplier);

Invoice.inInvoice(i) += i IS Invoice;

// Добавляем партии
@defineInvoiceBatch(customer, , Purchase, ' (закупка)');
@defineInvoiceBatchDialog();

@defineInvoiceDestination(supplier, customer);
@defineInvoiceStockDestination(supplierStock, customerStock);

// вторая валюта
@defineInvoiceHomeCurrency();
                                              
// страна
countryInvoiceDetail(invoiceDetail) = countryStock(customerStockInvoice(invoiceInvoiceDetail(invoiceDetail)));
countryUserInvoiceDetail(invoiceDetail) = countryStock(customerStockUserInvoice(userInvoiceUserInvoiceDetail(invoiceDetail)));

//----------------------------------------------- Операции -----------------------------------------------------//

@defineDocumentOperationContainer(invoice, i);
@extendFormFilterRoleAccess(invoice, i, invoices);
@defineDocumentOperationConstraint(invoice, 'накладная (закупка)', Purchase);

@defineDocumentOperationPriceListType(userInvoice, 'накладной (закупка)', userInvoice);

@defineDocumentOperationLegalEntity(userInvoice, supplier, 'Поставщик');
@deriveDocumentOperationLegalEntity(userInvoice, supplier, userInvoice);
@defineDocumentOperationLegalEntity(userInvoice, customer, 'Покупатель');
@deriveDocumentOperationLegalEntity(userInvoice, customer, userInvoice);
@defineDocumentOperationStock(userInvoice, supplier, 'Склад поставщика');
@deriveDocumentOperationStock(userInvoice, supplier, userInvoice);
@defineDocumentOperationStock(userInvoice, customer, 'Склад покупателя');
@deriveDocumentOperationStock(userInvoice, customer, userInvoice);

@defineDocumentOperationRoleOver(userInvoice, purchase);
        
@defineOperationProperty(isHomeCurrency, 'Конвертация', commonContainer);
@deriveDocumentOperationProperty(UserInvoice, isHomeCurrency);

typeExchangeOperation = DATA TypeExchange (Operation);
nameTypeExchangeOperation 'Тип обмена' (operation) = nameTypeExchange(typeExchangeOperation(operation));

EXTEND FORM operation
     PROPERTIES(o) nameTypeExchangeOperation AFTER isHomeCurrencyOperation(o)
 ;
DESIGN operation {
    commonContainer {
        MOVE PROPERTY(nameTypeExchangeOperation(o));
    }
}
    
@deriveDocumentOperationProperty(UserInvoice, typeExchange);

Invoice.operationInvoice(o) += operationInvoice(o);
// Добавляем в копирование инвойсов
overCopyInvoice(s, d) += ACTION(s, d) {
    ASSIGN operationUserInvoice(d) <- operationInvoice(s);
}

@defineOperationFilterProperty(invoice, i, invoices, nameFilterInvoiceSupplier);
// -------------------------------------------- Инвойс на основе заказа -------------------------------------- //

notFillPriceInvoiceOrderOperation 'Не использовать цены в накладной из заказа' = DATA BOOLEAN (Operation);
EXTEND FORM operation
    PROPERTIES(o) notFillPriceInvoiceOrderOperation
;

DESIGN operation {
    createContainer {
        MOVE PROPERTY(notFillPriceInvoiceOrderOperation(o));
    }
}

@defineOrderInvoice(' (закупка)', customer);

// --------------------------- Себестоимость ---------------------------------- //

extraCostPriceInvoiceDetail = ABSTRACT NUMERIC[16,4] (InvoiceDetail) PERSISTENT;
extraCostPriceUserInvoiceDetail = ABSTRACT NUMERIC[16,4] (UserInvoiceDetail) PERSISTENT;
extraCostPriceInvoiceDetail (detail) += extraCostPriceUserInvoiceDetail(detail);

customCostPriceInvoiceDetail = ABSTRACT NUMERIC[20,8](InvoiceDetail) PERSISTENT;
customCostPriceUserInvoiceDetail = ABSTRACT NUMERIC[20,8](UserInvoiceDetail) PERSISTENT;
customCostPriceInvoiceDetail(detail) += customCostPriceUserInvoiceDetail(detail);

certificateCostPriceInvoiceDetail = ABSTRACT NUMERIC[16,4](InvoiceDetail) PERSISTENT;
certificateCostPriceUserInvoiceDetail = ABSTRACT NUMERIC[16,4](UserInvoiceDetail) PERSISTENT;
certificateCostPriceInvoiceDetail(detail) += certificateCostPriceUserInvoiceDetail(detail);

incomePriceInvoiceDetail (detail) = IF isHomeCurrencyInvoice(invoiceInvoiceDetail(detail)) THEN
                                       homePriceInvoiceDetail(detail)
                                    ELSE priceInvoiceDetail(detail);
incomeSumInvoice(invoice) = GROUP SUM incomePriceInvoiceDetail(detail) * quantityInvoiceDetail(detail) BY invoiceInvoiceDetail(detail);

incomePriceUserInvoiceDetail (detail) = IF isHomeCurrencyUserInvoice(userInvoiceUserInvoiceDetail(detail)) THEN
                                           homePriceUserInvoiceDetail(detail)
                                        ELSE priceUserInvoiceDetail(detail);
incomeSumUserInvoice(invoice) = GROUP SUM incomePriceUserInvoiceDetail(detail) * quantityUserInvoiceDetail(detail) BY userInvoiceUserInvoiceDetail(detail);

// todo : переделать на обычный +, чтобы incomePriceInvoiceDetail суммировался с остальными через OVERRIDE, 0
costPriceInvoiceDetail(detail) = NUMERIC[14,2] (incomePriceInvoiceDetail(detail) (+) extraCostPriceInvoiceDetail(detail) (+)
                                                customCostPriceInvoiceDetail(detail) (+) certificateCostPriceInvoiceDetail(detail)) IF incomePriceInvoiceDetail(detail);

costPriceUserInvoiceDetail(detail) = NUMERIC[14,2] (incomePriceUserInvoiceDetail(detail) (+) extraCostPriceUserInvoiceDetail(detail) (+)
                                                    customCostPriceUserInvoiceDetail(detail) (+) certificateCostPriceUserInvoiceDetail(detail)) IF incomePriceUserInvoiceDetail(detail);

// -------------------------------------- Формирование задолженности ---------------------------------------------------

CONSTRAINT supplierUserInvoice(userInvoice) AND NOT isSupplierLegalEntity(supplierUserInvoice(userInvoice))
    CHECKED BY supplierUserInvoice MESSAGE 'Для накладной выбрана в качестве поставщика организация, не являющаяся поставщиком';
CONSTRAINT customerUserInvoice(userInvoice) AND NOT isCompanyLegalEntity(customerUserInvoice(userInvoice))
    CHECKED BY customerUserInvoice MESSAGE 'Для накладной выбрана в качестве покупателя организация, не являющаяся компанией';

CONSTRAINT filterInvoiceSupplier() AND NOT isSupplierLegalEntity(filterInvoiceSupplier())
    CHECKED BY filterInvoiceSupplier MESSAGE 'Для фильтра в накладной выбрана в качестве поставщика организация, не являющаяся поставщиком';
CONSTRAINT filterInvoiceCustomer() AND NOT isCompanyLegalEntity(filterInvoiceCustomer())
    CHECKED BY filterInvoiceCustomer MESSAGE 'Для фильтра в накладной выбрана в качестве покупателя организация, не являющаяся компанией';      
CONSTRAINT filterInvoiceCustomerStock() AND NOT isCompanyStock(filterInvoiceCustomerStock())
    CHECKED BY filterInvoiceCustomerStock MESSAGE 'Для фильтра в накладной выбран в качестве склада покупателя склад, который не принадлежит компании';          
    
CONSTRAINT filterInvoiceSupplier() AND filterInvoiceSupplierStock() AND NOT inLegalEntityStock(filterInvoiceSupplier(), filterInvoiceSupplierStock())
    CHECKED BY filterInvoiceSupplierStock MESSAGE 'Поставщик и склад поставщика в фильтре для накладной не имеют связи';
CONSTRAINT filterInvoiceCustomer() AND filterInvoiceCustomerStock() AND NOT inLegalEntityStock(filterInvoiceCustomer(), filterInvoiceCustomerStock())
    CHECKED BY filterInvoiceCustomerStock MESSAGE 'Покупатель и склад покупателя в фильтре для накладной не имеют связи';    

//------------------------------ Автоматическое проставление свойств -----------------------------//

@defineDocumentSupplierCustomerStockAccess(UserInvoice, supplier, company, userInvoice);

//------------------------------ Ввод в упаковках -----------------------------//

@defineDocumentPack(invoice, i);
Invoice.packQuantityInvoiceDetail(detail) += packQuantityInvoiceDetail(detail);
DESIGN userInvoice {
    headerExtraParams {
        NEW headerPack {
            caption = 'Упаковка';
            MOVE PROPERTY(showPackUserInvoice(i));
        }
    }
}

@defineOrderInvoicePack(showPack);

@defineDocumentPackSku(userInvoice, sku, customerStock);
@extendFormDocumentPackSku(userInvoice, userInvoice, i);

//overChangeQuantityValueSkuUserInvoiceDetail(detail) += ACTION (detail) {
//    IF  packBarcodeSku(skuUserInvoiceDetail(detail)) THEN {
//        ASSIGN packQuantityUserInvoiceDetail(detail) <- quantityUserInvoiceDetail(detail)/amountPackUserInvoiceDetail(detail);
//    }
//}

// -- Операция
@deriveDocumentOperationProperty(UserInvoice, showPack);

//------------------------------ Расширение формы -----------------------------//

EXTEND FORM userInvoice

    FILTERGROUP filter
        FILTER 'С остатком ' prevCurrentBalanceSkuUserInvoice(ks, i) 'F10'
        FILTER 'В документе ' quantityUserInvoiceDetailSkuUserInvoice(ks, i) 'F9'
    FILTERGROUP filter2
        FILTER 'С поступлением ' quantityPurchaseSupplierSku(supplierUserInvoice(i), ks) 'F8'
        FILTER 'В прайсе ' priceALedgerPriceListTypeSkuStockCompanyDateTime(priceListTypeUserInvoiceSku(i, ks), 
                                                                                 ks, 
                                                                                 customerStockUserInvoice(i),
                                                                                 supplierUserInvoice(i),
                                                                                 dateTimeUserInvoice(i)) 'F7'
;
EXTEND FORM userInvoice

    FILTERGROUP filter3
        FILTER 'С остатком ' prevCurrentBalanceBatchUserInvoice(b, i) 'F10' DEFAULT
        FILTER 'В документе ' quantityUserInvoiceDetailBatchUserInvoice(b, i) 'F9'
        
    FILTERGROUP filter4
        FILTER 'С поступлением ' quantityPurchaseSupplierSku(supplierUserInvoice(i), skuBatch(b)) 'F8'
        FILTER 'В прайсе ' companyALedgerPriceListTypeBatchStockDateTime(priceListTypeUserInvoiceBatch(i, b), 
                                                                              b, 
                                                                              customerStockUserInvoice(i), 
                                                                              dateTimeUserInvoice(i)) == supplierUserInvoice(i) 'F7'
;

// Резервы
@extendFormDocumentSkuOrderLedger(userInvoice, userInvoice, i, customerStock);
@extendFormDocumentSkuOrderLedgerAll(userInvoice, userInvoice, i);

@extendFormDocumentBatchOrderLedger(userInvoice, userInvoice, i, customerStock);
@extendFormDocumentBatchOrderLedgerAll(userInvoice, userInvoice, i);

// --------------- Заполнение кода партии ----------------- //

idBatchInvoiceDetail 'Код партии' = ABSTRACT VARSTRING[100] (InvoiceDetail) MINCHARWIDTH 10 PREFCHARWIDTH 15;
idBatchUserInvoiceDetail 'Код партии' = DATA VARSTRING[100] (UserInvoiceDetail) MINCHARWIDTH 10 PREFCHARWIDTH 15;
idBatchInvoiceDetail(detail) += idBatchUserInvoiceDetail(detail);

@defineMovementIdBatch(invoiceDetail, batch, customerStock);
@defineBalancesIdBatch(invoiceDetail, batch);
@defineMovementIdBatch(userInvoiceDetail, batch, customerStock);
@defineBalancesIdBatch(userInvoiceDetail, batch);

backgroundBatchInvoiceDetail 'Цвет' (detail) = RGB(204, 204, 204) IF batchInvoiceDetail(detail);

EXTEND FORM userInvoice
    PROPERTIES(d) BACKGROUND backgroundBatchInvoiceDetail(d) READONLYIF batchUserInvoiceDetail(d) SHOWIF showIDs()
                  idBatchUserInvoiceDetail AFTER nameBatchUserInvoiceDetail(d)
;
EXTEND FORM invoices
    PROPERTIES(d) READONLY BACKGROUND backgroundBatchInvoiceDetail(d) SHOWIF showIDs()
                  idBatchInvoiceDetail AFTER nameBatchInvoiceDetail(d)
;

// -------------------------------- Наименования для документов --------------------------- //

documentNameSkuInvoiceDetail 'Наименование для документов' = ABSTRACT VARISTRING[255] (InvoiceDetail) MINCHARWIDTH 30 PREFCHARWIDTH 60;
documentNameSkuUserInvoiceDetail 'Наименование для документов' = DATA VARISTRING[255] (UserInvoiceDetail) MINCHARWIDTH 30 PREFCHARWIDTH 60;
documentNameSkuInvoiceDetail(detail) += documentNameSkuUserInvoiceDetail(detail);

EXTEND FORM userInvoice
    PROPERTIES(d) documentNameSkuUserInvoiceDetail AFTER nameSkuUserInvoiceDetail(d) SHOWIF useDocumentNameSku()
;
EXTEND FORM invoices
    PROPERTIES(d) READONLY documentNameSkuInvoiceDetail AFTER nameSkuInvoiceDetail(d) SHOWIF useDocumentNameSku()
;

// --------------- Проведение по регистру закупок ------------- //

@implementPurchaseLedger(Invoice, sku, customerStock);
supplierPurchaseLedger (ledger) += supplierInvoiceDetail(ledger);
supplierStockPurchaseLedger (ledger) += supplierStockInvoiceDetail(ledger);
quantityPurchaseLedger (ledger) += quantityInvoiceDetail(ledger);
VATPurchaseLedger (ledger) += VATInvoiceDetail(ledger);
sumPurchaseLedger (ledger) += invoiceSumInvoiceDetail(ledger);
pricePurchaseLedger (ledger) += priceInvoiceDetail(ledger);
currencyPurchaseLedger(ledger) += currencyInvoiceDetail(ledger);
skipPurchaseLedger (ledger) += skipPurchaseLedgerOperation(operationInvoiceDetail(ledger));

// --------------- Проведение по регистру цен ------------- //

EXTEND CLASS InvoiceDetail : PriceListLedger;

fromDateTimePriceListLedger (ledger) += dateTimeInvoiceDetail(ledger);

isPostedPriceListLedger(ledger) += isPostedInvoiceDetail(ledger);

skuPriceListLedger (ledger) += skuInvoiceDetail(ledger);

descriptionPriceListLedger (ledger) += descriptionInvoiceDetail(ledger);

companyPriceListLedger (ledger) += supplierInvoiceDetail(ledger);

inPriceListLedgerStock (ledger, stock) += customerStockInvoiceDetail(ledger) == stock;

editPriceListLedger(d) += ACTION editInvoiceDetail(d);

EXTEND CLASS SystemLedgerPriceListType { purchaseInvoiceStockPriceListType 'Закупки (последняя по складу)' }
batchLedgerPriceListTypeStock (type, stock) += WHEN type == SystemLedgerPriceListType.purchaseInvoiceStockPriceListType AND isCompanyStock(stock)
                                               THEN TRUE; //priceBatchLedgerStock(stock); для закупки последняя по складу, всегда свои цены для складов
inPriceListLedgerSystemLedgerPriceListType (ledger, type) += WHEN priceInvoiceDetail(ledger) AND type == SystemLedgerPriceListType.purchaseInvoiceStockPriceListType THEN TRUE;
pricePriceListLedgerSystemLedgerPriceListType (ledger, type) += WHEN priceInvoiceDetail(ledger) AND type == SystemLedgerPriceListType.purchaseInvoiceStockPriceListType THEN priceInvoiceDetail(ledger);
differentOrganizationsLedgerPriceListType(type) += WHEN type == SystemLedgerPriceListType.purchaseInvoiceStockPriceListType THEN TRUE;  

//Учетные цены и суммы для партий
purchaseInvoiceStockPriceBBatchStockDate 'Цена поставщика (на утро)' (batch, stock, date) =
    prevPriceBPriceListTypeBatchStockDateTime(SystemLedgerPriceListType.purchaseInvoiceStockPriceListType, batch, stock, toDateTime(date));
purchaseInvoiceStockPriceABatchStockDate 'Цена  поставщика (на вечер)' (batch, stock, date) =
    prevPriceAPriceListTypeBatchStockDateTime(SystemLedgerPriceListType.purchaseInvoiceStockPriceListType, batch, stock, toDateTime(sumDate(date,1)));

purchaseInvoiceStockSumBBatchStockDate 'Сумма поставщика (на утро)' (batch, stock, date) =
    balanceBBatchStockDate(batch, stock, date) * purchaseInvoiceStockPriceBBatchStockDate(batch, stock, date);
purchaseInvoiceStockSumABatchStockDate 'Сумма поставщика (на вечер)' (batch, stock, date) =
    balanceABatchStockDate(batch, stock, date) * purchaseInvoiceStockPriceABatchStockDate(batch, stock, date);

purchaseInvoiceStockSumBBatchesStockDate 'Сумма поставщика (на утро)' (stock, date) =
    GROUP SUM purchaseInvoiceStockSumBBatchStockDate(batch, stock, date)
    BY stock, date;
purchaseInvoiceStockSumABatchesStockDate 'Сумма поставщика (на вечер)' (stock, date) =
    GROUP SUM purchaseInvoiceStockSumABatchStockDate(batch, stock, date)
    BY stock, date;

purchaseInvoiceStockSumBSkuGroupBatchStockDate 'Сумма поставщика (на утро)' (group, stock, date) =
    GROUP SUM purchaseInvoiceStockSumBBatchStockDate(batch, stock, date)
    BY groupGroupTypeSku(groupType, skuBatch(batch)), stock, date;
purchaseInvoiceStockSumRecBSkuGroupBatchStockDate 'Сумма поставщика (на утро)' (group, stock, date) =
    GROUP SUM purchaseInvoiceStockSumBBatchStockDate(batch, stock, date) IF isParentGroupBatch(group, batch)
    BY group, stock, date;

purchaseInvoiceStockSumASkuGroupBatchStockDate 'Сумма поставщика (на вечер)' (group, stock, date) =
    GROUP SUM purchaseInvoiceStockSumABatchStockDate(batch, stock, date)
    BY groupGroupTypeSku(groupType, skuBatch(batch)), stock, date;
purchaseInvoiceStockSumRecASkuGroupBatchStockDate 'Сумма поставщика на (вечер)' (group, stock, date) =
    GROUP SUM purchaseInvoiceStockSumABatchStockDate(batch, stock, date) IF isParentGroupBatch(group, batch)
    BY group, stock, date;

// ----------------- Текущие ---------------------- //

currentPurchaseInvoiceStockPriceBatchStock 'Цена поставщика' (batch, stock) =
    prevPriceAPriceListTypeBatchStockDateTime(SystemLedgerPriceListType.purchaseInvoiceStockPriceListType, batch, stock, currentDateTime());
currentPurchaseInvoiceStockSumBatchStock 'Сумма поставщика' (batch, stock) =
    currentBalanceBatchStock(batch, stock) * currentPurchaseInvoiceStockPriceBatchStock(batch, stock);

purchaseInvoiceStockPriceBatchStockDateTime 'Цена поставщика' (batch, stock, dateTime) =
    prevPriceAPriceListTypeBatchStockDateTime(SystemLedgerPriceListType.purchaseInvoiceStockPriceListType, batch, stock, dateTime);
    
purchaseInvoiceStockPriceBBatchStockDateTime 'Цена поставщика' (batch, stock, dateTime) =
    prevPriceBPriceListTypeBatchStockDateTime(SystemLedgerPriceListType.purchaseInvoiceStockPriceListType, batch, stock, dateTime);    
purchaseInvoiceStockSumBBatchStockDateTime 'Сумма поставщика' (batch, stock, dateTime) =
    balanceBBatchStockDateTime(batch, stock, dateTime) * purchaseInvoiceStockPriceBBatchStockDateTime(batch, stock, dateTime);

purchaseInvoiceStockSumBSkuGroupBatchStockDateTime 'Сумма поставщика (на утро)' (group, stock, dateTime) =
    GROUP SUM purchaseInvoiceStockSumBBatchStockDateTime(batch, stock, dateTime)
    BY groupGroupTypeSku(groupType, skuBatch(batch)), stock, dateTime;
purchaseInvoiceStockSumRecBSkuGroupBatchStockDateTime 'Сумма поставщика (на утро)' (group, stock, dateTime) =
    GROUP SUM purchaseInvoiceStockSumBBatchStockDateTime(batch, stock, dateTime) IF isParentGroupBatch(group, batch)
    BY group, stock, dateTime;

// Добавляем на форму остаток до
balanceBUserInvoiceDetail 'Остаток (до)' (d) = prevBalanceBSkuStockDateTime(skuUserInvoiceDetail(d), customerStockUserInvoiceDetail(d), dateTimeUserInvoiceDetail(d));
EXTEND FORM userInvoice
    PROPERTIES(d) READONLY balanceBUserInvoiceDetail 
;
    
//-- Курс обмена
EXTEND CLASS SystemLedgerPriceListType { rateExchangeStockPriceListType 'Курс обмена (последний по складу)' }
batchLedgerPriceListTypeStock (type, stock) += WHEN type == SystemLedgerPriceListType.rateExchangeStockPriceListType AND isCompanyStock(stock)
                                               THEN priceBatchLedgerStock(stock);
inPriceListLedgerSystemLedgerPriceListType (ledger, type) += WHEN isHomeCurrencyInvoiceDetail(ledger) AND type == SystemLedgerPriceListType.rateExchangeStockPriceListType THEN TRUE;
pricePriceListLedgerSystemLedgerPriceListType (ledger, type) += WHEN isHomeCurrencyInvoiceDetail(ledger) AND type == SystemLedgerPriceListType.rateExchangeStockPriceListType THEN NUMERIC[14,2](rateExchangeInvoiceDetail(ledger));

NAVIGATOR {
    purchasePurchaseNavigator {
        ADD invoices;
    }
}

//-- Запрет на изменение документа другим пользователем
@defineOperationChangesDocument(invoice, UserInvoice, preventChangesDocument, created);

overShowEditInvoice (i) += showEditDeleteUserInvoice(i) AND isOpenedInvoice(i) AND NOT skipShowEditInvoice(i);
overShowDeleteInvoice (i) += showEditDeleteUserInvoice(i) AND isUserOpenedInvoice(i) AND NOT skipShowDeleteInvoice(i); 

overPreventCloseUserInvoice (i) += preventCloseDocumentUserOperation(currentUser(), operationUserInvoice(i));

dateBanBarcodeStock 'Дата запрета приемки накладных без штрихкодов'  = DATA DATE (Stock); 
dateBanValueVATStock 'Дата запрета приемки накладных без ставки НДС'  = DATA DATE (Stock); 

EXTEND FORM options
    PROPERTIES(s) dateBanBarcodeStock, dateBanValueVATStock      
;

CONSTRAINT  isPostedInvoiceDetail(d) AND isItemSku(skuInvoiceDetail(d)) AND 
    dateInvoiceDetail(d) >= dateBanValueVATStock(customerStockInvoiceDetail(d)) AND NOT valueVATInvoiceDetail(d)
        MESSAGE 'Для строки накладной (закупка) должна быть задана ставка входного НДС';   


banBarcodeInvoiceDetail(d) = ABSTRACT BOOLEAN (InvoiceDetail);
CONSTRAINT  isPostedInvoiceDetail(d) AND isItemSku(skuInvoiceDetail(d)) AND NOT banBarcodeInvoiceDetail(d) AND
    dateInvoiceDetail(d) >= dateBanBarcodeStock(customerStockInvoiceDetail(d)) AND NOT idBarcodeSkuInvoiceDetail(d)
        MESSAGE 'Для строки накладной (закупка) обязан быть задан штрихкод';   
                
CONSTRAINT  isPostedUserInvoice(i) AND isContractOperation(operationUserInvoice(i)) AND NOT contractSkuInvoice(i) 
    MESSAGE 'Для накладной (закупка) обязан быть задан договор';   
CONSTRAINT  isPostedUserInvoiceDetail(d) AND isPriceOperation(operationUserInvoiceDetail(d)) AND NOT priceUserInvoiceDetail(d) 
    MESSAGE 'Для строки накладная (закупка) должна быть задана цена'; 
    
CONSTRAINT isPostedUserInvoiceDetail(d) AND isPurchaseBatchOperation(operationUserInvoiceDetail(d)) AND skuUserInvoiceDetail(d) AND NOT batchUserInvoiceDetail(d) 
    MESSAGE 'Для строки накладной (закупка) должна быть задана партия'; 
    
CONSTRAINT isPostedInvoice(i) AND isCharLengthOperation(operationInvoice(i)) AND NOT (charLength(numberInvoice(i)) == 7 AND onlyDigits(numberInvoice(i)) == 1)
    MESSAGE 'У накладной (закупка) номер должен состоять из семи цифр';