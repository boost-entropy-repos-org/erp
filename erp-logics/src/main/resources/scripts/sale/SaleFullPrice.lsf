MODULE SaleFullPrice;

REQUIRE SaleInvoice, PriceList;

NAMESPACE Sale;
    

@defineDocumentInterfaceDetailPricePrefix (order, full, ' (полная)');

percDiscount '% скидки' = ABSTRACT NUMERIC[8,4] (Order);
percDiscount '% скидки' = DATA NUMERIC[8,4] (UserOrder) IN documentPrm;
percDiscount(UserOrder o) += percDiscount(o);

percDiscount '% скидки' = ABSTRACT NUMERIC[8,4] (OrderDetail);
dataPercDiscount '% скидки' = DATA NUMERIC[8,4] (UserOrderDetail);
percDiscount '% скидки' (UserOrderDetail d) = OVERRIDE dataPercDiscount(d), percDiscount(userOrder(d)) IF isItem(sku(d));
percDiscount(UserOrderDetail d) += percDiscount(d);

prevList (PriceListType t, UserOrderDetail d) += WHEN t IS PriceListType AND isItem(sku(d)) THEN
                    round2(NUMERIC[16,4](prevPriceB(t, sku(d), priceStock(d), dateTime(d))));

recalculateDiscountPrice(UserOrderDetail d) = {
    price(d) <- round2(NUMERIC[16,4](fullPrice(d) * (100.0 (-) percDiscount (d)) / 100.0));
    invoicePrice(d) <- round2(price (d) * (100 + calcValueVAT(d)) / 100);
}

// заполнение полной цены 
WHEN LOCAL FORMS userOrder GOAFTER valueVAT[UserOrderDetail] 
        (((CHANGED(priceStock(UserOrderDetail d)) OR CHANGED(dateTime(d))) AND NOT isPosted(d)) OR
         (CHANGED(priceListType(d)) OR CHANGED(agreement(d)) OR CHANGED(sku(d))))
         AND NOT CHANGED(fullPrice(d)) AND PriceListType pt == priceListType(d) AND isItem(sku(d)) 
         NOINLINE (pt) DO {
    fullPrice(d) <- round2(prevPriceB((OVERRIDE basePriceListType(pt), pt), sku(d), priceStock(d), dateTime(d)));    
}

// при изменении полной цены пересчитывается цена 
WHEN LOCAL FORMS userOrder GOAFTER valueVAT[UserOrderDetail] 
        (CHANGED(fullPrice(UserOrderDetail d)))
         AND NOT CHANGED(percDiscount(d)) 
         AND isItem(sku(d)) DO {
    recalculateDiscountPrice(d);
}

// заполнение % скидки из соглашения
WHEN LOCAL FORMS userOrder CHANGED(agreement(UserOrder o)) AND NOT CHANGED(percDiscount(o)) AND CalcPriceListType pt == priceListType(agreement(o)) DO {
    percDiscount(o) <- -nearestMarkup(pt, itemGroup('all'));
}
WHEN LOCAL FORMS userOrder GOAFTER valueVAT[UserOrderDetail]  
        (CHANGED(sku(UserOrderDetail d)) OR CHANGED(agreement(d))) AND isItem(sku(d)) 
        AND NOT CHANGED(dataPercDiscount(d)) 
        AND CalcPriceListType pt == priceListType(d) AND isItem(sku(d)) NOINLINE (pt) DO {
    dataPercDiscount(d) <- -dataMarkup(pt,sku(d)); 
}

// при изменении % скидки пересчитывается цена 
WHEN LOCAL FORMS userOrder GOAFTER fullPrice[UserOrderDetail] 
        (CHANGED(percDiscount(UserOrderDetail d)))
         AND NOT CHANGED(price(d)) 
         AND fullPrice(d) AND isItem(sku(d)) DO {
    recalculateDiscountPrice(d);
}

// при изменении цены меняется % скидки
overChangePrice(UserOrderDetail d) += {
    IF fullPrice(d) AND isItem(sku(d)) THEN {
        dataPercDiscount(d) <- NUMERIC[8,4](round2((1.0 - (price(d)/fullPrice(d)))*100.0));     
    }   
}
WHEN LOCAL FORMS userOrder GOAFTER price[UserOrderDetail] (CHANGED(price(UserOrderDetail d)))  AND 
                             fullPrice(d) AND isItem(sku(d)) AND
                             NOT CHANGED(percDiscount(d)) AND NOT CHANGED(fullPrice(d))DO {
    dataPercDiscount(d) <- NUMERIC[8,4](round2((1.0 - (price(d)/fullPrice(d)))*100.0));
}

recalculateFullPriceUserOrderDetail 'Пересчитать цены'() = {
    FOR PriceListType pt == priceListType(UserOrderDetail d) AND isItem(sku(d)) AND [= FILTER userOrder.d](d) NOINLINE (pt) DO {
        fullPrice(d) <- round2(prevPriceB((OVERRIDE basePriceListType(pt),pt), sku(d), priceStock(d), dateTime(d)));    
    }
} ASON CONTEXTMENU fullPrice[UserOrderDetail];

@defineOption(readonlySaleDiscount, 'Запретить редактирование % скидки в строках', sale);

EXTEND FORM userOrder
    PROPERTIES (o) percDiscount 
    PROPERTIES (d) BEFORE  price(d) fullPrice, percDiscount READONLYIF readonlySaleDiscount()
;

EXTEND FORM orders
    PROPERTIES (d) READONLY BEFORE  price(d) fullPrice, percDiscount
;

skipSetAgreement(UserOrder o) += priceListType(agreement(o)) IS CalcPriceListType;

overCopy (UserOrder o, UserOrder order) += {
    percDiscount(order) <- percDiscount(o);  
} 

// только для копирования строки, при копировании документа заполняется стандартными значениями
overCopy[UserOrderDetail, UserOrderDetail](UserOrderDetail d, UserOrderDetail detail) += {
    fullPrice(d) <- fullPrice(detail);  
    dataPercDiscount(d) <- dataPercDiscount(detail);  
} 

// В накладную копируется всё из заказа. Cоглашение в заказе и накладной должно совпадать.
@defineDocumentInterfaceDetailPricePrefix (invoice, full, ' (полная)');

percDiscount '% скидки' = ABSTRACT NUMERIC[8,4] (Invoice);
percDiscount '% скидки' = DATA NUMERIC[8,4] (UserInvoice) IN documentPrm;
percDiscount(UserInvoice o) += percDiscount(o);

percDiscount '% скидки' = ABSTRACT NUMERIC[8,4] (InvoiceDetail);
dataPercDiscount '% скидки' = DATA NUMERIC[8,4] (UserInvoiceDetail);
percDiscount '% скидки' (UserInvoiceDetail d) = OVERRIDE dataPercDiscount(d), percDiscount(userInvoice(d)) IF isItem(sku(d));
percDiscount(UserInvoiceDetail d) += percDiscount(d);

prevList (PriceListType t, UserInvoiceDetail d) += WHEN t IS PriceListType AND isItem(sku(d)) AND NOT orderDetail(d) THEN
                    round2(NUMERIC[16,4](prevPriceB(t, sku(d), supplierStock(d), dateTime(d))));

recalculateDiscountPrice(UserInvoiceDetail d) = {
    price(d) <- round2(NUMERIC[16,4](fullPrice(d) * (100.0 (-) percDiscount (d)) / 100.0));
    invoicePrice(d) <- round2(price (d) * (100 + calcValueVAT(d)) / 100);
}

// заполнение полной цены 
WHEN LOCAL //FORMS userInvoice 
        GOAFTER valueVAT[UserInvoiceDetail] 
        (((CHANGED(supplierStock(UserInvoiceDetail d)) OR CHANGED(dateTime(d))) AND NOT isPosted(d)) OR
         (CHANGED(priceListType(d)) OR CHANGED(agreement(d)) OR CHANGED(sku(d))))
         AND NOT CHANGED(fullPrice(d)) AND PriceListType pt == priceListType(d) AND isItem(sku(d)) 
         NOINLINE (pt) DO {
    fullPrice(d) <- round2(prevPriceB((OVERRIDE basePriceListType(pt),pt), sku(d), supplierStock(d), dateTime(d)));    
}

// при изменении полной цены пересчитывается цена 
WHEN LOCAL //FORMS userInvoice 
        GOAFTER valueVAT[UserInvoiceDetail] 
        (CHANGED(fullPrice(UserInvoiceDetail d)))
         AND NOT CHANGED(percDiscount(d)) 
         AND isItem(sku(d)) DO {
    recalculateDiscountPrice(d);
}

// заполнение % скидки из соглашения
WHEN LOCAL FORMS userInvoice CHANGED(agreement(UserInvoice o)) AND NOT CHANGED(percDiscount(o)) AND CalcPriceListType pt == priceListType(agreement(o)) DO {
    percDiscount(o) <- -nearestMarkup(pt, itemGroup('all'));
}
WHEN LOCAL //FORMS userInvoice 
        GOAFTER valueVAT[UserOrderDetail] 
        (CHANGED(sku(UserInvoiceDetail d)) OR CHANGED(agreement(d))) AND isItem(sku(d)) 
        AND NOT CHANGED(dataPercDiscount(d)) 
        AND CalcPriceListType pt == priceListType(d) AND isItem(sku(d)) NOINLINE (pt) DO {
    dataPercDiscount(d) <- -dataMarkup(pt,sku(d)); 
}

// при изменении % скидки пересчитывается цена 
WHEN LOCAL //FORMS userInvoice 
        GOAFTER fullPrice[UserInvoiceDetail] 
        (CHANGED(percDiscount(UserInvoiceDetail d)))
         AND NOT CHANGED(price(d)) 
         AND fullPrice(d) AND isItem(sku(d)) DO {
    recalculateDiscountPrice(d);
}

// при изменении цены меняется % скидки
overChangePrice(UserInvoiceDetail d) += {
    IF fullPrice(d) AND isItem(sku(d)) THEN {
        dataPercDiscount(d) <- NUMERIC[8,4](round2((1.0 - (price(d)/fullPrice(d)))*100.0));     
    }   
}
WHEN LOCAL FORMS userInvoice GOAFTER price[UserInvoiceDetail] (CHANGED(price(UserInvoiceDetail d)))  AND 
                             fullPrice(d) AND isItem(sku(d)) AND
                             NOT CHANGED(percDiscount(d)) AND NOT CHANGED(fullPrice(d))DO {
    dataPercDiscount(d) <- NUMERIC[8,4](round2((1.0 - (price(d)/fullPrice(d)))*100.0));
}

recalculateFullPriceUserInvoiceDetail 'Пересчитать цены'() = {
    FOR PriceListType pt == priceListType(UserInvoiceDetail d) AND isItem(sku(d)) AND [= FILTER userInvoice.d](d) NOINLINE (pt) DO {
        fullPrice(d) <- round2(prevPriceB((OVERRIDE basePriceListType(pt),pt), sku(d), supplierStock(d), dateTime(d)));    
    }
} ASON CONTEXTMENU fullPrice[UserInvoiceDetail];

EXTEND FORM userInvoice
    PROPERTIES (i) percDiscount 
    PROPERTIES (d) BEFORE  price(d) fullPrice, percDiscount READONLYIF readonlySaleDiscount()
;

EXTEND FORM invoices
    PROPERTIES (d) READONLY BEFORE  price(d) fullPrice, percDiscount
;

skipEqualAgreements = ABSTRACT BOOLEAN (UserInvoice);

CONSTRAINT agreement(Order o) != agreement(UserInvoice i) AND include(o,i) AND NOT skipEqualAgreements(i)
    CHECKED BY agreement[UserInvoice] MESSAGE 'Соглашения в заказе и накладной должны совпадать';

skipSetAgreement(UserInvoice i) += priceListType(agreement(i)) IS CalcPriceListType;

overFill (UserInvoice i, Order o) += {
    percDiscount(i) <- percDiscount(o);
}
overFill (UserInvoiceDetail id, OrderDetail od) += {
    fullPrice(id) <- fullPrice(od);  
    dataPercDiscount(id) <- dataPercDiscount(od);  
}

overCopy (UserInvoice i, UserInvoice invoice) += {
    percDiscount(invoice) <- percDiscount(i);  
} 

// только для копирования строки, при копировании документа заполняется стандартными значениями
overCopy[UserInvoiceDetail, UserInvoiceDetail](UserInvoiceDetail d, UserInvoiceDetail detail) += {
    fullPrice(d) <- fullPrice(detail);  
    dataPercDiscount(d) <- dataPercDiscount(detail);  
} 