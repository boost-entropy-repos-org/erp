MODULE PricingSale;

REQUIRE PricingInvoice, SaleInvoice, SaleShipment, SaleOperation, PriceListLedger;

NAMESPACE Sale;

// Добавляем цены поставщика
@defineDocumentInterfaceDetailPricePrefix(invoice, supplier, ' поставщика');
@defineDocumentInterfaceDetailDataSumPrefix (invoice, supplier, ' поставщика');
@deriveDocumentDetailSumCustomRoundPrefix(userInvoiceDetail, supplier, currency, quantity,priceRound);
@defineDocumentInterfaceHeaderSumPrefix (invoice, supplier, ' поставщика');

// Создаем акт расценки
roundConditionUserInvoiceDetail(userInvoiceDetail) = roundConditionDepartmentStore(supplierStockUserInvoiceDetail(userInvoiceDetail));
@defineInvoicePricingAggregation(invoice, Invoice, ' (продажа)', 'Акт расценки при продаже', 'Проведенный акт расценки при продаже', supplier, supplier);
batchPricingDetail(detail) += batchInvoiceDetail(invoiceDetailInvoicePricingDetail(detail));
editPricingDetail (d)+= ACTION editInvoiceDetail(invoiceDetailInvoicePricingDetail(d));


// Автоматически проставляем цены поставщика и розничные
WHEN SESSION (CHANGED(skuUserInvoiceDetail(detail)) OR
              CHANGED(supplierStockUserInvoiceDetail(detail)) OR
              (CHANGED(dateTimeUserInvoiceDetail(detail)) AND NOT isPostedUserInvoiceDetail(detail)) OR
              CHANGED(batchUserInvoiceDetail(detail))) AND NOT CHANGED(supplierPriceUserInvoiceDetail (detail)) DO {
    supplierPriceUserInvoiceDetail (detail)  <- IF batchUserInvoiceDetail(detail) AND NOT notUseBatchPriceUserInvoiceDetail(detail) 
                                                    THEN prevPriceBPriceListTypeBatchStockDateTime(SystemLedgerPriceListType.supplierPricingPriceListType,
                                                                                                   batchUserInvoiceDetail(detail),
                                                                                                   supplierStockUserInvoiceDetail(detail),
                                                                                                   dateTimeUserInvoiceDetail(detail))
                                                    ELSE prevPriceBPriceListTypeSkuStockDateTime(SystemLedgerPriceListType.supplierPricingPriceListType,
                                                                                                 skuUserInvoiceDetail(detail),
                                                                                                 supplierStockUserInvoiceDetail(detail),
                                                                                                 dateTimeUserInvoiceDetail(detail));
}
 
WHEN SESSION (CHANGED(skuUserInvoiceDetail(detail)) OR
              CHANGED(supplierStockUserInvoiceDetail(detail)) OR
              (CHANGED(dateTimeUserInvoiceDetail(detail)) AND NOT isPostedUserInvoiceDetail(detail)) OR
              CHANGED(batchUserInvoiceDetail(detail))) AND NOT CHANGED(retailPriceUserInvoiceDetail (detail)) DO {
retailPriceUserInvoiceDetail (detail)  <- IF batchUserInvoiceDetail(detail) AND NOT notUseBatchPriceUserInvoiceDetail(detail)
                                                THEN prevPriceBPriceListTypeBatchStockDateTime(SystemLedgerPriceListType.retailPricingPriceListType,
                                                                                               batchUserInvoiceDetail(detail),
                                                                                               supplierStockUserInvoiceDetail(detail),
                                                                                               dateTimeUserInvoiceDetail(detail))
                                                ELSE prevPriceBPriceListTypeSkuStockDateTime(SystemLedgerPriceListType.retailPricingPriceListType,
                                                                                             skuUserInvoiceDetail(detail),
                                                                                             supplierStockUserInvoiceDetail(detail),
                                                                                             dateTimeUserInvoiceDetail(detail));
}

// Автоматический расчет розничной надбавки
retailMarkupUserInvoiceDetail(userInvoiceDetail)  <- [= round2((((X - X*Y/(100+Y))/Z)-1)*100)](
    retailPriceUserInvoiceDetail(userInvoiceDetail),
    valueRetailVATUserInvoiceDetail(userInvoiceDetail),
    pricingPriceUserInvoiceDetail(userInvoiceDetail))
    WHEN CHANGED(retailPriceUserInvoiceDetail(userInvoiceDetail)) OR
         CHANGED (valueRetailVATUserInvoiceDetail(userInvoiceDetail)) OR
         CHANGED(supplierPriceUserInvoiceDetail(userInvoiceDetail));

overRetailVATUserInvoiceDetail = ABSTRACT OVERRIDE FIRST Range (UserInvoiceDetail);
WHEN SESSION FORMS userInvoice
    (CHANGED(skuUserInvoiceDetail(detail)) OR CHANGED (supplierStockUserInvoiceDetail(detail)) OR 
     CHANGED(overRetailVATUserInvoiceDetail(detail))) AND NOT CHANGED(retailVATUserInvoiceDetail(detail)) DO {
        retailVATUserInvoiceDetail(detail) <- OVERRIDE VATSkuCountry (skuUserInvoiceDetail(detail), countryStock(supplierStockUserInvoiceDetail(detail))),
                                                       overRetailVATUserInvoiceDetail(detail);
    } // записываем шкалу

//------------------------------ Создание агрегированных объектов через операции -----------------------------//

// -- Операция
@defineOperationProperty(createPricing, 'Акт расценки', saleContainer);
@deriveDocumentOperationProperty(UserInvoice, createPricing);

// Добавление цены поставщика на форму
EXTEND FORM userInvoice
    PROPERTIES(i) SHOWIF createPricingInvoice(i) BACKGROUND backgroundRetailInvoice(i)
                     supplierSumUserInvoiceDetailUserInvoice
    PROPERTIES(pd) SHOWIF createPricingInvoice(i) BACKGROUND backgroundRetailInvoice(i) BEFORE retailMarkupUserInvoiceDetail(pd)
                     supplierPriceUserInvoiceDetail, supplierSumUserInvoiceDetail
;
EXTEND FORM invoices
    PROPERTIES(i) READONLY BACKGROUND backgroundRetailInvoice(i) BEFORE retailSumInvoiceDetailInvoice(i)
                           supplierSumInvoiceDetailInvoice
    PROPERTIES(d) SHOWIF createPricingInvoice(i) BACKGROUND backgroundRetailInvoice(i) BEFORE retailMarkupInvoiceDetail(d)
                           supplierPriceInvoiceDetail, supplierSumInvoiceDetail
;

// Помечаем, что этот акт расценки не меняет текущие цены и является обратным
skipChangeLedgerPricingDetail(d) += d IS InvoicePricingDetail;
isReturnPricing(pricing) += pricing IS InvoicePricing;

// Операция расценки

pricingOperationOperation  = DATA Pricing.Operation (Operation);
namePricingOperationOperation 'Операция (расценка)' (operation)= Pricing.nameOperation(pricingOperationOperation(operation));

EXTEND FORM operation
    PROPERTIES(o) namePricingOperationOperation
;
DESIGN operation {
    saleContainer {
        MOVE PROPERTY(namePricingOperationOperation(o)) AFTER PROPERTY(createPricingOperation(o));
    }
}

@defineDocumentInterfaceOperationPrefix (invoice, pricing, Pricing, ' ( расценка)');
pricingOperationUserInvoice (invoice) <- pricingOperationOperation(operationUserInvoice(invoice))
    WHEN CHANGED(operationUserInvoice(invoice));
operationPricing(pricing) += pricingOperationInvoice(invoiceInvoicePricing(pricing));

// Добавляем операцию расценки на форму
EXTEND FORM userInvoice
    PROPERTIES(i) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) namePricingOperationUserInvoice
;
DESIGN userInvoice {
    headerCreatePricing {
        MOVE PROPERTY(namePricingOperationUserInvoice(i));// BEFORE PROPERTY(namePricingCommitteeUserInvoice(i));
    }
}