MODULE PricingSale;

REQUIRE PricingInvoice, SaleInvoice, SaleShipment, SaleOperation, PriceListLedger;

NAMESPACE Sale;

// Добавляем цены поставщика
@defineDocumentInterfaceDetailPricePrefix(invoice, supplier, ' поставщика');
@defineDocumentInterfaceDetailDataSumPrefix (invoice, supplier, ' поставщика');
@deriveDocumentDetailSumCustomRoundPrefix(userInvoiceDetail, supplier, currency, quantity,priceRound);
@defineDocumentInterfaceHeaderSumPrefix (invoice, supplier, ' поставщика');

// Создаем акт расценки
roundConditionUserInvoiceDetail(userInvoiceDetail) = roundConditionDepartmentStore(supplierStockUserInvoiceDetail(userInvoiceDetail));
@defineInvoicePricingAggregation(invoice, Invoice, ' (продажа)', 'Акт расценки при продаже', 'Проведенный акт расценки при продаже', supplier, supplier);
batchPricingDetail(detail) += batchInvoiceDetail(invoiceDetailInvoicePricingDetail(detail));
editPricingDetail (d)+= ACTION editInvoiceDetail(invoiceDetailInvoicePricingDetail(d));


// Автоматически проставляем цены поставщика и розничные
@deriveDocumentDetailPriceSystemLedgerPriceListTypeBatch(userInvoice, supplierPricingPriceListType, supplier, sku, supplierStock);
@deriveDocumentDetailPriceSystemLedgerPriceListTypeBatch(userInvoice, retailPricingPriceListType, retail, sku, supplierStock);

// Автоматический расчет розничной надбавки
retailMarkupUserInvoiceDetail(userInvoiceDetail)  <- [= round2((((X - X*Y/(100+Y))/Z)-1)*100)](
    retailPriceUserInvoiceDetail(userInvoiceDetail),
    valueRetailVATUserInvoiceDetail(userInvoiceDetail),
    pricingPriceUserInvoiceDetail(userInvoiceDetail))
    WHEN CHANGED(retailPriceUserInvoiceDetail(userInvoiceDetail)) OR
         CHANGED (valueRetailVATUserInvoiceDetail(userInvoiceDetail)) OR
         CHANGED(supplierPriceUserInvoiceDetail(userInvoiceDetail));

@deriveDocumentDetailVAT(userInvoice, retail, date, sku, supplierStock);

//------------------------------ Создание агрегированных объектов через операции -----------------------------//

// -- Операция
@defineOperationProperty(createPricing, 'Акт расценки', saleContainer);
@deriveDocumentOperationProperty(UserInvoice, createPricing);

// Добавление цены поставщика на форму
EXTEND FORM userInvoice
    PROPERTIES(i) SHOWIF createPricingInvoice(i) BACKGROUND backgroundRetailInvoice(i)
                     supplierSumUserInvoiceDetailUserInvoice
    PROPERTIES(pd) SHOWIF createPricingInvoice(i) BACKGROUND backgroundRetailInvoice(i) BEFORE retailMarkupUserInvoiceDetail(pd)
                     supplierPriceUserInvoiceDetail, supplierSumUserInvoiceDetail
;
EXTEND FORM invoices
    PROPERTIES(i) READONLY BACKGROUND backgroundRetailInvoice(i) BEFORE retailSumInvoiceDetailInvoice(i)
                           supplierSumInvoiceDetailInvoice
    PROPERTIES(d) SHOWIF createPricingInvoice(i) BACKGROUND backgroundRetailInvoice(i) BEFORE retailMarkupInvoiceDetail(d)
                           supplierPriceInvoiceDetail, supplierSumInvoiceDetail
;

// Помечаем, что этот акт расценки не меняет текущие цены и является обратным
skipChangeLedgerPricingDetail(d) += d IS InvoicePricingDetail;
isReturnPricing(pricing) += pricing IS InvoicePricing;

// Операция расценки

pricingOperationOperation  = DATA Pricing.Operation (Operation);
namePricingOperationOperation 'Операция (расценка)' (operation)= Pricing.nameOperation(pricingOperationOperation(operation));

EXTEND FORM operation
    PROPERTIES(o) namePricingOperationOperation
;
DESIGN operation {
    saleContainer {
        MOVE PROPERTY(namePricingOperationOperation(o)) AFTER PROPERTY(createPricingOperation(o));
    }
}

@defineDocumentInterfaceOperationPrefix (invoice, pricing, Pricing, ' ( расценка)');
pricingOperationUserInvoice (invoice) <- pricingOperationOperation(operationUserInvoice(invoice))
    WHEN CHANGED(operationUserInvoice(invoice));
operationPricing(pricing) += pricingOperationInvoice(invoiceInvoicePricing(pricing));

// Добавляем операцию расценки на форму
EXTEND FORM userInvoice
    PROPERTIES(i) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) namePricingOperationUserInvoice
;
DESIGN userInvoice {
    headerCreatePricing {
        MOVE PROPERTY(namePricingOperationUserInvoice(i)) BEFORE PROPERTY(namePricingCommitteeUserInvoice(i));
    }
}