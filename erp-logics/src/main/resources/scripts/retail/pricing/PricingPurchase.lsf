MODULE PricingPurchase;

REQUIRE PricingInvoice, PurchaseInvoice, PurchaseShipment, PurchaseOperation, GLAccountType, PriceListStore;

NAMESPACE Purchase;

//----------------------------------------------- Акт расценки ---------------------------------------------------//

// Объявляем вид цены для надбавки, автоматически проставляем
@defineDocumentInterfaceHeaderPriceListType (invoice, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentDetailPriceListTypePrefix (invoice, invoiceDetail, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentDetailPriceListTypePrefix (userInvoice, userInvoiceDetail, calcPriceListType, calcRetail, ' (надбавка)');

// Объявляем вид цены управленческий
@defineDocumentInterfaceHeaderPriceListType (invoice, priceListType, calcRetail, ' (управленческий)');
@defineDocumentDetailPriceListTypePrefix (invoice, invoiceDetail, priceListType, calcRetail, ' (управленческий)');
@defineDocumentDetailPriceListTypePrefix (userInvoice, userInvoiceDetail, priceListType, calcRetail, ' (управленческий)');

@defineDocumentInterfaceDetailPriceListType (invoice, priceListType, retail, ' (розничная)');

CONSTRAINT currencyUserInvoice(invoice) != currencyPriceListType(calcRetailCalcPriceListTypeUserInvoice(invoice))
           CHECKED BY calcRetailCalcPriceListTypeUserInvoice
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';
CONSTRAINT currencyUserInvoice(invoice) != currencyPriceListType(calcRetailPriceListTypeUserInvoice(invoice))
           CHECKED BY calcRetailPriceListTypeUserInvoice
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';

CONSTRAINT currencyUserInvoiceDetail(detail) != currencyPriceListType(retailPriceListTypeUserInvoiceDetail(detail))
           CHECKED BY retailPriceListTypeUserInvoiceDetail
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';

// Записываем в вид цены управленческий вид цены, если по нему есть цена, иначе - надбавку
WHEN SESSION FORMS userInvoice
    (CHANGED(calcRetailPriceListTypeUserInvoiceDetail(detail)) OR
     CHANGED(calcRetailCalcPriceListTypeUserInvoiceDetail(detail)) OR
     CHANGED(skuUserInvoiceDetail(detail)) OR
     CHANGED(customerStockUserInvoiceDetail(detail)) OR
     CHANGED(dateTimeUserInvoiceDetail(detail))) AND pt == calcRetailPriceListTypeUserInvoiceDetail(detail) NOINLINE (pt) DO
     retailPriceListTypeUserInvoiceDetail(detail) <- IF prevPriceBPriceListTypeSkuStockDateTime(pt,
                                                                                                skuUserInvoiceDetail(detail),
                                                                                                customerStockUserInvoiceDetail(detail),
                                                                                                dateTimeUserInvoiceDetail(detail))
                                                        THEN pt
                                                        ELSE calcRetailCalcPriceListTypeUserInvoiceDetail(detail);

WHEN SESSION FORMS userInvoice
    (CHANGED(calcRetailPriceListTypeUserInvoiceDetail(detail)) OR
     CHANGED(calcRetailCalcPriceListTypeUserInvoiceDetail(detail)) OR
     CHANGED(skuUserInvoiceDetail(detail)) OR
     CHANGED(customerStockUserInvoiceDetail(detail)) OR
     CHANGED(dateTimeUserInvoiceDetail(detail))) AND NOT calcRetailPriceListTypeUserInvoiceDetail(detail) DO
     retailPriceListTypeUserInvoiceDetail(detail) <- calcRetailCalcPriceListTypeUserInvoiceDetail(detail);


// Округление розничной цен (если указан расчетный вид цены, то от него, иначе от склада)                
//roundConditionUserInvoiceDetail(userInvoiceDetail) =
//    IF roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(userInvoiceDetail))
//        THEN roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(userInvoiceDetail))
//        ELSE roundConditionDepartmentStore(customerStockUserInvoiceDetail(userInvoiceDetail));             

overRoundConditionUserInvoiceDetail (d) = IF retailPriceListTypeUserInvoiceDetail(d) IS CalcPriceListType 
    THEN roundConditionCalcPriceListTypeSku(retailPriceListTypeUserInvoiceDetail(d), skuUserInvoiceDetail(d)) 
    ELSE roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(d));

roundConditionUserInvoiceDetail(d) =  IF overRoundConditionUserInvoiceDetail(d)
        THEN overRoundConditionUserInvoiceDetail(d)              
        ELSE roundConditionDepartmentStore(customerStockUserInvoiceDetail(d));

@defineInvoicePricingAggregation(invoice, Invoice, ' (закупка)', 'Акт расценки на основе накладной', 'Проведенный акт расценки на основе накладной', customer, );
batchPricingDetail(detail) += OVERRIDE shipmentBatchShipmentDetail(invoiceShipmentDetailInvoiceDetail(invoiceDetailInvoicePricingDetail(detail))), batchInvoiceDetail(invoiceDetailInvoicePricingDetail(detail));
editPricingDetail (d)+= ACTION editInvoiceDetail(invoiceDetailInvoicePricingDetail(d));


@defineInvoicePricingRelation(' (закупка)', customerStock);
retailPriceListTypePricingDetail(pricingDetail) += retailPriceListTypeInvoiceDetail(invoiceDetailInvoicePricingDetail(pricingDetail));

// -- Операция
@defineOperationProperty(createPricing, 'Акт расценки', createContainer);
@deriveDocumentOperationProperty(UserInvoice, createPricing);
// Операция расценки
@defineDocumentInterfaceOperationPrefix (invoice, pricing, Pricing, ' ( расценка)');

pricingOperationOperation  = DATA Pricing.Operation (Operation);
namePricingOperationOperation 'Операция (расценка)' (operation)= Pricing.nameOperation(pricingOperationOperation(operation));

pricingOperationUserInvoice (invoice) <- pricingOperationOperation(operationUserInvoice(invoice))
    WHEN CHANGED(operationUserInvoice(invoice));

operationPricing(pricing) += pricingOperationInvoice(invoiceInvoicePricing(pricing));

// Записываем тип цены по умолчанию из операции
calcRetailPriceListTypeUserInvoice (invoice) <- IF pricingPriceListTypeOperation(pricingOperationUserInvoice(invoice)) 
                THEN pricingPriceListTypeOperation(pricingOperationUserInvoice(invoice))
                ELSE retailPriceListTypeDepartmentStore(customerStockUserInvoice(invoice))
                    WHEN CHANGED(pricingOperationUserInvoice(invoice)) OR CHANGED(customerStockUserInvoice(invoice));

calcRetailCalcPriceListTypeUserInvoice (invoice) <- IF pricingCalcPriceListTypeOperation(pricingOperationUserInvoice(invoice))
                THEN pricingCalcPriceListTypeOperation(pricingOperationUserInvoice(invoice))
                ELSE retailCalcPriceListTypeDepartmentStore(customerStockUserInvoice(invoice))
                    WHEN CHANGED(pricingOperationUserInvoice(invoice)) OR CHANGED(customerStockUserInvoice(invoice));

EXTEND FORM operation
    PROPERTIES(o) namePricingOperationOperation
;
EXTEND DESIGN operation {
    createContainer {
        ADD PROPERTY(namePricingOperationOperation(o)) AFTER PROPERTY(createPricingOperation(o));
    }
}

// Добавляем вид цены на форму
EXTEND FORM userInvoice
    PROPERTIES(i) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i)
                  namePricingOperationUserInvoice, nameCalcRetailPriceListTypeUserInvoice, nameCalcRetailCalcPriceListTypeUserInvoice
    PROPERTIES(pd) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) nameRetailPriceListTypeUserInvoiceDetail BEFORE retailMarkupUserInvoiceDetail(pd)
;
EXTEND DESIGN userInvoice {
    headerCreatePricing {
        ADD PROPERTY(namePricingOperationUserInvoice(i));
        ADD PROPERTY(nameCalcRetailPriceListTypeUserInvoice(i)) AFTER PROPERTY(namePricingOperationUserInvoice(i));
        ADD PROPERTY(nameCalcRetailCalcPriceListTypeUserInvoice(i)) AFTER PROPERTY(nameCalcRetailPriceListTypeUserInvoice(i));
    }
}

EXTEND FORM invoices PROPERTIES(d) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) READONLY nameRetailPriceListTypeInvoiceDetail BEFORE retailMarkupInvoiceDetail(d);

// расчет надбавок и цены при изменении priceListType
overLimitPriceUserInvoiceDetail = ABSTRACT NUMERIC[14,2] (UserInvoiceDetail);
@deriveDocumentDetailBatchOnSessionPriceListType(UserInvoiceDetail, retail, pricing, customerStock, userInvoice);
// Изменяем учетную цену
overShipmentPriceUserInvoiceDetail(detail) += WHEN customerStockUserInvoiceDetail(detail) IS DepartmentStore AND NOT costLedgerDepartmentStore(customerStockUserInvoiceDetail(detail))
                                                THEN retailPriceUserInvoiceDetail(detail);
overCostPriceShipmentDetail(detail) += WHEN customerStockShipmentDetail(detail) IS DepartmentStore AND NOT costLedgerDepartmentStore(customerStockShipmentDetail(detail)) 
                                   THEN costPriceInvoiceDetail(invoiceDetailInvoiceShipmentDetail(detail));

// Проставляем НДС розничный, равный НДС входному
retailVATUserInvoiceDetail (detail) <- VATUserInvoiceDetail(detail) WHEN CHANGED(VATUserInvoiceDetail(detail));

// Копирование документа
overCopyInvoice(s, d) += ACTION (s, d) {
    ASSIGN createPricingUserInvoice(d) <- createPricingUserInvoice(s);
    ASSIGN pricingCommitteeUserInvoice(d) <- pricingCommitteeUserInvoice(s);
    ASSIGN pricingOperationUserInvoice(d) <- pricingOperationUserInvoice(s);
    ASSIGN calcRetailPriceListTypeUserInvoice(d) <- calcRetailPriceListTypeUserInvoice(s);
    ASSIGN calcRetailCalcPriceListTypeUserInvoice(d) <- calcRetailCalcPriceListTypeUserInvoice(s);
}

