MODULE PricingPurchase;

REQUIRE Pricing, PurchaseInvoice, Repricing, PurchaseShipment, PurchaseOperation, GLAccountType;

NAMESPACE Purchase;

//----------------------------------------------- Акт расценки ---------------------------------------------------//

// Объявляем вид цены для надбавки, автоматически проставляем
@defineDocumentInterfaceHeaderPriceListType (invoice, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentDetailPriceListTypePrefix (invoice, invoiceDetail, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentDetailPriceListTypePrefix (userInvoice, userInvoiceDetail, calcPriceListType, calcRetail, ' (надбавка)');

// Объявляем вид цены управленческий
@defineDocumentInterfaceHeaderPriceListType (invoice, priceListType, calcRetail, ' (управленческий)');
@defineDocumentDetailPriceListTypePrefix (invoice, invoiceDetail, priceListType, calcRetail, ' (управленческий)');
@defineDocumentDetailPriceListTypePrefix (userInvoice, userInvoiceDetail, priceListType, calcRetail, ' (управленческий)');

@defineDocumentInterfaceDetailPriceListType (invoice, priceListType, retail, ' (розничная)');

CONSTRAINT currencyUserInvoice(invoice) != currencyPriceListType(calcRetailCalcPriceListTypeUserInvoice(invoice))
           CHECKED BY calcRetailCalcPriceListTypeUserInvoice
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';
CONSTRAINT currencyUserInvoice(invoice) != currencyPriceListType(calcRetailPriceListTypeUserInvoice(invoice))
           CHECKED BY calcRetailPriceListTypeUserInvoice
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';

CONSTRAINT currencyUserInvoiceDetail(detail) != currencyPriceListType(retailPriceListTypeUserInvoiceDetail(detail))
           CHECKED BY retailPriceListTypeUserInvoiceDetail
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';

retailPriceListTypeUserInvoiceDetail(detail) <- IF prevPricePriceListTypeSkuStockDateTime(calcRetailPriceListTypeUserInvoiceDetail(detail),
                                                                                          skuUserInvoiceDetail(detail),
                                                                                          customerStockUserInvoiceDetail(detail),
                                                                                          dateTimeUserInvoiceDetail(detail))
                                                    THEN calcRetailPriceListTypeUserInvoiceDetail(detail)
                                                    ELSE calcRetailCalcPriceListTypeUserInvoiceDetail(detail)

                                                WHEN CHANGED(calcRetailPriceListTypeUserInvoiceDetail(detail)) OR
                                                     CHANGED(skuUserInvoiceDetail(detail)) OR
                                                     CHANGED(customerStockUserInvoiceDetail(detail)) OR
                                                     CHANGED(dateTimeUserInvoiceDetail(detail));

// Записываем в вид цены управленческий вид цены, если по нему есть цена, иначе - надбавку
//WHEN SESSION FORMS userInvoice
//     CHANGED(calcRetailPriceListTypeUserInvoiceDetail(detail)) OR
//     CHANGED(calcRetailCalcPriceListTypeUserInvoiceDetail(detail)) OR
//     CHANGED(skuUserInvoiceDetail(detail)) OR
//     CHANGED(customerStockUserInvoiceDetail(detail)) OR
//     CHANGED(dateTimeUserInvoiceDetail(detail)) NOINLINE DO {
//
//     retailPriceListTypeUserInvoiceDetail(detail) <- IF prevPricePriceListTypeSkuStockDateTime(calcRetailPriceListTypeUserInvoiceDetail(detail),
//                                                                                               skuUserInvoiceDetail(detail),
//                                                                                               customerStockUserInvoiceDetail(detail),
//                                                                                               dateTimeUserInvoiceDetail(detail))
//                                                        THEN calcRetailPriceListTypeUserInvoiceDetail(detail)
//                                                        ELSE calcRetailCalcPriceListTypeUserInvoiceDetail(detail);
//}

// Округление розничной цен (если указан расчетный вид цены, то от него, иначе от склада)
roundConditionUserInvoiceDetail(userInvoiceDetail) =
    IF roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(userInvoiceDetail))
        THEN roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(userInvoiceDetail))
        ELSE roundConditionDepartmentStore(customerStockUserInvoiceDetail(userInvoiceDetail));

@defineInvoicePricingAggregation(invoice, Invoice, ' (закупка)', 'Акт расценки на основе инвойса', 'Проведенный акт расценки на основе инвойса', customerStock, );
@defineInvoicePricingRelation(' (закупка)', customerStock);
retailPriceListTypePricingDetail(pricingDetail) += retailPriceListTypeInvoiceDetail(invoiceDetailInvoicePricingDetail(pricingDetail));

// -- Операция
@defineOperationProperty(createPricing, 'Акт расценки', createContainer);
@deriveDocumentOperationProperty(UserInvoice, createPricing);
// Операция расценки
@defineDocumentInterfaceOperationPrefix (invoice, pricing, Pricing, ' ( расценка)');

pricingOperationOperation  = DATA Pricing.Operation (Operation);
namePricingOperationOperation 'Операция (расценка)' (operation)= Pricing.nameOperation(pricingOperationOperation(operation));

pricingOperationUserInvoice (invoice) <- pricingOperationOperation(operationUserInvoice(invoice))
    WHEN CHANGED(operationUserInvoice(invoice));

operationPricing(pricing) += pricingOperationInvoice(invoiceInvoicePricing(pricing));

// Записываем тип цены по умолчанию из операции
calcRetailPriceListTypeUserInvoice (invoice) <- pricingPriceListTypeOperation(pricingOperationUserInvoice(invoice))
    WHEN CHANGED(pricingOperationUserInvoice(invoice));
calcRetailCalcPriceListTypeUserInvoice (invoice) <- pricingCalcPriceListTypeOperation(pricingOperationUserInvoice(invoice))
    WHEN CHANGED(pricingOperationUserInvoice(invoice));

EXTEND FORM operation
    PROPERTIES(o) namePricingOperationOperation
;
EXTEND DESIGN operation {
    createContainer {
        ADD PROPERTY(namePricingOperationOperation) AFTER PROPERTY(createPricingOperation);
    }
}

// Добавляем вид цены на форму
EXTEND FORM userInvoice
    PROPERTIES(i) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i)
                  namePricingOperationUserInvoice, nameCalcRetailPriceListTypeUserInvoice, nameCalcRetailCalcPriceListTypeUserInvoice
    PROPERTIES(d) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) nameRetailPriceListTypeUserInvoiceDetail BEFORE retailMarkupUserInvoiceDetail
;
EXTEND DESIGN userInvoice {
    headerCreatePricing {
        ADD PROPERTY(namePricingOperationUserInvoice) AFTER PROPERTY(createPricingUserInvoice);
        ADD PROPERTY(nameCalcRetailPriceListTypeUserInvoice) AFTER PROPERTY(namePricingOperationUserInvoice);
        ADD PROPERTY(nameCalcRetailCalcPriceListTypeUserInvoice) AFTER PROPERTY(nameCalcRetailPriceListTypeUserInvoice);
    }
}

EXTEND FORM invoices PROPERTIES(d) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) READONLY nameRetailPriceListTypeInvoiceDetail BEFORE retailMarkupInvoiceDetail;

// расчет надбавок и цены при изменении priceListType
@deriveDocumentDetailPriceOnSessionPriceListType (UserInvoiceDetail, retail, pricing, customerStock, userInvoice);

// Изменяем учетную цену
overShipmentPriceUserInvoiceDetail(detail) += retailPriceUserInvoiceDetail(detail)
    WHEN customerStockUserInvoiceDetail(detail) IS DepartmentStore AND NOT costLedgerDepartmentStore(customerStockUserInvoiceDetail(detail));

// Проставляем НДС розничный, равный НДС входному
retailVATUserInvoiceDetail (detail) <- VATUserInvoiceDetail(detail) WHEN CHANGED(VATUserInvoiceDetail(detail));

//----------------------------------------------- Акт дооценки ---------------------------------------------------//
@defineRepricingAggregation(' (закупка)', customerStock);

@defineOperationProperty(createRepricing, 'Акт дооценки', createContainer);
@deriveDocumentOperationProperty(UserInvoice, createRepricing);

repricingOperationOperation  = DATA Repricing.Operation (Operation);
nameRepricingOperationOperation 'Операция (переоценки)' (operation)= Repricing.nameOperation(repricingOperationOperation(operation));


EXTEND FORM operation
    PROPERTIES(o) nameRepricingOperationOperation
;
EXTEND DESIGN operation {
    createContainer {
        ADD PROPERTY(nameRepricingOperationOperation) AFTER PROPERTY(createRepricingOperation);
    }
}

// Операция переоценки
@defineDocumentInterfaceOperationPrefix (invoice, repricing, Repricing, ' ( переоценка)');
repricingOperationUserInvoice(i) <- repricingOperationOperation(operationUserInvoice(i))
    WHEN CHANGED(operationUserInvoice(i));

EXTEND FORM userInvoice
    PROPERTIES(i) BACKGROUND backgroundCurInvoice(i) SHOWIF createRepricingUserInvoice(i) nameRepricingOperationUserInvoice
;
EXTEND DESIGN userInvoice {
    headerCreateRepricing {
        ADD PROPERTY(nameRepricingOperationUserInvoice) BEFORE PROPERTY(nameRepricingCommitteeUserInvoice);
    }
}

operationRepricing (repricing)+= repricingOperationInvoice(invoiceInvoiceRepricing(repricing));
// Копирование документа
overCopyInvoice(s, d) += ACTION (s, d) {
    SET createPricingUserInvoice(d) <- createPricingUserInvoice(s);
    SET pricingCommitteeUserInvoice(d) <- pricingCommitteeUserInvoice(s);
    SET pricingOperationUserInvoice(d) <- pricingOperationUserInvoice(s);
    SET calcRetailPriceListTypeUserInvoice(d) <- calcRetailPriceListTypeUserInvoice(s);
    SET calcRetailCalcPriceListTypeUserInvoice(d) <- calcRetailCalcPriceListTypeUserInvoice(s);

    SET createRepricingUserInvoice(d) <- createRepricingUserInvoice(s);
    SET repricingOperationUserInvoice(d) <- repricingOperationUserInvoice(s);
}

