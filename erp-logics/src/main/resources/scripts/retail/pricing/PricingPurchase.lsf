MODULE PricingPurchase;

REQUIRE PricingInvoice, PurchaseInvoice, PurchaseShipment, PurchaseOperation, GLAccountType, PriceListStore;

NAMESPACE Purchase;

//----------------------------------------------- Акт расценки ---------------------------------------------------//

// Объявляем вид цены для надбавки, автоматически проставляем
@defineDocumentInterfaceHeaderPriceListType (invoice, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentDetailPriceListTypePrefix (invoice, invoiceDetail, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentDetailPriceListTypePrefix (userInvoice, userInvoiceDetail, calcPriceListType, calcRetail, ' (надбавка)');

// Объявляем вид цены управленческий
@defineDocumentInterfaceHeaderPriceListType (invoice, priceListType, calcRetail, ' (управленческий)');
@defineDocumentDetailPriceListTypePrefix (invoice, invoiceDetail, priceListType, calcRetail, ' (управленческий)');
@defineDocumentDetailPriceListTypePrefix (userInvoice, userInvoiceDetail, priceListType, calcRetail, ' (управленческий)');

@defineDocumentInterfaceDetailPriceListType (invoice, priceListType, retail, ' (розничная)');

CONSTRAINT currency(UserInvoice invoice) != currency[PriceListType](calcRetailCalcPriceListType(invoice))
           CHECKED BY calcRetailCalcPriceListType[UserInvoice]
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';
CONSTRAINT currency(UserInvoice invoice) != currency(calcRetailPriceListType(invoice))
           CHECKED BY calcRetailPriceListType[UserInvoice]
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';

CONSTRAINT currency(UserInvoiceDetail detail) != currency(retailPriceListType(detail))
           CHECKED BY retailPriceListType[UserInvoiceDetail]
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';

    
//fillRetailPriceListTypeUserInvoiceDetailAll 'Пересчитать цену для всех'  = ACTION (detail) { // нужно чтобы еще сработали SESSION потом, которые изменяют цену и надбавку
//    retailPriceListTypeUserInvoiceDetail(d) <-NULL WHERE userInvoiceUserInvoiceDetail(detail) == userInvoiceUserInvoiceDetail(d);
//    retailPriceListTypeUserInvoiceDetail(d) <- (IF prevPriceBPriceListTypeSkuStockDateTime(calcRetailPriceListTypeUserInvoiceDetail(d),
//                                                                                            skuUserInvoiceDetail(d),
//                                                                                            customerStockUserInvoiceDetail(d),
//                                                                                            dateTimeUserInvoiceDetail(d)
//                                                                                            )
//        THEN calcRetailPriceListTypeUserInvoiceDetail(d)
//        ELSE calcRetailCalcPriceListTypeUserInvoiceDetail(d)) WHERE userInvoiceUserInvoiceDetail(detail) == userInvoiceUserInvoiceDetail(d);    
//} SHORTCUT nameRetailPriceListTypeUserInvoiceDetail;


// Округление розничной цен (если указан расчетный вид цены, то от него, иначе от склада)                
//roundConditionUserInvoiceDetail(userInvoiceDetail) =
//    IF roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(userInvoiceDetail))
//        THEN roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(userInvoiceDetail))
//        ELSE roundConditionDepartmentStore(customerStockUserInvoiceDetail(userInvoiceDetail));             

overRoundCondition (UserInvoiceDetail d) = IF retailPriceListType(d) IS CalcPriceListType 
    THEN roundCondition(retailPriceListType(d), sku(d)) 
    ELSE roundCondition(retailPriceListType(d));

roundCondition(UserInvoiceDetail d) =  IF overRoundCondition(d)
        THEN overRoundCondition(d)              
        ELSE roundCondition(customerStock(d));

@defineInvoicePricingAggregation(invoice, Invoice, ' (закупка)', 'Акт расценки на основе накладной', 'Проведенный акт расценки на основе накладной', customer, );

// Записываем в вид цены управленческий вид цены, если по нему есть цена, иначе - надбавку
extraCalcRetailCalcPriceListType = ABSTRACT CASE OVERRIDE FIRST CalcPriceListType (UserInvoiceDetail);

skipSetRetailPriceListType = ABSTRACT BOOLEAN (UserInvoiceDetail);
WHEN SESSION FORMS userInvoice
    (CHANGED(calcRetailPriceListType(UserInvoiceDetail detail)) OR
     CHANGED(calcRetailCalcPriceListType(detail)) OR
     CHANGED(sku(detail)) OR
     CHANGED(customerStock(detail)) OR
     (CHANGED(pricingDateTime(detail)) AND NOT isPosted(detail))) 
     AND PriceListType pt == calcRetailPriceListType(detail)
     AND NOT skipSetRetailPriceListType(detail) NOINLINE (pt) DO
     retailPriceListType(detail) <- IF prevPriceB(pt, sku(detail), customerStock(detail), pricingDateTime(detail))
                                        THEN pt
                                        ELSE OVERRIDE calcRetailCalcPriceListType(detail), extraCalcRetailCalcPriceListType(detail);

WHEN SESSION FORMS userInvoice
    (CHANGED(calcRetailPriceListType(UserInvoiceDetail detail)) OR
     CHANGED(calcRetailCalcPriceListType(detail)) OR
     CHANGED(sku(detail)) OR
     CHANGED(customerStock(detail)) OR
     (CHANGED(pricingDateTime(detail)) AND NOT isPosted(detail))) 
     AND NOT calcRetailPriceListType(detail)
     AND NOT skipSetRetailPriceListType(detail) DO
     retailPriceListType(detail) <- OVERRIDE calcRetailCalcPriceListType(detail), extraCalcRetailCalcPriceListType(detail);     

batch(InvoicePricingDetail detail) += OVERRIDE shipmentBatch(invoiceShipmentDetail(invoiceDetail(detail))), batch(invoiceDetail(detail));
edit (InvoicePricingDetail d)+= ACTION edit(invoiceDetail(d));


@defineInvoicePricingRelation(' (закупка)', customerStock);
retailPriceListType(InvoicePricingDetail pricingDetail) += retailPriceListType(invoiceDetail(pricingDetail));

// -- Операция
@defineOperationProperty(createPricing, 'Акт расценки', createContainer);
@deriveDocumentOperationProperty(UserInvoice, createPricing);
// Операция расценки
@defineDocumentInterfaceOperationPrefix (invoice, pricing, Pricing, ' ( расценка)');

pricingOperation  = DATA Pricing.Operation (Operation);
namePricingOperation 'Операция (расценка)' (Operation operation)= name(pricingOperation(operation));

pricingOperation (UserInvoice invoice) <- pricingOperation(operation(invoice))
    WHEN CHANGED(operation(invoice));

operation(InvoicePricing pricing) += pricingOperation(invoice(pricing));

useShipmentQuantity (UserInvoice invoice) <- useShipmentQuantity(pricingOperation(operation(invoice)))
                                                        WHEN CHANGED(operation(invoice));
                                                            
// Записываем тип цены по умолчанию из операции
skipSetPriceListTypesDepartmentStore 'Не подставлять виды цен магазина' = DATA BOOLEAN (Pricing.Operation);

EXTEND FORM Pricing.operation
    PROPERTIES (o) skipSetPriceListTypesDepartmentStore
;

DESIGN Pricing.operation {
    createContainer{
        MOVE PROPERTY(skipSetPriceListTypesDepartmentStore(o));
    }    
}

calcRetailPriceListType (UserInvoice invoice) <- IF pricingPriceListType(pricingOperation(invoice)) 
                THEN pricingPriceListType(pricingOperation(invoice))
                ELSE (retailPriceListType(customerStock(invoice)) IF NOT skipSetPriceListTypesDepartmentStore(pricingOperation(invoice)))
                    WHEN (CHANGED(pricingOperation(invoice)) OR CHANGED(customerStock(invoice))) AND pricingOperation(invoice);

calcRetailCalcPriceListType (UserInvoice invoice) <- IF pricingCalcPriceListType(pricingOperation(invoice)) 
                THEN pricingCalcPriceListType(pricingOperation(invoice))
                ELSE (retailCalcPriceListType(customerStock(invoice)) IF NOT skipSetPriceListTypesDepartmentStore(pricingOperation(invoice)))
                    WHEN (CHANGED(pricingOperation(invoice)) OR CHANGED(customerStock(invoice))) AND pricingOperation(invoice);

EXTEND FORM operation
    PROPERTIES(o) namePricingOperation
;
DESIGN operation {
    createContainer {
        MOVE PROPERTY(namePricingOperation(o)) AFTER PROPERTY(createPricing(o));
    }
}

// Добавляем вид цены на форму
EXTEND FORM userInvoice
    PROPERTIES(i) SHOWIF createPricing(i) BACKGROUND backgroundRetail(i)
                  namePricingOperation, nameCalcRetailPriceListType, nameCalcRetailCalcPriceListType, useShipmentQuantity
    PROPERTIES(pd) SHOWIF createPricing(i) BACKGROUND backgroundRetail(i) nameRetailPriceListType BEFORE retailMarkup(pd)
;
DESIGN userInvoice {
    headerCreatePricing {
        MOVE PROPERTY(namePricingOperation(i));
        MOVE PROPERTY(nameCalcRetailPriceListType(i)) AFTER PROPERTY(namePricingOperation(i));
        MOVE PROPERTY(nameCalcRetailCalcPriceListType(i)) AFTER PROPERTY(nameCalcRetailPriceListType(i));
        MOVE PROPERTY(useShipmentQuantity(i)) AFTER PROPERTY(nameCalcRetailCalcPriceListType(i));
    }
}

EXTEND FORM invoices PROPERTIES(d) SHOWIF createPricing[UserInvoice](i) BACKGROUND backgroundRetail(i) READONLY nameRetailPriceListType BEFORE retailMarkup(d);

// расчет надбавок и цены при изменении priceListType
@deriveDocumentDetailBatchOnSessionPriceListType(UserInvoiceDetail, retail, pricing, customerStock, userInvoice, pricing);
// Изменяем учетную цену
calcShipmentPrice(UserInvoiceDetail detail) += WHEN customerStock(detail) IS DepartmentStore AND NOT costLedger(customerStock(detail))
                                                THEN retailPrice(detail);
overCostPrice(InvoiceShipmentDetail detail) += costPrice(invoiceDetail(detail)) IF customerStock[ShipmentDetail](detail) IS DepartmentStore AND NOT costLedger(customerStock[ShipmentDetail](detail)); 

// Проставляем НДС розничный, равный НДС входному
WHEN SESSION CHANGED(VAT(UserInvoiceDetail detail)) OR CHANGED(valueVAT(detail)) DO {
    retailVAT(detail) <- IF valueVAT(detail) == 0 THEN
                                               VAT (sku(detail), country(supplierStock(detail)))
                                          ELSE VAT(detail);
}

// Добавляем на форму цену розничную (до)
retailPriceB 'Розничная цена (до)' (UserInvoiceDetail d) = prevRetailPricingPriceB(sku(d), customerStock(d), dateTime(d));
backgroundRetailPriceB (UserInvoiceDetail d) = CASE 
    WHEN retailPriceB(d) > retailExtraPrice(d) THEN RGB(250,150,150)
    WHEN retailPriceB(d) < retailExtraPrice(d) THEN RGB(150,250,200);

EXTEND FORM userInvoice
    PROPERTIES(pd) READONLY SHOWIF createPricing(i) retailExtraPrice, balanceB, retailPriceB BACKGROUND backgroundRetailPriceB(pd)

    FILTERGROUP prices 
        FILTER 'Цена (до) больше' retailPriceB(pd) > retailExtraPrice(pd)
        FILTER 'Цена (до) меньше' retailPriceB(pd) < retailExtraPrice(pd)
        FILTER 'Разные цены' retailPriceB(pd) != retailExtraPrice(pd)
;

// Копирование документа
overCopy(UserInvoice s, UserInvoice d) += ACTION (s, d) {
    ASSIGN createPricing(d) <- createPricing(s);
    ASSIGN pricingCommittee(d) <- pricingCommittee(s);
    ASSIGN pricingOperation(d) <- pricingOperation(s);
    ASSIGN calcRetailPriceListType(d) <- calcRetailPriceListType(s);
    ASSIGN calcRetailCalcPriceListType(d) <- calcRetailCalcPriceListType(s);
}

