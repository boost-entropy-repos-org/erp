MODULE BinLedger;

REQUIRE Bin;

NAMESPACE Bin;

CLASS ABSTRACT BinLedger 'Изменение остатка по ячейкам';
TABLE binLedger(BinLedger);

dateTime 'Дата/время' = ABSTRACT DATETIME (BinLedger) PERSISTENT INDEXED;
date 'Дата' (BinLedger ledger) = toDate(dateTime(ledger)); 

isPosted 'Проведен' = ABSTRACT BOOLEAN (BinLedger) PERSISTENT;

isClosed 'Закрыт' = ABSTRACT BOOLEAN (BinLedger);

sku = ABSTRACT Sku (BinLedger) PERSISTENT INDEXED;
nameSku 'SKU' (BinLedger ledger) = name(sku(ledger)) IN recognize;
idBarcodeSku 'Штрих код' (BinLedger ledger)= idBarcode(sku(ledger)) IN recognize;

stock = ABSTRACT Stock (BinLedger) PERSISTENT INDEXED;
nameStock 'Склад' (BinLedger ledger)= name(stock(ledger));

inBin = ABSTRACT Bin (BinLedger) PERSISTENT INDEXED;
nameInBin 'Ячейка (в)' (BinLedger ledger) = name(inBin(ledger)) IN recognize;

outBin = ABSTRACT Bin (BinLedger) PERSISTENT INDEXED;
nameOutBin 'Ячейка (из)' (BinLedger ledger) = name(outBin(ledger)) IN recognize;

quantity 'Кол-во' (ledger) = ABSTRACT NUMERIC[16,5] (BinLedger) PERSISTENT;

description 'Название документа' = ABSTRACT VARISTRING[200] (BinLedger);

changed = ABSTRACT BOOLEAN (BinLedger);

skip 'Не проводить по учету' = ABSTRACT BOOLEAN (BinLedger) PERSISTENT;
active 'Активен' (BinLedger ledger) = isPosted(ledger) AND NOT skip(ledger) PERSISTENT;

TABLE skuBin (Sku, Bin);

inBinTotal 'Приход в ячейку' =
    GROUP SUM quantity(BinLedger ledger) IF isPosted(ledger) BY sku(ledger), inBin(ledger) PERSISTENT;
    
outBinTotal 'Расход из ячейки' =
    GROUP SUM quantity(BinLedger ledger) IF isPosted(ledger) BY sku(ledger), outBin(ledger) PERSISTENT;
    
inBinTotalA 'Приход в ячейку' =
    GROUP SUM quantity(BinLedger ledger) IF date(ledger) > DATE date AND isPosted(ledger) BY sku(ledger), inBin(ledger), date;
    
outBinTotalA 'Расход из ячейки' =
    GROUP SUM quantity(BinLedger ledger) IF date(ledger) > DATE date AND isPosted(ledger) BY sku(ledger), outBin(ledger), date;
        
inBinTotalB 'Приход в ячейку' =
    GROUP SUM quantity(BinLedger ledger) IF date(ledger) >= DATE date AND isPosted(ledger) BY sku(ledger), inBin(ledger), date;
    
outBinTotalB 'Расход из ячейки' =
    GROUP SUM quantity(BinLedger ledger) IF date(ledger) >= DATE date AND isPosted(ledger) BY sku(ledger), outBin(ledger), date;
                
inBinTotalA 'Приход в ячейку' =
    GROUP SUM quantity(BinLedger ledger) IF dateTime(ledger) > DATETIME dateTime AND isPosted(ledger) BY sku(ledger), inBin(ledger), dateTime;
    
outBinTotalA 'Расход из ячейки' =
    GROUP SUM quantity(BinLedger ledger) IF dateTime(ledger) > DATETIME dateTime AND isPosted(ledger) BY sku(ledger), outBin(ledger), dateTime;
        
inBinTotalB 'Приход в ячейку' =
    GROUP SUM quantity(BinLedger ledger) IF dateTime(ledger) >= DATETIME dateTime AND isPosted(ledger) BY sku(ledger), inBin(ledger), dateTime;
    
outBinTotalB 'Расход из ячейки' =
    GROUP SUM quantity(BinLedger ledger) IF dateTime(ledger) >= DATETIME dateTime AND isPosted(ledger) BY sku(ledger), outBin(ledger), dateTime;                   
        
currentBalance 'Текущий остаток в ячейке' (Sku sku, Bin bin)=
    inBinTotal(sku, bin) (-) outBinTotal(sku, bin) PERSISTENT;
prevCurrentBalance 'Текущий остаток в ячейке' (Sku sku, Bin bin) = PREV(currentBalance(sku, bin));

balanceA 'Остаток в ячейке на конец дня' (Sku sku, Bin bin, DATE date) = currentBalance(sku, bin) (-)
                                                                 inBinTotalA(sku, bin, date) (+) outBinTotalA(sku, bin, date);

// без учета текущей даты/времени
balanceB 'Остаток в ячейке (до)' (Sku sku, Bin bin, DATETIME dateTime) = currentBalance(sku, bin) (-)
                                                                 inBinTotalA(sku, bin, dateTime) (+) outBinTotalA(sku, bin, dateTime);
prevBalanceB 'Остаток (до)' (Sku sku, Bin bin, DATETIME dateTime) = PREV(balanceB(sku, bin, dateTime) IF dateTime IS DATETIME);

// с учетом текущей даты/времени
balanceA 'Остаток в ячейке (после)' (Sku sku, Bin bin, DATETIME dateTime) = currentBalance(sku, bin) (-)
                                                                 inBinTotalA(sku, bin, dateTime) (+) outBinTotalA(sku, bin, dateTime);
prevBalanceA 'Остаток в ячейке (после)'(Sku sku, Bin bin, DATETIME dateTime) = PREV(balanceA(sku, bin, dateTime) IF dateTime IS DATETIME);

META implementBinLedger(class, object, skuProp, quantityProp, stockProp, inBinProp, outBinProp)
    dateTime[BinLedger] (###class ledger) += dateTime(object(ledger));
    isPosted[BinLedger] (###class ledger) += isPosted(object(ledger));
    isClosed[BinLedger] (###class ledger) += isClosed(object(ledger));
    skuProp[BinLedger] (###class ledger) += skuProp(object(ledger));
    quantity[BinLedger] (###class ledger) += quantityProp(object(ledger));
    stock[BinLedger] (###class ledger) += stockProp(object(ledger));
    inBin[BinLedger] (###class ledger) += inBinProp(object(ledger));
    outBin[BinLedger] (###class ledger) += outBinProp(object(ledger));
    description[BinLedger] (###class ledger) += description(object(ledger));
END       

META implementBinLedger(class, stockProp)
    dateTime[BinLedger] (###class ledger) += dateTime(ledger);
    isPosted[BinLedger] (###class ledger) += isPosted(ledger);
    isClosed[BinLedger] (###class ledger) += isClosed(ledger);
    sku[BinLedger] (###class ledger) += sku(ledger);
    quantity[BinLedger] (###class ledger) += quantity(ledger);
    stock[BinLedger] (###class ledger) += stockProp(ledger);
    inBin[BinLedger] (###class ledger) += inBin(ledger);
    outBin[BinLedger] (###class ledger) += outBin(ledger);
    description[BinLedger] (###class ledger) += description(ledger);
END
       
META createClassBinLedger (classPref)
    CLASS classPref##BinLedger : BinLedger;
END
META implementAggregationBinLedger(object, classPrefix, ClassPref, skuProp, quantityProp, stockProp, inBinProp, outBinProp)
    @createClassBinLedger(###classPrefix);
    needToCreate (###object object) = inBinProp(object) OR outBin(object); 
    @defineAggregation(object, classPrefix##BinLedger, needToCreate);
    @implementBinLedger(classPrefix##BinLedger, object, skuProp, quantityProp, stockProp, inBinProp, outBinProp);
END

FORM binLedger 'Регистр изменения остатков по ячейкам'
    OBJECTS dates = (dFrom = DATE, dTo = DATE) PANEL
    PROPERTIES valFrom = VALUE(dFrom), valTo = VALUE(dTo)
    
    OBJECTS b = BinLedger
    PROPERTIES (b) READONLY dateTime, isPosted, isClosed, nameStock, idBarcodeSku, nameSku, quantity, nameInBin, nameOutBin, description
    FILTERS isPosted(b)
    
    FILTERS date(b) >= dFrom, date(b) <= dTo
;

DESIGN binLedger {
    MOVE dates.box {
        type = CONTAINERH;
    }
    MOVE b.box {
        type = CONTAINERV;
    }
    MOVE functions.box;
}

balanceQuantity 'Кол-во' (Bin bin, BinLedger ledger) = IF inBin(ledger)==bin
    THEN quantity(ledger)
        ELSE IF outBin(ledger)==bin 
            THEN -quantity(ledger);
            
balanceBin 'Ячейка (из/в)' (Bin bin, BinLedger ledger) = IF inBin(ledger)==bin
    THEN nameOutBin(ledger)
        ELSE IF outBin(ledger)==bin 
            THEN nameInBin(ledger);            

FORM binBalance 'Остатки по ячейкам'

    OBJECTS ts = Stock PANEL
    PROPERTIES(ts) SELECTOR name
    FILTERS isCompany(ts)

    TREE binTree bg = BinGroup PARENT parent
    PROPERTIES READONLY name(bg)
    FILTERS countIn(ts, bg)

    OBJECTS b = Bin
    PROPERTIES(b) READONLY name, canonicalName
    FILTERS b IS Bin AND NOT bg IS BinGroup OR isParent(bg, b), in(ts, b)
    ORDER BY name(b)

    TREE treeGroup g=SkuGroup PARENT parent
    PROPERTIES READONLY order(g), name(g)
    FILTERS groupType(g) == groupType(ts)
    ORDER BY order(g), name(g)
    FILTERGROUP inactive FILTER 'Активные' active(g) 'F5' DEFAULT

    OBJECTS s = Sku
    PROPERTIES(s) READONLY name, idBarcode
    PROPERTIES (s, b) READONLY currentBalance
    ORDER BY name(s)
    FILTERS isParent(g, s) OR s IS Sku AND NOT g
    FILTERGROUP balance
        FILTER 'С остатком' currentBalance(s, b) DEFAULT
        
    OBJECTS l = BinLedger
    PROPERTIES (l) READONLY dateTime, isPosted, description
    PROPERTIES(b, l) READONLY balanceBin, balanceQuantity
    ORDER BY dateTime(l) DESC
    FILTERS inBin(l)==b OR outBin(l)==b, sku(l)==s
    FILTERGROUP posted
        FILTER 'Проведен' isPosted(l) DEFAULT
;

DESIGN binBalance {
    main{
        preferredSize = (1024, 768);

        MOVE ts.box;
        NEW topContainer {
            type = SPLITV;
            fill = 1;

            NEW binGroup {
                type = SPLITH;
                fill = 1;

                MOVE binTree.tree.box {
                    caption = 'Группы ячеек';
                }

                MOVE b.box {
                    fill = 2.5;
                    b.grid {
                        defaultComponent = TRUE;
                    }
                }
            }
            NEW skuGroup {
                type = SPLITH;
                fill = 3;

                MOVE treeGroup.tree.box {
                    caption = 'Группы Sku';
                }

                NEW skus {
                    fill = 2.5;
                    type = SPLITV;
                    MOVE s.box {
                        fill = 2;
                        s.grid {
                            defaultComponent = TRUE;
                        }
                    }    
                    MOVE l.box;                    
                }
            }
        }

        MOVE functions.box;
    }
}

NAVIGATOR {
    WMSNavigator {
        WMSReports {
            ADD binLedger;
            ADD binBalance;
        }    
    }
}

FORM dialogBinStock 'Ячейки'
    OBJECTS s = Stock PANEL
    
    TREE binTree bg = BinGroup PARENT parent
    PROPERTIES READONLY name(bg)
    FILTERS countIn(s, bg)

    OBJECTS b = Bin
    PROPERTIES(b) READONLY name, id SHOWIF showIDs(), canonicalName
    PROPERTIES(b) NEWSESSION NEW, EDIT, DELETE 

    FILTERS isParent(bg, b)
    ORDER BY name(b)    
;

DESIGN dialogBinStock {
    main{
        preferredSize = (1024, 768);

        NEW topContainer {
            type = SPLITH;
            fill = 1;
            
            MOVE binTree.tree.box {
                caption = 'Группы ячеек';
            }

            MOVE b.box {
                fill = 2;
                b.grid {
                    defaultComponent = TRUE;
                }
            }
        }

        MOVE functions.box;
    }
}

META defineInterfaceBin (object, prefix, caption)
    prefix###bin 'Ячейка'##caption = DATA Bin(###user###object) IN documentPrm;
    prefix###bin 'Ячейка'##caption = ABSTRACT Bin(###object) PERSISTENT IN documentPrm;
    prefix###bin (User###object object) += prefix###bin(object);
       
    name###prefix###bin 'Ячейка'##caption (###object object) = name(prefix###bin(object)) IN documentPrm MINCHARWIDTH 12 PREFCHARWIDTH 15;
    name###prefix###bin 'Ячейка'##caption (###user###object object) = name(prefix###bin(object)) IN documentPrm MINCHARWIDTH 12 PREFCHARWIDTH 15;
END

META defineDocumentBins (object)
    @defineInterfaceBin (object, in, ' (в)');
    @defineInterfaceBin (object, out, ' (из)');   
    
    @defineDocumentInterfaceProperty (object, useBins, 'Ячейки');
                   
    @defineInterfaceBin (object###detail, in, ' (в)');
    @defineInterfaceBin (object###detail, out, ' (из)');  
END

META setBinObject (object, stockProp)
    setInBin (object d) = {
        DIALOG dialogBinStock OBJECTS s = stockProp(d), b = inBin(d) CHANGE DO {}
    }
    
    setOutBin (object d) = {
        DIALOG dialogBinStock OBJECTS s = stockProp(d), b = outBin(d) CHANGE DO {}
    }
END

META setBinDocument (object, stockProp)
    @setBinObject (object, stockProp);
    @setBinObject (object###detail, stockProp);
END

META setBinDocument (object)
    @setBinDocument (###object, stock);
END

META defineBinConstraints(object, stockProp)
    CONSTRAINT inBin(object detail) AND NOT in(stockProp(detail), inBin(detail))
               CHECKED BY inBin[object] MESSAGE 'Ячейка не доступна для склада';
               
    CONSTRAINT outBin(object detail) AND NOT in(stockProp(detail), outBin(detail))
               CHECKED BY outBin[object] MESSAGE 'Ячейка не доступна для склада';
END

META defineBinConstraints(object)
    @defineBinConstraints(###object, stock);
END

META defineBinDocumentConstraints(object, stock)
    @defineBinConstraints(###object, stock);
    @defineBinConstraints(###object##Detail, stock);
END

META defineBinDocumentConstraints(object)
    @defineBinDocumentConstraints(object, stock);
END

META extendObjectFormsBins(form, forms, obj, stockProp, background) 
    EXTEND FORM form
        PROPERTIES(obj) useBins, nameInBin SHOWIF useBins(obj) ON CHANGE setInBin(obj), nameOutBin SHOWIF useBins(obj) ON CHANGE setOutBin(obj)
        PROPERTIES(d) AFTER name###stockProp(d) SHOWIF useBins(obj) BACKGROUND background(obj)
                      nameInBin ON CHANGE setInBin(d), nameOutBin ON CHANGE setOutBin(d)
    ;
    DESIGN form {
        headerExtraParams {
            NEW headerBins {
                caption = 'Ячейки';
                MOVE PROPERTY(useBins(obj));
                MOVE PROPERTY(nameInBin(obj));
                MOVE PROPERTY(nameOutBin(obj));
            }
        }
    }

    EXTEND FORM forms
        PROPERTIES(d) AFTER name###stockProp(d) READONLY SHOWIF useBins(obj) BACKGROUND background(obj)
                      nameInBin, nameOutBin
    ;
END

META defineInvoiceShipmentBins(stockProp)

    @defineDocumentBins(invoice);
    inBin [ShipmentDetail] (InvoiceShipmentDetail detail) += inBin(invoiceDetail(detail));
    outBin [ShipmentDetail] (InvoiceShipmentDetail detail) += outBin(invoiceDetail(detail));
    
    @setBinDocument(UserInvoice, stockProp);
    @defineBinConstraints(UserShipmentDetail, stockProp);
    @defineBinConstraints(UserInvoiceDetail, stockProp);      
    
    @extendObjectFormsBins(userInvoice, invoices, i, stockProp, backgroundShipped);                          

    EXTEND FORM invoiceDetails
        PROPERTIES(d) AFTER name###stockProp(d) READONLY SHOWIF useBins(d) BACKGROUND backgroundShipped(d)
                      nameInBin, nameOutBin
    ;
    
    overCopy[UserInvoiceDetail,UserInvoiceDetail](UserInvoiceDetail d, UserInvoiceDetail detail) += {      
        inBin(d) <- inBin(detail);
        outBin(d) <- outBin(detail);
    }
    
END

META deriveDocumentBinsProperty(object, readProp, writeProp, stockProp)
    writeProp (###object o) <- readProp(operation(o), stockProp(o))
        WHEN CHANGED(operation(o)) OR CHANGED(stockProp(o));    
END

META deriveFormBinsProperty (form, object)
    overInBin = ABSTRACT Bin (###object###detail);
    overOutBin = ABSTRACT Bin (###object###detail);
    
    WHEN SESSION FORMS form (CHANGED(inBin(object(###object###detail detail))) OR CHANGED(sku(detail))) AND NOT CHANGED(inBin(detail)) DO {
             inBin(detail) <- OVERRIDE inBin(object(detail)), overInBin(detail);
    }

    WHEN SESSION FORMS form (CHANGED(outBin(object(###object###detail detail))) OR CHANGED(sku(detail))) AND NOT CHANGED(outBin(detail)) DO {
        outBin(detail) <- OVERRIDE outBin(object(detail)), overOutBin(detail);
    }    
END

META deriveFormBinsProperty (object) 
    @deriveFormBinsProperty (object, object);
END

META deriveInvoiceBins (inRead, inWrite, outRead, outWrite, stockProp)
    @deriveDocumentOperationProperty(UserShipment, useBins);
    @deriveDocumentBinsProperty(UserShipment, inRead, inWrite, stockProp);
    @deriveDocumentBinsProperty(UserShipment, outRead, outWrite, stockProp);
    @deriveDocumentOperationProperty(UserInvoice, useBins);
    @deriveDocumentBinsProperty(UserInvoice, inRead, inWrite, stockProp);
    @deriveDocumentBinsProperty(UserInvoice, outRead, outWrite, stockProp);
    
    @deriveFormBinsProperty (userInvoice);
END

META deriveDocumentBins (object, form, inRead, inWrite, outRead, outWrite, stockProp)
    @deriveDocumentBinsProperty(object, inRead, inWrite, stockProp);
    @deriveDocumentBinsProperty(object, outRead, outWrite, stockProp);
    
    @deriveFormBinsProperty (form, object);
END