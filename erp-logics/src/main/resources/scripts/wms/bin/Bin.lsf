MODULE Bin;

REQUIRE Stock, Barcode, WMS;

//------------------------- Ячейка -----------------------------//


CLASS  BinGroup 'Группа ячеек';
TABLE binGroup (BinGroup);

@defineExternalizable(bin, VARSTRING[100]);

name 'Наименование' = DATA VARISTRING[100](BinGroup);

TABLE binGroupBinGroup(BinGroup, BinGroup);
@defineHierarchy(binGroup, BinGroup);

FORM binGroup 'Группа ячеек'
    OBJECTS g=BinGroup FIXED PANEL
    PROPERTIES(g) name, nameParent
    EDIT BinGroup OBJECT g
;

FORM binGroups 'Группы ячеек'
    TREE treeGroups g=BinGroup PARENT parent
    PROPERTIES READONLY name(g), canonicalName (g)
    PROPERTIES(g) NEWSESSION NEW, EDIT, deleteg=DELETE TOOLBAR
    ORDER BY canonicalName(g)
    LIST BinGroup OBJECT g
;

CLASS Bin 'Ячейка' ;
TABLE bin (Bin);

name 'Наименование' = DATA VARISTRING[100](Bin);
binGroup = DATA BinGroup (Bin) AUTOSET;
nameBinGroup 'Группа' (Bin bin) = name(binGroup(bin));

TABLE binGroupBin(BinGroup, Bin);
isParent (BinGroup binGroup, Bin bin) = isParent(binGroup(bin), binGroup);
canonicalName 'Каноническое имя' (Bin bin) = canonicalName(binGroup(bin));

FORM bin 'Ячейка'
    OBJECTS s = Bin FIXED PANEL
    PROPERTIES(s) name, id SHOWIF showIDs(), nameBinGroup
    EDIT Bin OBJECT s
;

FORM bins 'Ячейки'
    TREE binTree sg = BinGroup PARENT parent
    PROPERTIES READONLY name(sg)

    OBJECTS s = Bin
    PROPERTIES(s) READONLY name, id SHOWIF showIDs(), canonicalName
    PROPERTIES(s) NEWSESSION NEW, EDIT, DELETE TOOLBAR

    FILTERS isParent(sg, s)
    ORDER BY name(s)

    LIST Bin OBJECT s
;

DESIGN bins {
    main{
        preferredSize = (1024, 768);

        NEW topContainer {
            type = SPLITH;
            fill = 1;

            MOVE binTree.tree.box {
                caption = 'Группы ячеек';
            }

            MOVE s.box {
                fill = 2;
                s.grid {
                    defaultComponent = TRUE;
                }
            }
        }

        MOVE functions.box;
    }
}

// ----------------------------------- Ledger ------------------------------------------ //
//
//bin = ABSTRACT Bin(DataSkuLedger) PERSISTENT INDEXED;
//nameBin 'Ячейка' (DataSkuLedger ledger) = name(bin(ledger)) MINCHARWIDTH 10 PREFCHARWIDTH 10;
//
//bin (batch) = ABSTRACT Bin (Batch) PERSISTENT INDEXED;
//prevBin (Batch batch) = PREV(bin(batch));
//nameBin 'Ячейка' (Batch batch) = name(bin(batch)) MINCHARWIDTH 10 PREFCHARWIDTH 10;
//
//bin (SkuLedger ledger) = MULTI bin[DataSkuLedger] (ledger), bin[Batch] (ledger) PERSISTENT INDEXED;
//nameBin 'Ячейка' (SkuLedger ledger) = name(bin(ledger)) MINCHARWIDTH 10 PREFCHARWIDTH 10;
//
//TABLE skuBin(Sku, Bin);
//TABLE skuStockBin(Sku, Stock, Bin);
//TABLE skuStockBinDate(Sku, Stock, Bin, DATE);

META defineBinSkuLedgerBalanceProperties(postfix, caption)

    currentBalance 'Текущий остаток'###caption (sku, stock, bin) =
        GROUP SUM signedQuantityActive(SkuLedger ledger) BY sku(ledger), stock(ledger), bin(ledger) PERSISTENT;
    prevCurrentBalance 'Текущий остаток'###caption (Sku sku, Stock stock, Bin bin) = PREV(currentBalance(sku, stock, bin));
    countLedger 'Кол-во движений'###caption (sku, stock, bin) =
        GROUP SUM 1 IF signedQuantityActive(SkuLedger ledger) BY sku(ledger), stock(ledger), bin(ledger) PERSISTENT;

    quantityIn (sku, stock, bin, date) =
        GROUP SUM quantityInActive(InSkuLedger ledger) BY sku(ledger), stock(ledger), bin(ledger), date(ledger) PERSISTENT;

    quantityOut (sku, stock, bin, date) =
        GROUP SUM quantityOutActive(OutFIFOSkuLedger ledger) BY sku[SkuLedger](ledger), stock[SkuLedger](ledger), bin[SkuLedger](ledger), date[SkuLedger](ledger) PERSISTENT;

    quantity (Sku sku, Stock stock, Bin bin, DATE date) = quantityIn(sku, stock, bin, date)
                                                         (+)
                                                         quantityOut(sku, stock, bin, date) PERSISTENT;

    signedQuantity (Sku sku, Stock stock, Bin bin, DATE date) = quantityIn(sku, stock, bin, date)
                                                               (-)
                                                               quantityOut(sku, stock, bin, date) PERSISTENT;

    // без учета текущей даты/времени
    balanceB 'Остаток на начало дня'###caption (Sku sku, Stock stock, Bin bin, DATE date) = currentBalance(sku, stock, bin)
                                                                      (-) [= GROUP SUM signedQuantity (Sku sku, Stock stock, Bin bin, DATE dateIn) IF dateIn >= DATE date
                                                                                 BY sku, stock, bin, date](sku, stock, bin, date);

    // с учетом текущей даты/времени
    balanceA 'Остаток на конец дня'###caption (Sku sku, Stock stock, Bin bin, DATE date) = currentBalance(sku, stock, bin)
                                                                     (-) [= GROUP SUM signedQuantity (Sku sku, Stock stock, Bin bin, DATE dateIn) IF dateIn > DATE date
                                                                                BY sku, stock, bin, date](sku, stock, bin, date);

    // без учета текущей даты/времени
    balanceB 'Остаток (до)'###caption (Sku sku, Stock stock, Bin bin, DATETIME dateTime) = currentBalance(sku, stock, bin)
                                                                              (-) [= GROUP SUM signedQuantityActive(SkuLedger ledger) IF dateTime(ledger) >= DATETIME dateTime
                                                                                         BY sku(ledger), stock(ledger), bin(ledger), dateTime](sku, stock, bin, dateTime);

    // с учетом текущей даты/времени
    balanceA 'Остаток (после)'###caption (Sku sku, Stock stock, Bin bin, DATETIME dateTime) = currentBalance(sku, stock, bin)
                                                                             (-) [= GROUP SUM signedQuantityActive(SkuLedger ledger) IF dateTime(ledger) > DATETIME dateTime
                                                                                        BY sku(ledger), stock(ledger), bin(ledger), dateTime](sku, stock, bin, dateTime);

    currentBalance 'Остаток (всего)'###caption (sku, bin) = GROUP SUM currentBalance(Sku sku, Stock stock, Bin bin) BY sku, bin PERSISTENT;

    // ---------------------------- Суммы по товару -------------------------------- //

    currentSum 'Сумма остатка'###caption (sku, stock, bin) =
        GROUP SUM signedSumActive(SkuLedger ledger) BY sku(ledger), stock(ledger), bin(ledger) PERSISTENT;

    sumIn (sku, stock, bin, date) =
        GROUP SUM sumInActive(InSkuLedger ledger) BY sku(ledger), stock(ledger), bin(ledger), date(ledger) PERSISTENT;

    sumOut (sku, stock, bin, date) =
        GROUP SUM sumOutActive(OutSkuLedger ledger) BY sku(ledger), stock(ledger), bin(ledger), date(ledger) PERSISTENT;

    sum (Sku sku, Stock stock, Bin bin, DATE date) = sumIn(sku, stock, bin, date)
                                                         (+)
                                                         sumOut(sku, stock, bin, date) PERSISTENT;

    signedSum (Sku sku, Stock stock, Bin bin, DATE date) = sumIn(sku, stock, bin, date)
                                                               (-)
                                                               sumOut(sku, stock, bin, date) PERSISTENT;

    // без учета текущей даты/времени
    sumB 'Сумма на начало дня'###caption (Sku sku, Stock stock, Bin bin, DATE date) = currentSum(sku, stock, bin)
                                                                      (-) [= GROUP SUM signedSum (Sku sku, Stock stock, Bin bin, DATE dateIn) IF dateIn >= DATE date
                                                                                 BY sku, stock, bin, date](sku, stock, bin, date);

    // с учетом текущей даты/времени
    sumA 'Сумма на конец дня'###caption (Sku sku, Stock stock, Bin bin, DATE date) = currentSum(sku, stock, bin)
                                                                     (-) [= GROUP SUM signedSum (Sku sku, Stock stock, Bin bin, DATE dateIn) IF dateIn > DATE date
                                                                                BY sku, stock, bin, date](sku, stock, bin, date);

    averagePrice 'Цена (средневзв.)'###caption (Sku sku, Stock stock, Bin bin) = currentSum(sku, stock, bin) / currentBalance(sku, stock, bin);

END

//@defineBinSkuLedgerBalanceProperties(,);
//
//EXTEND FORM currentBalanceSkuStock
//
//    PROPERTIES(bil)   READONLY nameBin  BEFORE signedQuantity(bil)
//    PROPERTIES(bt)    READONLY nameBin  BEFORE shippedQuantity(bt)
//
//    OBJECTS           bin=Bin
//    PROPERTIES        READONLY name(bin), currentBalance(s,st,bin)
//    FILTERS           currentBalance(s,st,bin)
//;
//DESIGN currentBalanceSkuStock {
//    ledger.box {
//        MOVE bin.box;
//    }
//}
//
//EXTEND FORM balanceSkuStock
//
//    PROPERTIES(bil)   READONLY nameBin  BEFORE signedQuantity(bil)
//    PROPERTIES(bt)    READONLY nameBin  BEFORE shippedQuantity(bt)
//
//    OBJECTS           bin=Bin
//    PROPERTIES        READONLY name(bin), balanceA(s,st,bin,t)
//    FILTERS           balanceA(s,st,bin,t)
//;
//DESIGN balanceSkuStock {
//    ledger.box {
//        MOVE bin.box;
//    }
//}

//EXTEND FORM batches
//    PROPERTIES(bt) READONLY nameBin AFTER nameStock(bt)
//;
// ---------------------  Склады с указанием ячеек ----------------------- //

TABLE stockBinGroup(Stock, BinGroup);
dataIn 'Отм.' = DATA BOOLEAN (Stock, BinGroup);

TABLE stockBin(Stock, Bin);
dataIn 'Отм.' = DATA BOOLEAN (Stock, Bin);

levelParent (stock, binGroup) = GROUP MIN level(BinGroup binGroup, BinGroup parent) IF dataIn(Stock stock, parent)
                                                               BY stock, binGroup PERSISTENT;
nearestParent (Stock stock, BinGroup binGroup) =
    binGroup(binGroup, levelParent(stock, binGroup));
nearestIn (Stock stock, BinGroup binGroup) =
    dataIn(stock, nearestParent(stock, binGroup));

in 'Отм.' (Stock stock, BinGroup binGroup) = OVERRIDE nearestIn (stock, binGroup), dataIn(stock, binGroup) PERSISTENT;

in 'Отм.' (Stock stock, Bin bin) = OVERRIDE in(stock, binGroup(bin)), dataIn(stock, bin) PERSISTENT;

countIn = GROUP SUM 1 IF binGroup(Bin bin)==BinGroup group AND in(Stock stock, bin) BY stock, group;

bins 'Ячейки' (stock) = GROUP CONCAT name(Bin bin) IF in(Stock stock, bin) , ', '
                                       BY stock
                                       ORDER bin MINCHARWIDTH 20 PREFCHARWIDTH 40 PERSISTENT;
stocks 'Склады' (bin) = GROUP CONCAT name(Stock stock) IF in(stock, Bin bin) , ', '
                                       BY bin
                                       ORDER stock MINCHARWIDTH 20 PREFCHARWIDTH 40 PERSISTENT;


// ---------------- Ячейка по классификатору ------------------- //

groupType = DATA GroupType (Stock);
nameGroupType 'Тип классификатора' (Stock stock) = name(groupType(stock));

dataBin = DATA Bin (Stock, Group);
nameDataBin 'Ячейка' (Stock stock,Group group) = name(dataBin(stock,group)) MINCHARWIDTH 10 PREFCHARWIDTH 10;

dataBin = DATA Bin (Stock, Sku);
nameDataBin 'Ячейка' (Stock stock,Sku sku) = name(dataBin(stock,sku)) MINCHARWIDTH 10 PREFCHARWIDTH 10;

levelParentBin (stock, group) = GROUP MIN level(Group group, Group parent) IF dataBin(Stock stock, parent)
                                                              BY stock, group PERSISTENT;

nearestParentBin (Stock stock, Group group) = group(group, levelParentBin (stock, group));
nearestInBin  (Stock stock, Group group) =
    dataBin(stock, nearestParentBin (stock, group)) PERSISTENT;

bin (Stock stock, Group group) = OVERRIDE nearestInBin(stock, group), dataBin(stock, group) PERSISTENT;
nameBin 'Ячейка'= name(bin(Stock stock, Group group)) MINCHARWIDTH 10 PREFCHARWIDTH 10;

bin (Stock stock, Sku sku) = OVERRIDE bin(stock, group(groupType(stock), sku)), dataBin(stock, sku) PERSISTENT;
nameBin 'Ячейка'= name(bin(Stock stock, Sku sku)) MINCHARWIDTH 10 PREFCHARWIDTH 10;

CONSTRAINT dataBin(Stock stock, Group group) AND NOT in(stock, dataBin(stock, group))
           CHECKED BY dataBin[Stock,Group] MESSAGE 'Ячейка (для группы sku) не включена для склада';

CONSTRAINT dataBin(Stock stock, Sku sku) AND NOT in(stock, dataBin(stock, sku))
           CHECKED BY dataBin[Stock,Sku] MESSAGE 'Ячейка (для sku) не включена для склада';
// ------------------------------------- Формы ---------------------------------- //

FORM binStocks 'Ячейки'

    OBJECTS ts = Stock FIXED PANEL
    PROPERTIES(ts) SELECTOR name
    PROPERTIES(ts) nameGroupType
    FILTERS isCompany(ts)

    TREE binTree bg = BinGroup PARENT parent
    PROPERTIES READONLY name(bg)
    PROPERTIES(ts, bg) in
    PROPERTIES(bg) NEWSESSION NEW, EDIT, DELETE TOOLBAR

    OBJECTS b = Bin
    PROPERTIES(b) READONLY name, canonicalName
    PROPERTIES(ts, b) in
    FILTERS b IS Bin AND NOT bg IS BinGroup OR isParent(bg, b)
    ORDER BY name(b)
    PROPERTIES(b) NEWSESSION NEW, EDIT, DELETE TOOLBAR

    FILTERGROUP filters1
            FILTER 'Отмеченные ячейки' in(ts, b) 'F10'

    TREE treeGroup g=Group PARENT parent
    PROPERTIES READONLY order(g), name(g)
    FILTERS groupType(g) == groupType(ts)
    ORDER BY order(g), name(g)
    PROPERTIES(ts, g) nameBin
    FILTERGROUP inactive FILTER 'Активные' active(g) 'F5' DEFAULT

    OBJECTS s = Sku
    PROPERTIES(s) READONLY name, idBarcode
    FILTERS isParent(g, s) OR s IS Sku AND NOT g
    PROPERTIES(ts, s) nameBin
;

DESIGN binStocks {
    main{
        preferredSize = (1024, 768);

        MOVE ts.box;
        NEW topContainer {
            type = SPLITV;
            fill = 1;

            NEW binGroup {
                type = SPLITH;
                fill = 1;

                MOVE binTree.tree.box {
                    caption = 'Группы ячеек';
                }

                MOVE b.box {
                    fill = 2.5;
                    caption = 'Ячейки';
                    b.grid {
                        defaultComponent = TRUE;
                    }
                }
            }
            NEW skuGroup {
                type = SPLITH;
                fill = 1;

                MOVE treeGroup.tree.box {
                    caption = 'Группы Sku';
                }

                MOVE s.box {
                    fill = 2.5;
                    s.grid {
                        defaultComponent = TRUE;
                    }
                }
            }
        }

        MOVE functions.box;
    }
}
//--------------------------------------------------Ячейка для Detail--------------------------------------//

META defineDocumentDetailBinCustom(detail, prefix, caption)
    prefix###bin = DATA Bin (###detail);
    name###prefix##Bin 'Ячейка'###caption (###detail detail) = name(prefix###bin(detail)) MINCHARWIDTH 10 PREFCHARWIDTH 10;
END
META defineDocumentAbstractDetailBinCustom(detail, prefix, caption)
    prefix###bin = ABSTRACT Bin (###detail) PERSISTENT;
    name###prefix##Bin 'Ячейка'###caption (###detail detail) = name(prefix###bin(detail)) MINCHARWIDTH 10 PREFCHARWIDTH 10;
END
META defineDocumentInterfaceDetailBinCustom(detail, prefix, caption)
    @defineDocumentAbstractDetailBinCustom(detail, prefix, caption);
    @defineDocumentDetailBinCustom(user###detail, prefix, caption);
    prefix###bin(User###detail detail) += prefix###bin(detail);
END
META defineDocumentInterfaceDetailBinCustom(detail)
    @defineDocumentInterfaceDetailBinCustom(detail, , );
END

META defineDocumentAbstractDetailBin(object)
    @defineDocumentAbstractDetailBinCustom(object###detail, , );
END

META defineDocumentInterfaceDetailBin(object, caption)
    @defineDocumentInterfaceDetailBinCustom(object###detail, , caption);
END
META defineDocumentInterfaceDetailBin(object)
    @defineDocumentInterfaceDetailBinCustom(object###detail, , );
END

META extendFormInterfaceDetailBin(object, concrete, prefix, befProp)
    @defineDocumentInterfaceProperty (object, showBin, 'Ячейка');

    EXTEND FORM user###object
        PROPERTIES(concrete) showBin
        PROPERTIES (d) SHOWIF showBin(concrete) nameBin BEFORE befProp(d)
    ;
    DESIGN user###object {
        headerExtraParams {
            NEW headerBin {
                caption = 'Ячейка';
                type = CONTAINERH;
                MOVE PROPERTY(showBin(concrete));
            }
        }
    }
    EXTEND FORM object##s
    PROPERTIES (d) READONLY SHOWIF showBin(concrete) nameBin BEFORE befProp(d)
    ;
END

//---------------- invoiceShipment --------------------//

META defineInvoiceShipmentBin(stockProp)

    @defineDocumentInterfaceDetailBin(invoice);
    bin (InvoiceShipmentDetail detail) += bin(invoiceDetail(detail));

    @defineDocumentInterfaceProperty (invoice, showBin, 'Ячейка');

    EXTEND FORM userInvoice
        PROPERTIES(i) showBin
        PROPERTIES(d) BEFORE quantity(d) SHOWIF showBin(i) BACKGROUND backgroundShipped(i)
                      nameBin
    ;
    DESIGN userInvoice {
        headerExtraParams {
            NEW headerBin {
                caption = 'Ячейка';
                MOVE PROPERTY(showBin(i));
            }
        }
    }

    EXTEND FORM invoices
        PROPERTIES(d) READONLY BEFORE name###stockProp(d) SHOWIF showBin(i) BACKGROUND backgroundShipped(i)
                      nameBin
    ;
    EXTEND FORM invoiceDetails
        PROPERTIES(d) READONLY BEFORE name###stockProp(d) SHOWIF showBin(d) BACKGROUND backgroundShipped(d)
                      nameBin
    ;
    
    overCopy[UserInvoiceDetail,UserInvoiceDetail](UserInvoiceDetail d, UserInvoiceDetail detail) += ACTION {      
        bin(d) <- bin(detail);
    }     

END

NAVIGATOR {
    WMSNavigator {
        NEW binNavigator 'Ячейки' {
            ADD binGroups;
            ADD binStocks;
        }
    }
}



