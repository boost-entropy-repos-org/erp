MODULE Contract;

REQUIRE System, Historizable, LegalEntity, Numerator, Document, PaymentCondition, Stock;

// ---------------------------------------- Договора ------------------------------------ //

CLASS ABSTRACT Contract 'Договор';
TABLE contract (Contract);
TABLE contractDate (Contract, DATE);

GROUP contract 'Реквизиты' : recognize;

id 'Код' = ABSTRACT VARSTRING[100] (Contract) IN recognize MINCHARWIDTH 10 PREFCHARWIDTH 15 PERSISTENT ;

number 'Номер' = ABSTRACT VARSTRING[28] (Contract) IN numbered PERSISTENT MINCHARWIDTH 7;
series 'Серия' = ABSTRACT STRING[2] (Contract) IN numbered PERSISTENT FIXEDCHARWIDTH 3; 

seriesNumber 'Серия/Номер' (Contract o) = 
    CONCAT '', series(o), number(o) 
    MINCHARWIDTH 7 PREFCHARWIDTH 15 MAXCHARWIDTH 20 INDEXED PERSISTENT;

word 'Файл договора'  = ABSTRACT WORDFILE (Contract);
saveWord 'Загрузить файл договора' (Contract contract) = ACTION LOADFILE word(contract);
openWord 'Просмотреть файл договора' (Contract contract) = ACTION OPENFILE word(contract);


//numberContract 'Номер договора' = DATA STRING[30] (Contract) IN contract;
dateFrom 'Действует (с)' = DATA DATE (Contract) IN contract;
dateTo 'Действует (по)' = DATA DATE (Contract) IN contract;
active 'Действуюший' (Contract contract, DATE date) =
    dateFrom(contract) <= date AND NOT dateTo(contract) < date;

description 'Описание' (Contract contract) = CONCAT '', seriesNumber(contract),
                                                       ' от '+ toDateDDMMYYYY(dateFrom(contract));

GROUP party 'Контрагенты' : recognize;

partyA = ABSTRACT LegalEntity (Contract) PERSISTENT INDEXED;
namePartyA 'Организация (поставщик)' (Contract contract) = name(partyA(contract)) IN party;
addressPartyA 'Адрес организация (поставщик)' (Contract contract) = address(partyA(contract)) IN party;

partyB = ABSTRACT LegalEntity (Contract) PERSISTENT INDEXED;
namePartyB 'Организация (покупатель)' (Contract contract) = name(partyB(contract)) IN party;
addressPartyB 'Адрес организация (покупатель)' (Contract contract) = address(partyB(contract)) IN party;

countContract 'Кол-во договоров' (partyA, partyB) =
    GROUP SUM 1 IF partyA(Contract contract) == LegalEntity partyA AND partyB(contract) == LegalEntity partyB BY partyA, partyB;

TABLE stockContract (Stock, Contract);

inPartyA 'Вкл.'  = ABSTRACT BOOLEAN (Stock, Contract) PERSISTENT INDEXED;
inPartyB 'Вкл.' = ABSTRACT BOOLEAN (Stock, Contract) PERSISTENT INDEXED;

namePartyAStocks 'Склады поставщика' (contract) = GROUP CONCAT name(Stock stock) IF inPartyA(stock, Contract contract) , ', '
                                                 BY contract
                                                 ORDER stock MINCHARWIDTH 30 PREFCHARWIDTH 50 PERSISTENT;
namePartyBStocks 'Склады покупателя' (contract) = GROUP CONCAT name(Stock stock) IF inPartyB(stock, Contract contract) , ', '
                                                 BY contract
                                                 ORDER stock MINCHARWIDTH 30 PREFCHARWIDTH 50 PERSISTENT;

countContract 'Кол-во договоров' (partyA, stockA, partyB, stockB) =
    GROUP SUM 1 IF inPartyA(Stock stockA, Contract contract) AND inPartyB(Stock stockB, contract) BY partyA(contract), stockA, partyB(contract), stockB;

GROUP payment 'Оплата' : public;

//договор по умолчанию
isDefault 'По умолчанию' = ABSTRACT BOOLEAN (Contract) IN party;
  
// Валюты
currency = DATA Currency (Contract);
nameCurrency 'Валюта взаиморасчетов' (Contract contract) = name(currency(contract)) IN payment;
shortNameCurrency 'Валюта взаиморасчетов' (Contract contract) = shortName(currency(contract)) IN payment;
symbolCurrency 'Символ' (Contract contract) = symbol(currency(contract)) IN payment;

typeExchange (contract) = DATA TypeExchange (Contract);
nameTypeExchange 'Тип обмена' (Contract contract) = name(typeExchange(contract)) IN payment;

CONSTRAINT currency(Contract contract) != currency(typeExchange(contract))
    CHECKED BY typeExchange[Contract] MESSAGE 'Валюта типа обмена должна соответствовать валюте договора';

// Условия оплаты
paymentCondition 'Условия оплаты' =  DATA PaymentCondition (Contract);
typePayment 'Тип оплаты' (Contract contract) = type(paymentCondition(contract));
descriptionPaymentCondition 'Условия оплаты' (Contract contract) = description(paymentCondition(contract)) IN payment;
shortDescriptionPaymentCondition 'Условия оплаты' (Contract contract) = shortDescription(paymentCondition(contract)) IN payment;

note 'Примечание' = DATA VARSTRING[100] (Contract) MINCHARWIDTH 20 PREFCHARWIDTH 30;

edit 'Редактировать' (contract) = ACTION ABSTRACT LIST (Contract) IMAGE 'edit.png' EDITKEY 'BACK_SPACE' HIDE TOOLBAR;

FORM contracts 'Договоры'
    OBJECTS c = Contract
    PROPERTIES(c) READONLY namePartyA, namePartyAStocks, namePartyB, namePartyBStocks, id SHOWIF showIDs(),
                           seriesNumber, dateFrom, dateTo, isDefault, nameCurrency, 
                           nameTypeExchange, descriptionPaymentCondition, note
    PROPERTIES(c) edit, DELETE FORCE PANEL TOOLBAR

    DIALOG Contract OBJECT c
;

DESIGN options {
    pane{
        NEW contract {
            caption = 'Договор';
        }
    }
}

contractSupplier= DATA LOCAL LegalEntity();
nameContractSupplier 'Поставщик' = name(contractSupplier()) MINCHARWIDTH 15 PREFCHARWIDTH 20;

contractCustomer= DATA LOCAL LegalEntity();
nameContractCustomer 'Покупатель' = name(contractCustomer()) MINCHARWIDTH 15 PREFCHARWIDTH 20;

FORM contractDialog 'Договоры'
    OBJECTS dt = DATE FIXED PANEL 
    PROPERTIES val = OBJVALUE (dt)
    PROPERTIES nameContractSupplier(), nameContractCustomer() 
    
    OBJECTS c = Contract
    PROPERTIES(c) READONLY namePartyA, namePartyAStocks, namePartyB, namePartyBStocks, 
                           seriesNumber, dateFrom, dateTo, isDefault, nameCurrency, 
                           nameTypeExchange, descriptionPaymentCondition, note
    FILTERS partyA(c) == contractSupplier() OR c IS Contract AND NOT contractSupplier(),
            partyB(c) == contractCustomer() OR c IS Contract AND NOT contractCustomer()
    FILTERGROUP active 
        FILTER 'Активные' dateFrom(c) <= dt AND NOT dateTo(c) < dt 'F5' DEFAULT      
;
DESIGN contractDialog {
    main {
        preferredSize = (1024, 768);
        NEW top {
            type = CONTAINERH;
            caption = 'Шапка';
            MOVE PROPERTY (val) {caption = 'Дата';}
            MOVE PROPERTY(nameContractSupplier());
            MOVE PROPERTY(nameContractCustomer());
        }
        MOVE c.box;
        MOVE functions.box;
    }
}

// ------------------------------------ Макрос для создания договоров по умолчанию ----------------------------- //

//META defineContractDefault (contract, partyA, partyB)
//    @defineContractDefault (contract, ###partyA, ###partyB, partyA, partyB);
//END

META defineContractDefault (contract, partyAClass, stockAClass, partyBClass, stockBClass, prefixA, prefixB)
    @defineContractDefault(contract, ###contract, partyAClass, stockAClass, partyBClass, stockBClass, prefixA, prefixB);
END

META defineContractDefault (contract, contractClass, partyAClass, stockAClass, partyBClass, stockBClass, prefixA, prefixB)

    isDataDefault 'По умолчанию' = DATA BOOLEAN (###contract);
    isDefault(###contract contract) += isDataDefault(contract);
    
    count###contract###prefixA###prefixB (pA, pB, dateIn)= GROUP SUM 1 
        IF dateFrom(###contract contract) <= DATE dateIn AND NOT dateTo(contract) < dateIn
            BY prefixA(contract), prefixB(contract), dateIn;

    single###contract###prefixA###prefixB (pA, pB, dateIn) = GROUP MAX (###contract contract) 
        IF dateFrom(contract) <= DATE dateIn AND NOT dateTo(contract) < dateIn
            BY prefixA(contract), prefixB(contract), dateIn;

    default###contract###prefixA###prefixB (pA, pB, dateIn) = GROUP MAX (###contract contract) IF isDataDefault(contract) 
        AND dateFrom(contract) <= DATE dateIn AND NOT dateTo(contract) < dateIn
            BY prefixA(contract), prefixB(contract), dateIn;
        
    default###contract###prefixA###prefixB (sA, sB, dateIn) = GROUP MAX (###contract contract) 
        IF in###prefixA(stockAClass sA,contract) AND in###prefixB(stockAClass sB,contract)
        AND dateFrom(contract) <= DATE dateIn AND NOT dateTo(contract) < dateIn
            BY sA, sB, dateIn;
            
    default###contract###prefixA (pA, sA, dateIn) = GROUP MAX (###contract contract) 
        IF in###prefixA(stockAClass sA,contract) //AND inCustomerStockContractSku(sB,contract)
        AND dateFrom(contract) <= DATE dateIn AND NOT dateTo(contract) < dateIn
            BY prefixA(contract), sA, dateIn;      
                  
    count###contract###prefixA (pA, sA, dateIn) = GROUP SUM 1 
        IF in###prefixA(stockAClass sA,###contract contract) //AND inCustomerStockContractSku(sB,contract)
        AND dateFrom(contract) <= DATE dateIn AND NOT dateTo(contract) < dateIn
            BY prefixA(contract), sA, dateIn;  
                                
    default###contract###prefixA###prefixB (pA, sA, pB, dateIn) = GROUP MAX (###contract contract) 
        IF in###prefixA(stockAClass sA,contract) //AND inCustomerStockContractSku(sB,contract)
        AND dateFrom(contract) <= DATE dateIn AND NOT dateTo(contract) < dateIn
            BY prefixA(contract), sA, prefixB(contract), dateIn;      
                  
    count###contract###prefixA###prefixB (pA, sA, pB, dateIn) = GROUP SUM 1 
        IF in###prefixA(stockAClass sA,###contract contract) //AND inCustomerStockContractSku(sB,contract)
        AND dateFrom(contract) <= DATE dateIn AND NOT dateTo(contract) < dateIn
            BY prefixA(contract), sA, prefixB(contract), dateIn;
            
    default###contract###prefixA###prefixB (pA, sB, dateIn) = GROUP MAX (###contract contractSku) 
        IF in###prefixB(stockAClass sB,contract)
        AND dateFrom(contractSku) <= DATE dateIn AND NOT dateTo(contractSku) < dateIn
            BY prefixA(contractSku), sB, dateIn;    
                  
END

META defineDocumentContract (objectClass, contractType, prefixA, prefixB, partyAMessage, partyBMessage, caption, NS)
    @defineDocumentContract (objectClass, contractType, prefixA, prefixB, default###contractType###prefixA###prefixB, partyAMessage, partyBMessage, caption, NS);
END

META defineDocumentContract (objectClass, contractType, prefixA, prefixB, defaultContractProp, partyAMessage, partyBMessage, caption, NS)
    @defineDocumentContract (objectClass, contractType, ###contractType, prefixA, prefixB, defaultContractProp, partyAMessage, partyBMessage, caption, NS);
END

META defineDocumentContract (objectClass, contractType, contractTypeClass, prefixA, prefixB, defaultContractProp, partyAMessage, partyBMessage, caption, NS)
    contractType = DATA contractTypeClass (objectClass);
    number###contractType 'Договор (номер)' (objectClass o) = number[Contract](contractType(o)) IN documentPrm;
    seriesNumber###contractType 'Договор (серия/номер)' (objectClass o) = seriesNumber[Contract](contractType(o)) IN documentPrm;
    dateFrom###contractType 'Дата договора' (objectClass o) = dateFrom(contractType(o)) IN documentPrm;

    description###contractType 'Описание договора' (objectClass o)= CONCAT ' ', seriesNumber###contractType(o), ' от ' + dateFrom###contractType(o);

    isCommission 'Продажа на комиссию' = DATA BOOLEAN (objectClass) IN documentPrm;
    isCommission(objectClass o) <- type(contractType(o)) == ContractSkuType.commission
        WHEN CHANGED(contractType(o));

    skipSet###contractType = ABSTRACT BOOLEAN (###objectClass);
    WHEN SESSION (CHANGED(prefixA(objectClass o)) OR CHANGED(prefixB(o)) OR CHANGED(prefixA##Stock(o))
                OR CHANGED(prefixB##Stock(o)) OR CHANGED(date(o))) AND NOT CHANGED(contractType(o)) AND NOT skipSet###contractType(o) NOINLINE DO {
                
        contractType(o) <- OVERRIDE single###contractType###prefixA###prefixB(prefixA(o), prefixB(o), date(o)) IF count###contractType###prefixA###prefixB(prefixA(o), prefixB(o), date(o)) == 1,
                                                 defaultContractProp(prefixA(o), prefixB(o), date(o)),
                                                 defaultContractProp(prefixA##Stock(o), prefixB##Stock(o), date(o)); 
    }

    CONSTRAINT contractType(objectClass o) AND NOT prefixA(o) == partyA(contractType(o))
        CHECKED BY contractType[objectClass] MESSAGE partyAMessage;

    CONSTRAINT contractType(objectClass o) AND NOT prefixB(o) == partyB(contractType(o))
        CHECKED BY contractType[objectClass] MESSAGE partyBMessage;
    
    dateFromConstraintContract##objectClass 'Дата начала контроля сроков договора '##caption = DATA DATE ();  
    
    EXTEND FORM options 
        PROPERTIES NS###dateFromConstraintContract##objectClass = dateFromConstraintContract##objectClass()    
    ;
        
    DESIGN options {
        contract {
            MOVE PROPERTY(NS###dateFromConstraintContract##objectClass);
        }
    }      
        
    CONSTRAINT contractType(objectClass o) AND NOT (dateFrom(contractType(o)) <= date(o) 
               AND NOT (dateTo(contractType(o)) < date(o))) AND NOT (dateFromConstraintContract##objectClass() > date(o))
               CHECKED BY contractType[objectClass]
               MESSAGE 'Договор просрочен или еще не действует';
                  
    CONSTRAINT contractType(objectClass o) AND count###prefixA##sStock(contractType(o)) AND NOT in###prefixA(prefixA##Stock(o),contractType(o))
        CHECKED BY contractType[objectClass] MESSAGE 'Для документа выбран склад поставщика, который не включен в договор';        
                  
    CONSTRAINT contractType(objectClass o) AND count###prefixB##sStock(contractType(o)) AND NOT in###prefixB(prefixB##Stock(o),contractType(o))
        CHECKED BY contractType[objectClass] MESSAGE 'Для документа выбран склад покупателя, который не включен в договор';                    
                  
END

META defineDocumentAbstractContract (objectClass, contractType)
    @defineDocumentAbstractContract(objectClass, contractType, ###contractType);
END

META defineDocumentAbstractContract (objectClass, contractType, contractTypeClass)
    contractType = ABSTRACT contractTypeClass (objectClass) PERSISTENT INDEXED;
    seriesNumber###contractType 'Номер договора' (objectClass o) = seriesNumber[Contract](contractType(o)) IN documentPrm;
    dateFrom###contractType 'Дата договора' (objectClass o) = dateFrom(contractType(o)) IN documentPrm;
    
    description###contractType 'Описание договора' (objectClass o)= CONCAT ' ', seriesNumber###contractType(o), ' от ' + dateFrom###contractType(o);

    isCommission 'Продажа на комиссию' = ABSTRACT BOOLEAN (objectClass) PERSISTENT IN documentPrm;
END
META defineDocumentInterfaceContract (objectClass, contractType, prefixA, prefixB, partyAMessage, partyBMessage, caption, NS)
    @defineDocumentAbstractContract(objectClass, contractType);
    @defineDocumentContract(User###objectClass, contractType, prefixA, prefixB, partyAMessage, partyBMessage, caption, NS);
    contractType(User##objectClass o) += contractType(o);
    isCommission(User##objectClass o) += isCommission(o);
END