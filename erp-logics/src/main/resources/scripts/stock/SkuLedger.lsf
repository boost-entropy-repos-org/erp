MODULE SkuLedger;

REQUIRE Stock, Sku, EmployeeStock;

NAMESPACE Stock;

// ----------------------------------- Ledger ------------------------------------------ //

CLASS ABSTRACT SkuLedger 'Изменение остатка по товару';
TABLE skuLedger (SkuLedger);
isSkuLedger (l) = l IS SkuLedger PERSISTENT;

CLASS ABSTRACT InSkuLedger 'Приход' : SkuLedger;
CLASS ABSTRACT OutSkuLedger 'Расход' : SkuLedger;

CLASS ABSTRACT Batch 'Партия' : InSkuLedger;

CLASS ABSTRACT DataSkuLedger 'Изменение остатка с первичной себестоимостью' : SkuLedger;

CLASS ABSTRACT InLIFOSkuLedger 'Приход по LIFO' : InSkuLedger, DataSkuLedger;
CLASS ABSTRACT OutFIFOSkuLedger 'Расход по FIFO' : OutSkuLedger, DataSkuLedger;

editSkuLedger 'Редактировать' = ABSTRACT ACTION LIST (SkuLedger) IMAGE 'edit.png' EDITKEY 'BACK_SPACE' HIDE TOOLBAR;
replaceSkuBatch = ABSTRACT ACTION LIST (Sku, Batch);
// --------------------------------- Партии ------------------------------------------------ //

TABLE batch(Batch);
TABLE skuLedgerBatch (SkuLedger, Batch);
TABLE batchStock(Batch, Stock);

dateTimeBatch 'Дата/время' (batch) = ABSTRACT DATETIME (Batch) PERSISTENT INDEXED;
dateBatch 'Дата' (batch) = toDate(dateTimeBatch(batch));
timeBatch 'Время' (batch) = toTime(dateTimeBatch(batch));

isPostedBatch 'Проведен' (batch) = ABSTRACT BOOLEAN (Batch) PERSISTENT;

skuBatch (batch) = ABSTRACT Sku (Batch) PERSISTENT INDEXED;
nameSkuBatch 'Наименование' (batch) = nameSku(skuBatch(batch)) IN recognize;

// Наименование для документов
overDocumentNameSkuBatch = ABSTRACT VARISTRING[255] (Batch) PERSISTENT;
documentNameSkuBatch 'Наименование (для документов)' (batch) = OVERRIDE nameSkuBatch(batch), overDocumentNameSkuBatch(batch);

useDocumentNameSku 'Использовать наименование для документов' = DATA BOOLEAN ();

EXTEND FORM options
    PROPERTIES() useDocumentNameSku
;

EXTEND DESIGN options {
    pane {
        stock {
            ADD PROPERTY(useDocumentNameSku());
        }
    }
}

lastBatchSku (sku) = GROUP LAST batch 
    BY skuBatch(batch)
    ORDER dateTimeBatch(batch), batch
    WHERE dateTimeBatch(batch);

netWeightSkuBatch 'Вес нетто' (batch) = netWeightSku(skuBatch(batch));
grossWeightSkuBatch 'Вес брутто' (batch) = grossWeightSku(skuBatch(batch));
prevNameSkuBatch 'Наименование' (batch) = PREV(nameSku(skuBatch(batch))) IN recognize;
activeSkuBatch 'Активные' (batch) = activeSku(skuBatch(batch));

UOMBatch(batch)= UOMSku(skuBatch(batch));
shortNameUOMBatch 'Единица измерений' (batch)= shortNameUOMSku(skuBatch(batch));

countryBatch (batch) = countrySku(skuBatch(batch));
sidOrigin2CountryBatch (batch) = sidOrigin2Country(countryBatch(batch));

stockBatch (batch) = ABSTRACT Stock (Batch) PERSISTENT INDEXED ;
nameStockBatch 'Склад' (batch) = nameStock(stockBatch(batch));

costBatch 'Себестоимость' (batch) = ABSTRACT NUMERIC[14,2] (Batch) PERSISTENT;
prevCostBatch 'Себестоимость' (batch) = PREV(costBatch(batch));

descriptionBatch 'Описание' (batch) = ABSTRACT VARSTRING[200] (Batch) PERSISTENT IN recognize MINCHARWIDTH 30 PREFCHARWIDTH 60;
nameBatch 'Название' (batch) = ABSTRACT VARISTRING[200] (Batch) PERSISTENT IN recognize MINCHARWIDTH 30 PREFCHARWIDTH 60;

expiryDateBatch 'Годен до' (batch) = ABSTRACT DATE (Batch) PERSISTENT INDEXED;
prevExpiryDateBatch 'Годен до' (batch) = PREV(expiryDateBatch(batch));

manufactureDateBatch 'Дата изготовления' (batch) = ABSTRACT DATE (Batch) PERSISTENT INDEXED;
prevManufactureDateBatch 'Дата изготовления' (batch) = PREV(manufactureDateBatch(batch));

numberBatch 'Номер документа' = ABSTRACT STRING[18] (Batch) MINCHARWIDTH 8 PERSISTENT;
seriesBatch 'Серия документа' = ABSTRACT STRING[2] (Batch) FIXEDCHARWIDTH 3 PERSISTENT;

supplierBatch = ABSTRACT LegalEntity (Batch) PERSISTENT;
prevSupplierBatch (batch) = PREV(supplierBatch(batch));

nameSupplierBatch 'Поставщик' (batch) = nameLegalEntity(supplierBatch(batch));
idSupplierBatch 'Код поставщика' (batch) = idLegalEntity(supplierBatch(batch));
addressSupplierBatch 'Адрес поставщика' (batch) = addressLegalEntity(supplierBatch(batch));

supplierGroupBatch (batch) = legalEntityGroupLegalEntity(supplierBatch(batch));

supplierStockBatch = ABSTRACT Stock (Batch) PERSISTENT;
nameSupplierStockBatch 'Склад поставщика' (batch) = nameStock(supplierStockBatch(batch));

idBatch 'Код партии' (batch) = ABSTRACT VARSTRING[100] (Batch) PERSISTENT MINCHARWIDTH 10 PREFCHARWIDTH 15;
batchId (id) = GROUP MAX batch BY idBatch (batch);

expiresBatchDateTime(batch, dateTime, period) = expiryDateBatch(batch) < sumDate(toDate(dateTime), period);
expiresBatchDate(batch, date, period) = expiryDateBatch(batch) < sumDate(date, period);

orderBatch (batch) = STRUCT(dateTimeBatch(batch), batch) PERSISTENT;

isSkuBatch (batch, sku) = skuBatch(batch) == sku;

isParentSkuGroupBatch (skuGroup, batch) = isParentSkuGroupSku(skuGroup, skuBatch(batch));
isParentGroupBatch (group, batch) = isParentGroupSku(group, skuBatch(batch));

isContainerBatch 'Тара' (batch) = isContainerSku(skuBatch(batch));

batchSkuLedger = ABSTRACT Batch (SkuLedger) PERSISTENT;
nameBatchSkuLedger 'Партия' (l) = nameBatch(batchSkuLedger(l));

//---------------------------- Количественные регистры (конкретная реализация) ----------------------------------------//

dateTimeDataSkuLedger 'Дата/время' = ABSTRACT DATETIME (DataSkuLedger) PERSISTENT INDEXED;
dateDataSkuLedger 'Дата' (ledger) = toDate(dateTimeDataSkuLedger(ledger)) PERSISTENT;

isPostedDataSkuLedger 'Проведен' = ABSTRACT BOOLEAN (DataSkuLedger) PERSISTENT;

skuDataSkuLedger = ABSTRACT Sku (DataSkuLedger) PERSISTENT INDEXED;

stockDataSkuLedger = ABSTRACT Stock(DataSkuLedger) PERSISTENT INDEXED;

descriptionDataSkuLedger 'Название документа' = ABSTRACT VARSTRING[200] (DataSkuLedger) PERSISTENT;

changedDataSkuLedger = ABSTRACT BOOLEAN (DataSkuLedger);

// -------------------------------- Для всего ledger'а -------------------- //

dateTimeSkuLedger 'Дата/время' (ledger) = MULTI dateTimeDataSkuLedger (ledger), dateTimeBatch (ledger) PERSISTENT INDEXED;
dateSkuLedger 'Дата' (ledger) = toDate(dateTimeSkuLedger(ledger)) PERSISTENT INDEXED;

isPostedSkuLedger 'Проведен' (ledger) = MULTI isPostedDataSkuLedger (ledger), isPostedBatch (ledger) PERSISTENT;

skuSkuLedger (ledger) = MULTI skuDataSkuLedger (ledger), skuBatch (ledger) PERSISTENT INDEXED;
nameSkuSkuLedger 'SKU' (ledger) = nameSku(skuSkuLedger(ledger));

canonicalNameSkuGroupSkuLedger 'Группа' (ledger) = canonicalNameGroup(skuGroupSku(skuSkuLedger(ledger)));

countSkuLedgerSku = GROUP SUM 1 BY skuSkuLedger(ledger) PERSISTENT;

stockSkuLedger (ledger) = MULTI stockDataSkuLedger (ledger), stockBatch (ledger) PERSISTENT INDEXED;
nameStockSkuLedger 'Склад' (ledger) = nameStock(stockSkuLedger(ledger));
isCompanyStockSkuLedger (ledger) = isCompanyStock(stockSkuLedger(ledger));
idStockSkuLedger (ledger) = idStock(stockSkuLedger(ledger));

descriptionSkuLedger 'Описание' (ledger) = MULTI descriptionDataSkuLedger (ledger), descriptionBatch (ledger) PERSISTENT;


// -------------------------------- Количества ---------------------------- //

quantityBatch 'Кол-во в партии' = ABSTRACT NUMERIC[14,3] (Batch) PERSISTENT;

extraShippedQuantityBatch = ABSTRACT NUMERIC[14,3] (Batch);
shippedQuantityBatch 'Кол-во в партии (всего)' (batch) = quantityBatch(batch) (+) extraShippedQuantityBatch(batch) PERSISTENT;

quantityInLIFOSkuLedger 'Кол-во' (ledger) = ABSTRACT NUMERIC[14,3] (InLIFOSkuLedger) PERSISTENT;

quantityInSkuLedger 'Кол-во' (ledger) = MULTI quantityBatch(ledger),
                                              quantityInLIFOSkuLedger(ledger) PERSISTENT;

quantityOutFIFOSkuLedger 'Кол-во' = ABSTRACT NUMERIC[14,3] (OutFIFOSkuLedger) PERSISTENT;

quantityOutSkuLedger 'Кол-во' (ledger) = MULTI quantityOutFIFOSkuLedger(ledger) PERSISTENT;

quantityDataSkuLedger 'Кол-во' (ledger) = MULTI quantityInLIFOSkuLedger(ledger),
                                                quantityOutFIFOSkuLedger(ledger) PERSISTENT;

quantitySkuLedger 'Кол-во' (ledger) = MULTI quantityInSkuLedger(ledger),
                                            quantityOutSkuLedger(ledger) PERSISTENT;

signedQuantitySkuLedger 'Кол-во' (ledger) = MULTI quantityInSkuLedger(ledger),
                                                  -quantityOutSkuLedger(ledger) PERSISTENT;

// -------------------------------------------- Расчет себестоимости -------------------------------------- //

explicitBatchLedgerStock 'Партионный учет' = ABSTRACT BOOLEAN (Stock) PERSISTENT IN bookkeeping;
CONSTRAINT explicitBatchLedgerStock(stockSkuLedger(l)) AND NOT batchSkuLedger(l)
    MESSAGE 'Не выбрана партия для строки движения товара';

orderDataSkuLedger (ledger) = STRUCT(dateTimeDataSkuLedger(ledger), ledger);

// Формулы для расчета
quantityBatchBatch 'Кол-во' (ledger, batch) = quantityBatch(ledger) IF batch == ledger;

limitInLIFOSkuLedgerBatch = ABSTRACT NUMERIC[14,3] (InLIFOSkuLedger, Batch);
orderInLIFOSkuLedgerBatch = ABSTRACT LONG (InLIFOSkuLedger, Batch);

quantityInLIFOSkuLedgerBatch (ledger, batch) =
        PARTITION UNGROUP quantityInLIFOSkuLedger
                  LIMIT STRICT limitInLIFOSkuLedgerBatch(ledger, batch) IF skuBatch(batch) == skuDataSkuLedger(ledger)
                  BY ledger
                  ORDER DESC orderInLIFOSkuLedgerBatch(ledger, batch), orderBatch(batch);

limitOutFIFOSkuLedgerBatch = ABSTRACT NUMERIC[14,3] (OutFIFOSkuLedger, Batch);
orderOutFIFOSkuLedgerBatch = ABSTRACT LONG (OutFIFOSkuLedger, Batch);

quantityOutFIFOSkuLedgerBatch (ledger, batch) =
        PARTITION UNGROUP quantityOutFIFOSkuLedger
                  LIMIT STRICT limitOutFIFOSkuLedgerBatch(ledger, batch) IF skuBatch(batch) == skuDataSkuLedger(ledger)
                  BY ledger
                  ORDER orderOutFIFOSkuLedgerBatch(ledger, batch), orderBatch(batch);

quantityDataSkuLedgerBatch (ledger, batch) = MULTI quantityInLIFOSkuLedgerBatch(ledger, batch),
                                                   quantityOutFIFOSkuLedgerBatch(ledger, batch);

// Свойства для расчета себестоимости

costDataSkuLedgerBatch 'Расписано из партии (перв.)' (ledger, batch) = DATA NUMERIC[14,3] (DataSkuLedger, Batch);

costSkuLedgerBatch 'Расписано из партии' (ledger, batch) = MULTI quantityBatchBatch(ledger, batch),
                                                                 costDataSkuLedgerBatch(ledger, batch) PERSISTENT;

maxBatchCostSkuLedger 'Последняя партия, из которой расписано' (ledger) = GROUP MAX batch IF  costSkuLedgerBatch(ledger, batch) BY ledger;
countBatchCostSkuLedger 'Кол-во партий' (ledger) = GROUP SUM 1 IF costSkuLedgerBatch(ledger, batch) BY ledger;


signedCostSkuLedgerBatch (ledger, batch) = IF ledger IS OutSkuLedger
                                              THEN -costSkuLedgerBatch(ledger, batch)
                                              ELSE costSkuLedgerBatch(ledger, batch);

// Расчет себестоимости по Action
costedDataSkuLedger 'Расписано' (ledger) = GROUP SUM costDataSkuLedgerBatch (ledger, batch) BY ledger PERSISTENT;
costedSkuLedger 'Расписано' (ledger) = GROUP SUM costSkuLedgerBatch (ledger, batch) BY ledger PERSISTENT;

needToCostDataSkuLedger 'Требуется расчет себестоимости' (ledger) = quantitySkuLedger(ledger) > 0 AND isPostedDataSkuLedger(ledger)
                                                                        AND NOT quantitySkuLedger(ledger) == costedDataSkuLedger(ledger);

resetCostDataSkuLedger 'Перерассчитать себестоимость' = ACTION (ledger) { //NEWSESSION AUTOAPPLY {
    ASSIGN costDataSkuLedgerBatch(ledger, batch) <- NULL;
    ASSIGN costDataSkuLedgerBatch(ledger, batch) <- quantityDataSkuLedgerBatch(ledger, batch);
}

iterate(i, from, to) = RECURSION i==from AND from IS INTEGER AND to IS INTEGER STEP i==$i+1 AND i<=to CYCLES IMPOSSIBLE;

// мгновенный расчет себестоимости
//WHEN SET(isPostedDataSkuLedger(ledger)) DO EXEC resetCostDataSkuLedger (ledger) ORDER orderDataSkuLedger(ledger);
changedCostDataSkuLedger 'Перерасчитывалась себестоимость' = DATA SESSION BOOLEAN (DataSkuLedger);

changedLedger = DATA SESSION BOOLEAN (DataSkuLedger);
updateDataSkuLedgerBatchCost() = ACTION {
    ASSIGN costDataSkuLedgerBatch(ledger, batch) <- NULL WHERE changedLedger(ledger);

    LOCAL orderedLedger = INTEGER (DataSkuLedger);
    ASSIGN orderedLedger(ledger) <- PARTITION SUM 1 IF changedLedger(ledger) BY skuDataSkuLedger(ledger) ORDER orderDataSkuLedger(ledger);

    FOR iterate(i, 1, [= GROUP MAX orderedLedger(ledger)]()) DO {
        ASSIGN changedCostDataSkuLedger(ledger) <- TRUE WHERE orderedLedger(ledger) == i;
        ASSIGN costDataSkuLedgerBatch(ledger, batch) <- quantityDataSkuLedgerBatch(ledger, batch) WHERE orderedLedger(ledger) == i;
    }
}

ON { // eventChangeLedger - так как внутрь рекурсивного события толь
    LOCAL eventChangedLedger = BOOLEAN (DataSkuLedger); 
    ASSIGN eventChangedLedger(ledger) <- SET(isPostedDataSkuLedger(ledger)) OR ((
                                  CHANGED(quantityDataSkuLedger(ledger))
                                  OR CHANGED(skuDataSkuLedger(ledger))
                                  OR CHANGED(batchSkuLedger(ledger))
                                  OR CHANGED(stockDataSkuLedger(ledger))
                                  OR CHANGED(changedDataSkuLedger(ledger)))
                                 AND isPostedDataSkuLedger(ledger));

    IF [= GROUP MAX eventChangedLedger(ledger)]() THEN
        NEWSESSION(eventChangedLedger) SINGLE {
            changedLedger(ledger) <- eventChangedLedger(ledger);
            updateDataSkuLedgerBatchCost();
        }
}

setDataSkuLedgerBatchCost 'Дорассчитать себестоимость' = ACTION () NEWSESSION {
    APPLY SINGLE { 
        changedLedger(ledger) <- needToCostDataSkuLedger(ledger);
        updateDataSkuLedgerBatchCost();
    }
} CONFIRM;

resetDataSkuLedgerBatchCost 'Перерассчитать себестоимость' = ACTION () NEWSESSION {
    FORM dialogDate MODAL;
    IF formResult() == FormResult.ok THEN {

        FOR d == chosenDate('d') DO {
            APPLY SINGLE { 
                changedLedger(ledger) <- dateSkuLedger(ledger) >= d AND isPostedDataSkuLedger(ledger);
                updateDataSkuLedgerBatchCost();
            }
        }
    }
} CONFIRM;

clearDataSkuLedgerBatchCost 'Сбросить всю себестоимость' = ACTION() NEWSESSION AUTOAPPLY {
    ASSIGN costDataSkuLedgerBatch(ledger, batch) <- NULL;
} CONFIRM;

// Суммы

costSumSkuLedgerBatch 'Сумма поставщика без НДС' (ledger, batch) = NUMERIC[16,3](costSkuLedgerBatch(ledger, batch) * costBatch(batch));
costSumSkuLedger 'Сумма поставщика без НДС' = GROUP SUM costSumSkuLedgerBatch(ledger, batch) BY ledger;

// ---------------------------- Учетные цены и суммы ------------------------------- //

// сумма операции
sumInSkuLedger 'Сумма' (ledger) = ABSTRACT NUMERIC[16,2] (InSkuLedger) PERSISTENT;
sumOutSkuLedger 'Сумма' (ledger) = ABSTRACT NUMERIC[16,2] (OutSkuLedger) PERSISTENT;

sumSkuLedger 'Сумма' = MULTI sumInSkuLedger(ledger),
                             sumOutSkuLedger(ledger) PERSISTENT;
                              
signedSumSkuLedger 'Сумма' (ledger) = MULTI sumInSkuLedger(ledger),
                                            -sumOutSkuLedger(ledger) PERSISTENT;
                                            
signedPriceSkuLedger 'Цена' (ledger)= signedSumSkuLedger(ledger)/signedQuantitySkuLedger(ledger) IF NOT signedQuantitySkuLedger(ledger) == 0.0;                                            

// ---------------------------- Остаток по товару -------------------------------- //

TABLE skuStock(Sku, Stock);
TABLE skuStockDate(Sku, Stock, DATE);
TABLE batchStockDate(Batch, Stock, DATE);

TABLE skuGroupStock(SkuGroup, Stock);
TABLE skuStockGroup(Sku, StockGroup);

META defineSkuLedgerBalanceProperties(postfix, caption)
    skip##postfix##SkuLedger 'Не проводить по учету'###caption = ABSTRACT BOOLEAN (SkuLedger) PERSISTENT;
    active##postfix##SkuLedger 'Активен'###caption (ledger) = isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;

    signedQuantityActive##postfix##SkuLedger(ledger) = signedQuantitySkuLedger(ledger) IF active##postfix##SkuLedger(ledger) PERSISTENT;

    currentBalance##postfix##SkuStock 'Текущий остаток'###caption (sku, stock) =
        GROUP SUM signedQuantityActive##postfix##SkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger) PERSISTENT;
    prevCurrentBalance##postfix##SkuStock 'Текущий остаток'###caption (sku, stock) = PREV(currentBalance##postfix##SkuStock(sku, stock));
    prevCurrentBalance##postfix##Sku 'Текущий остаток'###caption (sku) = GROUP SUM prevCurrentBalance##postfix##SkuStock(sku, stock) BY sku;
    countLedger##postfix##SkuStock 'Кол-во движений'###caption (sku, stock) =
        GROUP SUM 1 IF signedQuantityActive##postfix##SkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger) PERSISTENT;

    quantityInActiveSkuLedger(ledger) = quantityInSkuLedger(ledger) IF isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;
    quantityIn##postfix##SkuStockDate (sku, stock, date) =
        GROUP SUM quantityInActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT;

    quantityOutActiveSkuLedger(ledger) = quantityOutSkuLedger(ledger) IF isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;
    quantityOut##postfix##SkuStockDate (sku, stock, date) =
        GROUP SUM quantityOutActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT;

    quantity##postfix##SkuStockDate (sku, stock, date) = quantityIn##postfix##SkuStockDate(sku, stock, date)
                                                         (+)
                                                         quantityOut##postfix##SkuStockDate(sku, stock, date) PERSISTENT;

    signedQuantity##postfix##SkuStockDate (sku, stock, date) = quantityIn##postfix##SkuStockDate(sku, stock, date)
                                                               (-)
                                                               quantityOut##postfix##SkuStockDate(sku, stock, date) PERSISTENT;

    quantitySumIn##postfix##SkuStockDateDate 'Кол-во товара пришедшего за период' (sku, stock, date1, date2) =
        GROUP SUM quantityIn##postfix##SkuStockDate(sku, stock, dateIn) IF dateIn>=date1 IF dateIn<=date2
        BY sku, stock, date1, date2;
    quantitySumIn##postfix##GroupStockDateDate 'Кол-во товара пришедшего за период' (group, stock, date1, date2) =
        GROUP SUM quantitySumIn##postfix##SkuStockDateDate(sku, stock, date1, date2) IF isParentGroupSku(group, sku)
        BY group, stock, date1, date2;

    quantitySumOut##postfix##SkuStockDateDate 'Кол-во товара ушедшего за период' (sku, stock, date1, date2) =
        GROUP SUM quantityOut##postfix##SkuStockDate(sku, stock, dateIn) IF dateIn>=date1 IF dateIn<=date2
        BY sku, stock, date1, date2;
    quantitySumOut##postfix##GroupStockDateDate 'Кол-во товара ушедшего за период' (group, stock, date1, date2) =
        GROUP SUM quantitySumOut##postfix##SkuStockDateDate (sku, stock, date1, date2) IF isParentGroupSku(group, sku)
        BY group, stock, date1, date2;

    // без учета текущей даты/времени
    balanceB##postfix##SkuStockDate 'Остаток на начало дня'###caption (sku, stock, date) = currentBalance##postfix##SkuStock(sku, stock)
                                                                      (-) [= GROUP SUM signedQuantity##postfix##SkuStockDate (sku, stock, dateIn) IF dateIn >= date
                                                                                 BY sku, stock, date](sku, stock, date);

    // с учетом текущей даты/времени
    balanceA##postfix##SkuStockDate 'Остаток на конец дня'###caption (sku, stock, date) = currentBalance##postfix##SkuStock(sku, stock)
                                                                     (-) [= GROUP SUM signedQuantity##postfix##SkuStockDate (sku, stock, dateIn) IF dateIn > date
                                                                                BY sku, stock, date](sku, stock, date);

    // без учета текущей даты/времени
    balanceB##postfix##SkuStockDateTime 'Остаток (до)'###caption (sku, stock, dateTime) = currentBalance##postfix##SkuStock(sku, stock)
                                                                              (-) [= GROUP SUM signedQuantityActive##postfix##SkuLedger(ledger) IF dateTimeSkuLedger(ledger) >= dateTime
                                                                                         BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateTime](sku, stock, dateTime);

    // с учетом текущей даты/времени
    balanceA##postfix##SkuStockDateTime 'Остаток (после)'###caption (sku, stock, dateTime) = currentBalance##postfix##SkuStock(sku, stock)
                                                                             (-) [= GROUP SUM signedQuantityActive##postfix##SkuLedger(ledger) IF dateTimeSkuLedger(ledger) > dateTime
                                                                                        BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateTime](sku, stock, dateTime);

    balanceA##postfix##GroupStockDateTime 'Остаток (после)'###caption (group,  stock, dateTime) =
        GROUP SUM balanceA##postfix##SkuStockDateTime (sku, stock, dateTime) IF isParentGroupSku(group, sku)
        BY group, stockSkuLedger(ledger), dateTime;
        
    balanceB##postfix##StockDate 'Остаток на начало дня' (stock, date) = GROUP SUM balanceB##postfix##SkuStockDate(sku, stock, date) BY stock, date;

    currentBalance##postfix##Sku 'Остаток (всего)'###caption (sku) = GROUP SUM currentBalance##postfix##SkuStock(sku, stock) BY sku;

    signedQuantityActive##postfix##SkuLedgerBatch(ledger, batch) = signedCostSkuLedgerBatch(ledger, batch) IF active##postfix##SkuLedger(ledger) PERSISTENT;
    
    signedActiveCostSum##postfix##SkuLedgerBatch 'Себестоимость' (ledger, batch) = NUMERIC[16,3](signedQuantityActive##postfix##SkuLedgerBatch(ledger, batch) * costBatch(batch));
    signedActiveCostSum##postfix##SkuLedger 'Себестоимость' = GROUP SUM signedActiveCostSum##postfix##SkuLedgerBatch(ledger, batch) BY ledger;
    
    currentBalance##postfix##BatchStock 'Текущий остаток'###caption (batch, stock) = GROUP SUM signedQuantityActive##postfix##SkuLedgerBatch(ledger, batch)
                                                                                           BY batch, stockSkuLedger(ledger) PERSISTENT;
    prevCurrentBalance##postfix##BatchStock 'Текущий остаток'###caption (batch, stock) = PREV(currentBalance##postfix##BatchStock(batch, stock));

    count##postfix##BatchSkuStock 'Кол-во партий' (sku, stock) = GROUP SUM 1  IF currentBalance##postfix##BatchStock(batch, stock)
                                                                 BY skuBatch(batch), stock;
    default##postfix##BatchSkuStock 'Партия по умолчанию' (sku, stock)= GROUP MIN batch IF currentBalance##postfix##BatchStock(batch, stock)
                                                                        BY skuBatch(batch), stock;

    countLedger##postfix##BatchStock 'Кол-во движений'###caption (batch, stock) =
        GROUP SUM 1 IF signedQuantityActive##postfix##SkuLedgerBatch(ledger, batch) BY batch, stockSkuLedger(ledger) PERSISTENT;

    countLedger##postfix##BatchStockDateDate 'Кол-во движений за период'###caption (batch, stock, dateFrom, dateTo) =
        GROUP SUM 1 IF signedQuantityActive##postfix##SkuLedgerBatch(ledger, batch) AND dateSkuLedger(ledger) >= dateFrom AND dateSkuLedger(ledger) <= dateTo
        BY batch, stockSkuLedger(ledger), dateFrom, dateTo;

    orderBatch##postfix##SkuStock (sku, stock) = GROUP MAX orderBatch(batch) IF countLedger##postfix##BatchStock(batch, stock)
                                                       BY skuBatch(batch), stock PERSISTENT;
    lastOrderBatch##postfix##SkuStock(sku, stock) = orderBatch##postfix##SkuStock(sku, stock)[2] PERSISTENT;
    
    lastOrderBatch##postfix##Sku (sku) = GROUP MIN lastOrderBatch##postfix##SkuStock(sku, stock) BY sku;

    currentBalance##postfix##Batch 'Остаток (всего)'###caption (batch) = GROUP SUM currentBalance##postfix##BatchStock(batch, stock) BY batch PERSISTENT;
    outcome##postfix##Batch 'Расходовано'###caption (batch) = shippedQuantityBatch(batch) (-) currentBalance##postfix##Batch(batch);

    balanceASkuLedger 'Остаток (после)' (ledger) = balanceASkuStockDateTime(skuSkuLedger(ledger), stockSkuLedger(ledger), dateTimeSkuLedger(ledger));

    // ---------------------------- Суммы по товару -------------------------------- //

    signedSumActiveSkuLedger(ledger) = signedSumSkuLedger(ledger) IF isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;
    currentSum##postfix##SkuStock 'Сумма остатка'###caption (sku, stock) =
        GROUP SUM signedSumActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger) PERSISTENT;
    //-- по дате
    sumInActiveSkuLedger(ledger) = sumInSkuLedger(ledger) IF isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;
    sumIn##postfix##SkuStockDate (sku, stock, date) =
        GROUP SUM sumInActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT;

    sumOutActiveSkuLedger(ledger)  = sumOutSkuLedger(ledger) IF isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;
    sumOut##postfix##SkuStockDate (sku, stock, date) =
        GROUP SUM sumOutActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT;

    sum##postfix##SkuStockDate (sku, stock, date) = sumIn##postfix##SkuStockDate(sku, stock, date)
                                                         (+)
                                                         sumOut##postfix##SkuStockDate(sku, stock, date) PERSISTENT;

    signedSum##postfix##SkuStockDate (sku, stock, date) = sumIn##postfix##SkuStockDate(sku, stock, date)
                                                               (-)
                                                               sumOut##postfix##SkuStockDate(sku, stock, date) PERSISTENT;

    // без учета текущей даты/времени
    sumB##postfix##SkuStockDate 'Сумма на начало дня'###caption (sku, stock, date) = currentSum##postfix##SkuStock(sku, stock)
                                                                      (-) [= GROUP SUM signedSum##postfix##SkuStockDate (sku, stock, dateIn) IF dateIn >= date
                                                                                 BY sku, stock, date](sku, stock, date);

    sumB##postfix##StockDate 'Сумма на начало дня' (stock, date) = GROUP SUM sumB##postfix##SkuStockDate(sku, stock, date) BY stock, date;

    sumB##postfix##SkuGroupStockDate 'Сумма на начало дня (по группе)' (group, stock, date) =
        GROUP SUM sumB##postfix##SkuStockDate (sku, stock, date)
        BY groupGroupTypeSku(groupType, sku), stock, date;

    sumRecB##postfix##SkuGroupStockDate 'Сумма на начало дня (всего)' (group, stock, date) =
        GROUP SUM sumB##postfix##SkuStockDate (sku, stock, date) IF isParentGroupSku(group, sku)
        BY group, stock, date;

    // с учетом текущей даты/времени
    sumA##postfix##SkuStockDate 'Сумма на конец дня'###caption (sku, stock, date) = currentSum##postfix##SkuStock(sku, stock)
                                                                     (-) [= GROUP SUM signedSum##postfix##SkuStockDate (sku, stock, dateIn) IF dateIn > date
                                                                                BY sku, stock, date](sku, stock, date);

    sumA##postfix##SkuGroupStockDate 'Сумма на конец дня (по группе)' (group, stock, date) =
        GROUP SUM sumA##postfix##SkuStockDate (sku, stock, date)
        BY groupGroupTypeSku(groupType, sku), stock, date;

    sumRecA##postfix##SkuGroupStockDate 'Сумма на конец дня (всего)' (group, stock, date) =
        GROUP SUM sumA##postfix##SkuStockDate (sku, stock, date) IF isParentGroupSku(group, sku)
        BY group, stock, date;

    //-- по дате/время
    sumIn##postfix##SkuStockDateTime (sku, stock, dateTime) =
        GROUP SUM sumInActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateTimeSkuLedger(ledger);

    sumOut##postfix##SkuStockDateTime (sku, stock, dateTime) =
        GROUP SUM sumOutActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateTimeSkuLedger(ledger);

    sum##postfix##SkuStockDateTime (sku, stock, dateTime) = sumIn##postfix##SkuStockDateTime(sku, stock, dateTime)
                                                         (+)
                                                         sumOut##postfix##SkuStockDateTime(sku, stock, dateTime);

    signedSum##postfix##SkuStockDateTime (sku, stock, dateTime) = sumIn##postfix##SkuStockDateTime(sku, stock, dateTime)
                                                               (-)
                                                               sumOut##postfix##SkuStockDateTime(sku, stock, dateTime);

    // без учета текущей даты/времени
    sumB##postfix##SkuStockDateTime 'Сумма (до)'###caption (sku, stock, dateTime) = currentSum##postfix##SkuStock(sku, stock)
                                                                      (-) [= GROUP SUM signedSum##postfix##SkuStockDateTime (sku, stock, dateIn) IF dateIn >= dateTime
                                                                                 BY sku, stock, dateTime](sku, stock, dateTime);

    sumB##postfix##SkuGroupStockDateTime 'Учетная сумма группы товаров (до)' (group, stock, dateTime) =
        GROUP SUM sumB##postfix##SkuStockDateTime (sku, stock, dateTime) IF isParentGroupSku(group, sku)
        BY groupGroupTypeSku(groupType, sku), stock, dateTime;
        
    sumRecB##postfix##SkuGroupStockDateTime 'Учетная сумма (всего)' (group, stock, dateTime) =
        GROUP SUM sumB##postfix##SkuStockDateTime (sku, stock, dateTime) IF isParentGroupSku(group, sku)
        BY group, stock, dateTime;
        
    // с учетом текущей даты/времени
    sumA##postfix##SkuStockDateTime 'Сумма (после)'###caption (sku, stock, dateTime) = currentSum##postfix##SkuStock(sku, stock)
                                                                     (-) [= GROUP SUM signedSum##postfix##SkuStockDateTime (sku, stock, dateIn) IF dateIn > dateTime
                                                                                BY sku, stock, dateTime](sku, stock, dateTime);

    // суммы для периодов
    sumIn##postfix##SkuStockDateDate 'Сумма товара пришедшего за период' (sku, stock, dateFrom, dateTo) =
        GROUP SUM sumIn##postfix##SkuStockDate(sku, stock, dateIn) IF dateIn >= dateFrom AND dateIn <= dateTo
               BY sku, stock, dateFrom, dateTo;
    sumIn##postfix##GroupSkuStockDateDate 'Сумма товара пришедшего за период(по группе)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumIn##postfix##SkuStockDateDate (sku, stock, dateFrom, dateTo)
        BY groupGroupTypeSku(groupType, sku), stock, dateFrom, dateTo;
    sumRecIn##postfix##GroupSkuStockDateDate 'Сумма товара пришедшего за период(всего)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumIn##postfix##SkuStockDateDate (sku, stock, dateFrom, dateTo) IF isParentGroupSku(group, sku)
        BY group, stock, dateFrom, dateTo;

    sumOut##postfix##SkuStockDateDate 'Сумма товара ушедшего за период' (sku, stock, dateFrom, dateTo) =
        GROUP SUM sumOut##postfix##SkuStockDate(sku, stock, dateOut) IF dateOut >= dateFrom AND dateOut <= dateTo
               BY sku, stock, dateFrom, dateTo;
    sumOut##postfix##GroupSkuStockDateDate 'Сумма товара ушедшего за период(по группе)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumOut##postfix##SkuStockDateDate (sku, stock, dateFrom, dateTo)
        BY groupGroupTypeSku(groupType, sku), stock, dateFrom, dateTo;
    sumRecOut##postfix##GroupSkuStockDateDate 'Сумма товара ушедшего за период(всего)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumOut##postfix##SkuStockDateDate (sku, stock, dateFrom, dateTo) IF isParentGroupSku(group, sku)
        BY group, stock, dateFrom, dateTo;

    averagePrice##postfix##SkuStock 'Цена (средневзв.)'###caption (sku, stock) = currentSum##postfix##SkuStock(sku, stock) / currentBalance##postfix##SkuStock(sku, stock); // IF NOT currentBalance##postfix##SkuStock(sku, stock) == 0; (возможно не нужно, так как 0 не может быть в GROUP SUM )
    averagePriceA##postfix##SkuStockDateTime 'Цена (средневзв.)'###caption (sku, stock, dateTime) = sumA##postfix##SkuStockDateTime(sku, stock, dateTime) / balanceA##postfix##SkuStockDateTime(sku, stock, dateTime); // IF NOT currentBalance##postfix##SkuStock(sku, stock) == 0; (возможно не нужно, так как 0 не может быть в GROUP SUM )

END

@defineSkuLedgerBalanceProperties(,);

expiryDateSkuStock 'Годен до (max.)' (sku, stock) = GROUP MAX expiryDateBatch(batch) IF currentBalanceBatchStock(batch, stock)
                                                          BY skuBatch(batch), stock PERSISTENT;
                                                          
banNegativeSku 'Запретить расходовать больше чем в остатке по товару' = DATA BOOLEAN ();

EXTEND FORM options 
    PROPERTIES() banNegativeSku 
;

EXTEND DESIGN options {
    stock {
        ADD PROPERTY(banNegativeSku());
    }
}

CONSTRAINT currentBalanceSkuStock(sk, st) < 0.0 AND banNegativeSku()
    MESSAGE 'Текущий остаток должен быть больше нуля';


// -------------------------------------- Последнее движение ---------------------------------- //

dateTimeLastMovedSkuStock 'Время последнего движения' (sku, stock) =
    GROUP MAX dateTimeSkuLedger(ledger)
    BY skuSkuLedger(ledger), stockSkuLedger(ledger) PERSISTENT;

dateTimeLastMovedSku 'Время последнего движения' (sku) =
    GROUP MAX dateTimeLastMovedSkuStock(sku, stock)
    BY sku;

movedSkuStockDateTimePeriod (item, departmentStore, dateTime, period) =
    dateTimeLastMovedSkuStock(item, departmentStore) >= toDateTime(subtractDate(toDate(dateTime), period));

balanceSkuStockDateTimePeriod (item, departmentStore, dateTime, period) =
    movedSkuStockDateTimePeriod (item, departmentStore, dateTime, period) OR balanceASkuStockDateTime(item, departmentStore, dateTime);

movedSkuStockDatePeriod (item, departmentStore, date, period) =
    dateTimeLastMovedSkuStock(item, departmentStore) >= toDateTime(subtractDate(date, period));

balanceSkuStockDatePeriod (item, departmentStore, date, period) =
    movedSkuStockDatePeriod (item, departmentStore, date, period) OR balanceASkuStockDate(item, departmentStore, date);

//----------------------------------------- По партиям ---------------------------------------------//

signedQuantityBatchStockDate = GROUP SUM signedCostSkuLedgerBatch (ledger, batch) IF isPostedSkuLedger(ledger)
                                     BY batch, stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT; 
                                     
quantityBatchStockDate = GROUP SUM costSkuLedgerBatch (ledger, batch) IF isPostedSkuLedger(ledger)
                                     BY batch, stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT;                                      

// без учета текущей даты/времени
balanceBBatchStockDate 'Остаток на начало дня' (batch, stock, date) = currentBalanceBatchStock(batch, stock)
    (-) [= GROUP SUM signedQuantityBatchStockDate(batch, stock, dateIn) IF dateIn >= date
           BY batch, stock, date](batch, stock, date);

// с учетом текущей даты/времени
balanceABatchStockDate 'Остаток на конец дня' (batch, stock, date) = currentBalanceBatchStock(batch, stock)
    (-) [= GROUP SUM signedQuantityBatchStockDate(batch, stock, dateIn) IF dateIn > date
           BY batch, stock, date](batch, stock, date);

// без учета текущей даты/времени
balanceBBatchStockDateTime 'Остаток (до)' (batch, stock, dateTime) = currentBalanceBatchStock(batch, stock)
    (-) [= GROUP SUM signedQuantityActiveSkuLedgerBatch (ledger, batch) IF dateTimeSkuLedger(ledger) >= dateTime
    BY batch, stockSkuLedger(ledger), dateTime](batch, stock, dateTime);

// с учетом текущей даты/времени
balanceABatchStockDateTime 'Остаток (после)' (batch, stock, dateTime) = currentBalanceBatchStock(batch, stock)
    (-) [= GROUP SUM signedQuantityActiveSkuLedgerBatch (ledger, batch) IF dateTimeSkuLedger(ledger) > dateTime
    BY batch, stockSkuLedger(ledger), dateTime](batch, stock, dateTime);

// Остатки по себестоимости
costBBatchStockDate 'Себестоимость на начало дня' (batch, stock, date) = balanceBBatchStockDate(batch, stock, date) * costBatch(batch);
  
costABatchStockDate 'Себестоимость на конец дня' (batch, stock, dateTo) = balanceABatchStockDate(batch, stock, dateTo) * costBatch(batch);          

// Итоги по складам
costBStockDate 'Себестоимость на начало дня' = GROUP SUM costBBatchStockDate(b, s, d) BY s, d;
costAStockDate 'Себестоимость на конец дня' = GROUP SUM costABatchStockDate(b, s, d) BY s, d;

//---------------------------------------------- За период ------------------------------------------//

costInBalanceBatchStockDateFromTo 'Приход' (batch, stock, dateFrom, dateTo) = GROUP SUM costSkuLedgerBatch (ledger, batch)
    IF ledger IS InSkuLedger AND isPostedSkuLedger(ledger)
    AND dateSkuLedger(ledger) >= dateFrom AND dateSkuLedger(ledger)<= dateTo
    BY batch, stockSkuLedger(ledger), dateFrom, dateTo;

costSumInBalanceBatchStockDateFromTo 'Сумма прихода' (batch, stock, dateFrom, dateTo) =
    costBatch(batch) * costInBalanceBatchStockDateFromTo(batch, stock, dateFrom, dateTo);

costOutBalanceBatchStockDateFromTo 'Расход' (batch, stock, dateFrom, dateTo) = GROUP SUM costSkuLedgerBatch (ledger, batch)
    IF ledger IS OutSkuLedger AND isPostedSkuLedger(ledger)
    AND dateSkuLedger(ledger) >= dateFrom AND dateSkuLedger(ledger)<= dateTo
    BY batch, stockSkuLedger(ledger), dateFrom, dateTo;

costSumOutBalanceBatchStockDateFromTo 'Сумма расхода' (batch, stock, dateFrom, dateTo) =
    costBatch(batch) * costOutBalanceBatchStockDateFromTo(batch, stock, dateFrom, dateTo);
    
//---------------------------------------------- Себестоимость ------------------------------------------//    
    
currentCostSumSkuStock 'Текущая себестоимость' (sku, stock) =
    GROUP SUM signedActiveCostSumSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger);
    
// без учета текущей даты/времени
costSumBSkuStockDate 'Себестоимость на начало дня' (sku, stock, date) = GROUP SUM costBBatchStockDate(batch, stock, date) BY skuBatch(batch), stock, date;

// с учетом текущей даты/времени
costSumASkuStockDate 'Себестоимость на конец дня' (sku, stock, date) = GROUP SUM costABatchStockDate(batch, stock, date) BY skuBatch(batch), stock, date; 

// ------------------------------------------------ Формы для партий ------------------------------ //
FORM batches 'Партии'

    TREE skuTree sk = SkuGroup PARENT parentSkuGroup
    PROPERTIES READONLY skuTreeName = nameSkuGroup(sk)
    ORDER BY skuTreeName
    FILTERGROUP inactive FILTER 'Активные' 'F5' activeSkuGroup(sk) DEFAULT

    OBJECTS           bt=Batch
    PROPERTIES(bt)    READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameSkuBatch, idBatch SHOWIF showIDs(), 
                               nameBatch, nameStockBatch, shippedQuantityBatch, costBatch, expiryDateBatch, currentBalanceBatch
    PROPERTIES(bt)    editSkuLedger
    FILTERS           isParentSkuGroupBatch(sk, bt)
    ORDER BY          dateTimeBatch(bt)

    FILTERGROUP filterBalance
        FILTER 'Партии пришедшие за последний 1 день' 'F10' dateBatch(bt) >= subtractDate(currentDate(), 1)
        FILTER 'Партии пришедшие за последние 7 дней' 'F9' dateBatch(bt) >= subtractDate(currentDate(), 7)
        FILTER 'Партии пришедшие за последние 30 дней' 'F8' dateBatch(bt) >= subtractDate(currentDate(), 30)

    FILTERGROUP filterExpiry
        FILTER 'Партии с истекшим сроком годности' 'F7' expiryDateBatch(bt) < currentDate()
        FILTER 'Партии со сроком годности, истекающим через 1 день' 'F6' expiresBatchDate(bt, currentDate(), 1)
        FILTER 'Партии со сроком годности, истекающим через 7 дней' 'F5' expiresBatchDate(bt, currentDate(), 7)
        FILTER 'Партии со сроком годности, истекающим через 30 дней' 'F4' expiresBatchDate(bt, currentDate(), 30)

    DIALOG Batch OBJECT bt
;

DESIGN batches FROM DEFAULT {
    main{
        preferredSize = (1024, 768);

        NEW topContainer {
            fill = 1;
            type = SPLITH;
            ADD skuTree.tree.box { caption = 'Группы'; }
            ADD bt.box { fill = 3; caption = 'Партии'; }
        }
        ADD functions.box;
    }
}
@extendFormFilterAccessStock(Batch, bt, batches, stock, company);

FORM dialogBatch 'Партии'
    OBJECTS sk = Sku FIXED PANEL

    OBJECTS bt = Batch
    PROPERTIES (bt) READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameStockBatch,
                    nameSkuBatch, nameBatch, idBatch SHOWIF showIDs(), shippedQuantityBatch, costBatch, expiryDateBatch
    FILTERS skuBatch(bt) == sk

    ORDER BY dateTimeBatch(bt)
;

FORM dialogBatchStock 'Партии'
    OBJECTS st = Stock FIXED PANEL
    OBJECTS t = DATETIME FIXED PANEL
    OBJECTS sk = Sku FIXED PANEL

    OBJECTS bt = Batch
    PROPERTIES (bt) READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameSkuBatch, idBatch SHOWIF showIDs(), nameBatch, shippedQuantityBatch, costBatch, expiryDateBatch
    PROPERTIES  READONLY balanceBBatchStockDateTime(bt, st, t)
    FILTERS skuBatch(bt) == sk

    FILTERGROUP batch
        FILTER 'Партии с остатком' 'F11' balanceBBatchStockDateTime(bt, st, t) DEFAULT
;
DESIGN dialogBatchStock FROM DEFAULT {
    main {
        PROPERTY (balanceBBatchStockDateTime(bt,st,t)) {
            caption = 'Текущий остаток';
        }
    }
}

// ------------------------------------------------- Себестоимость --------------------------- //

currentBalanceSkuLedgerBatch 'Текущий остаток' (bil, bt) = currentBalanceBatchStock(bt, stockSkuLedger(bil));

FORM costSkuLedger 'Себестоимость (операции)'
    OBJECTS bil = SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger, nameSkuSkuLedger, nameStockSkuLedger,
                             quantitySkuLedger, costedSkuLedger, sumSkuLedger
    PROPERTIES(bil)          resetCostDataSkuLedger FORCE GRID
    PROPERTIES(bil)          editSkuLedger
    FILTERS isSkuLedger(bil)
    ORDER BY dateTimeSkuLedger(bil)

    FILTERGROUP needToCostDataSkuLedger
        FILTER 'Нерасписанные строки' 'F9' needToCostDataSkuLedger(bil)

    OBJECTS bt = Batch
    PROPERTIES(bt) READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, shippedQuantityBatch, costBatch, currentBalanceBatch
    PROPERTIES(bil, bt)     costSkuLedgerBatch FORCE GRID, currentBalanceSkuLedgerBatch FORCE GRID
    FILTERS skuBatch(bt) == skuSkuLedger(bil)
    ORDER BY dateTimeBatch(bt) DESC

    FILTERGROUP inSkuLedgerBatch
        FILTER 'Только расписанные партии' 'F10' costSkuLedgerBatch (bil, bt) DEFAULT

    FILTERGROUP currentBalance
        FILTER 'Только партии с остатком на складе' 'F11' currentBalanceSkuLedgerBatch (bil, bt)

    PROPERTIES() setDataSkuLedgerBatchCost, resetDataSkuLedgerBatchCost, clearDataSkuLedgerBatchCost
;

DESIGN costSkuLedger FROM DEFAULT {
    NEW topContainer{
        fill = 1;
        type = SPLITV;

        ADD bil.box;
        ADD bt.box;
    }

    NEW buttonContainer {
        type = CONTAINERH;
        ADD PROPERTY(setDataSkuLedgerBatchCost());
        ADD PROPERTY(resetDataSkuLedgerBatchCost());
        ADD PROPERTY(clearDataSkuLedgerBatchCost());
    }

    ADD functions.box;
}
@extendFormFilterAccessStock(SkuLedger, bil, costSkuLedger, stock, company);

FORM costSkuBatchLedger 'Себестоимость (партии)'
    OBJECTS i = Sku FIXED PANEL
    PROPERTIES(i) SELECTOR nameSku//, idBarcodeSku

    OBJECTS bt = Batch
    PROPERTIES(bt) READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, shippedQuantityBatch, costBatch, currentBalanceBatch

    OBJECTS bil = SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger, nameStockSkuLedger,
                             quantitySkuLedger, costedSkuLedger
//    PROPERTIES(bil)          resetCostSkuLedger
    ORDER BY dateTimeSkuLedger(bil)

    FILTERGROUP needToCostSkuLedger
        FILTER 'Нерасписанные строки' 'F9' needToCostDataSkuLedger(bil)


    PROPERTIES(bil, bt)     READONLY costSkuLedgerBatch FORCE GRID
    FILTERS skuBatch(bt) == i,
            skuSkuLedger(bil) == i

    ORDER BY dateTimeBatch(bt) DESC

    FILTERGROUP inSkuLedgerBatch
        FILTER 'Только расписанные партии' 'F10' costSkuLedgerBatch (bil, bt) DEFAULT
;

DESIGN costSkuBatchLedger FROM DEFAULT {
    NEW topContainer {
        fill = 1;
        type = SPLITV;

        ADD bt.box;
        ADD bil.box;
    }
    ADD functions.box;
}

// ------------------------------------------------ Остатки по товарам ---------------------------------------- //

selectSkuStock 'Отм.' = DATA SESSION BOOLEAN (Sku, Stock);
selectSkuSessionStock (stock) = GROUP SUM 1 IF selectSkuStock(sku, stock) BY stock; 
selectSkuStockSession () = GROUP SUM 1 IF selectSkuStock(sku, stock) ; 

multipleStores 'Несколько складов' = DATA SESSION BOOLEAN ();
singleStore = NOT multipleStores();

FORM currentBalanceSkuStock 'Текущие остатки'
    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) nameStock SELECTOR SHOWIF singleStore()
    FILTERS isCompanyStock(ss)
    
    TREE stockTree a = STRING[3], sg = StockGroup PARENT parentStockGroup, ts = Stock
    PROPERTIES SHOWIF multipleStores() READONLY OBJVALUE(a), sgTreeName = nameStockGroup(sg), tsTreeName = nameStock(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroupStock(ts) == sg,
            isCompanyStock(ts)
    FILTERGROUP tsinactiveStock FILTER 'Активный' 'ctrl F10' activeStock(ts) DEFAULT
    
    TREE skuTree sk = SkuGroup PARENT parentSkuGroup
    PROPERTIES READONLY skuTreeName = nameSkuGroup(sk)
    ORDER BY skuTreeName
    FILTERGROUP inactive FILTER 'Активные' 'F5' activeSkuGroup(sk) DEFAULT

    OBJECTS           sts=(st=Stock, s=Sku)
    PROPERTIES        selectSkuStock(s,st)
    PROPERTIES        READONLY nameSku(s), stockName = nameStock(st) SHOWIF multipleStores()  //  idBarcodeSku
    FILTERS           isParentSkuGroupSku(sk, s),
                      IF multipleStores() THEN 
                        st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                      ELSE 
                        st == ss,
                      isCompanyStock(st)
    ORDER BY          nameSku(s)
    FILTERGROUP inactiveStock FILTER 'Активный' 'ctrl F10' activeStock(st) DEFAULT

    PROPERTIES(s, st) READONLY currentBalanceSkuStock, averagePriceSkuStock, currentSumSkuStock, dateTimeLastMovedSkuStock

    FILTERGROUP filters
        FILTER 'Товары с остатком' 'F10' currentBalanceSkuStock(s, st) DEFAULT
        FILTER 'Товары с движением не позднее 1 дня' 'F9' balanceSkuStockDatePeriod(s, st, currentDate(), 1)
        FILTER 'Товары с движением не позднее 7 дней' 'F8' balanceSkuStockDatePeriod(s, st, currentDate(), 7)
        FILTER 'Товары с движением не позднее 30 дней' 'F7' balanceSkuStockDatePeriod(s, st, currentDate(), 30)

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger, nameBatchSkuLedger,
                    signedQuantitySkuLedger, signedPriceSkuLedger, signedSumSkuLedger, skipSkuLedger
                    
    FILTERS isPostedSkuLedger(bil) AND skuSkuLedger(bil)==s AND stockSkuLedger(bil)==st
    ORDER BY dateTimeSkuLedger(bil) DESC

    OBJECTS bt=Batch
    PROPERTIES(bt) READONLY      numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, idBatch, shippedQuantityBatch, costBatch, expiryDateBatch
    PROPERTIES(bt, st) READONLY  currentBalanceBatchStock
    FILTERS isPostedBatch(bt) AND skuBatch(bt)==s
    ORDER BY dateTimeBatch(bt) DESC
;

DESIGN currentBalanceSkuStock FROM DEFAULT {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            ADD PROPERTY (multipleStores());
            ADD PROPERTY (nameStock(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;

            NEW firstBottom {
                fill = 1;
                type = SPLITV;
                ADD stockTree.tree.box { caption = 'Склады'; }
                ADD skuTree.tree.box { caption = 'Группы'; }
            }

            NEW secondCase {
                fill = 3;
                type = CONTAINERV;
                ADD sts.box {
                    fill = 2;
                }

                NEW ledger.box {
                    fill = 1;
                    caption = 'Изменение цен';
                    type = TABBED;
                    ADD bil.box;
                    ADD bt.box;
                    NEW actionContainer {
                        caption = 'Действия';
                        type = CONTAINERH;
                    }
                }
            }
        }

        ADD functions.box;
    }
}
@extendFormFilterStockGroupAccess(StockGroup, sg, currentBalanceSkuStock);
@extendFormFilterStockAccess(Stock, st, currentBalanceSkuStock);

@extendFormFilterStockAccess(Stock, ts, currentBalanceSkuStock);

FORM balanceSkuStock 'Остатки на дату'

    OBJECTS t=DATETIME FIXED PANEL
    PROPERTIES valT = OBJVALUE(t)

    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) nameStock SELECTOR SHOWIF singleStore()
    FILTERS isCompanyStock(ss)    

    TREE stockTree a = STRING[3], sg = StockGroup PARENT parentStockGroup, ts = Stock
    PROPERTIES READONLY SHOWIF multipleStores() OBJVALUE(a), sgTreeName = nameStockGroup(sg), tsTreeName = nameStock(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroupStock(ts) == sg,
            isCompanyStock(ts)
    FILTERGROUP sginactiveStock FILTER 'Активный' 'ctrl F10' activeStock(ts) DEFAULT
    TREE skuTree sk = SkuGroup PARENT parentSkuGroup
    PROPERTIES READONLY skuTreeName = nameSkuGroup(sk)
    ORDER BY skuTreeName
    FILTERGROUP inactive FILTER 'Активные' 'F5' activeSkuGroup(sk) DEFAULT

    OBJECTS           sts=(st=Stock, s=Sku)
    PROPERTIES        READONLY nameSku(s), stockName = nameStock(st) SHOWIF multipleStores()  //  idBarcodeSku
    FILTERGROUP inactiveStock FILTER 'Активный' 'ctrl F10' activeStock(st) DEFAULT
    FILTERS           isParentSkuGroupSku(sk, s),
                      IF multipleStores() THEN 
                          st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                        ELSE 
                            st == ss,
                      isCompanyStock(st)

    PROPERTIES(s, st, t) READONLY balanceASkuStockDateTime, averagePriceASkuStockDateTime, sumASkuStockDateTime
    PROPERTIES(s, st) READONLY dateTimeLastMovedSkuStock

    FILTERGROUP filters
        FILTER 'Товары с остатком' 'F10' balanceASkuStockDateTime(s, st, t) DEFAULT
        FILTER 'Товары с движением не позднее 1 дня' 'F9' balanceSkuStockDateTimePeriod(s, st, t, 1)
        FILTER 'Товары с движением не позднее 7 дней' 'F8' balanceSkuStockDateTimePeriod(s, st, t, 7)
        FILTER 'Товары с движением не позднее 30 дней' 'F7' balanceSkuStockDateTimePeriod(s, st, t, 30)

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger, nameBatchSkuLedger,
                    signedQuantitySkuLedger, signedPriceSkuLedger, signedSumSkuLedger
    FILTERS isPostedSkuLedger(bil) AND skuSkuLedger(bil)==s AND stockSkuLedger(bil)==st
    ORDER BY dateTimeSkuLedger(bil) DESC

    OBJECTS bt=Batch
    PROPERTIES(bt) READONLY      numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, idBatch, shippedQuantityBatch, costBatch
    PROPERTIES(bt, st, t) READONLY  balanceBBatchStockDateTime
    FILTERS isPostedBatch(bt) AND skuBatch(bt)==s
    ORDER BY dateTimeBatch(bt) DESC
;

DESIGN balanceSkuStock FROM DEFAULT {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            ADD PROPERTY (valT);
            ADD PROPERTY (multipleStores());
            ADD PROPERTY (nameStock(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;
            
            NEW firstCaseTwo {
                fill = 1;
                type = SPLITV;
                ADD stockTree.tree.box { caption = 'Склады'; }
                ADD skuTree.tree.box { caption = 'Группы'; }
            }

            NEW secondCase {
                fill = 3;
                type = CONTAINERV;
                ADD sts.box { fill = 2; }

                NEW ledger.box {
                    fill = 1;
                    caption = 'Изменение цен';
                    type = TABBED;
                    ADD bil.box;
                    ADD bt.box;
                }
            }
        }
        ADD functions.box;
    }
}
@extendFormFilterStockGroupAccess(StockGroup, sg, balanceSkuStock);
@extendFormFilterStockAccess(Stock, st, balanceSkuStock);

@extendFormFilterStockAccess(Stock, ts, balanceSkuStock);

// ------------------------------------------------ Остатки по партиям ---------------------------------------- //

FORM currentBalanceBatchStock 'Текущие остатки по партиям'

    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) nameStock SELECTOR SHOWIF singleStore()
    FILTERS isCompanyStock(ss)   

    TREE stockTree a = STRING[3], sg = StockGroup PARENT parentStockGroup, ts = Stock
    PROPERTIES READONLY SHOWIF multipleStores() OBJVALUE(a), sgTreeName = nameStockGroup(sg), tsTreeName = nameStock(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroupStock(ts) == sg,
            isCompanyStock(ts)
    FILTERGROUP sginactiveStock FILTER 'Активный' 'ctrl F10' activeStock(ts) DEFAULT
    TREE skuTree sk = SkuGroup PARENT parentSkuGroup
    PROPERTIES READONLY skuTreeName = nameSkuGroup(sk)
    ORDER BY skuTreeName
    FILTERGROUP inactive FILTER 'Активные' 'F5' activeSkuGroup(sk) DEFAULT
       
    OBJECTS           stb=(st=Stock, bt=Batch)
    PROPERTIES        READONLY nameSkuBatch(bt), stockName = nameStock(st) SHOWIF multipleStores()
    PROPERTIES        READONLY currentBalanceBatchStock(bt, st)
    PROPERTIES(bt)    READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, idBatch, shippedQuantityBatch, costBatch, expiryDateBatch
    FILTERS           isParentSkuGroupBatch(sk, bt),
                      IF multipleStores() THEN 
                          st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                        ELSE 
                            st == ss,    
//                      st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts,
                      isCompanyStock(st)
    FILTERGROUP inactiveStock FILTER 'Активный' 'ctrl F10' activeStock(st) DEFAULT
    ORDER BY          dateTimeBatch(bt)

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger,
                    signedQuantitySkuLedger, signedPriceSkuLedger, signedSumSkuLedger, skipSkuLedger
    FILTERS isPostedSkuLedger(bil) AND costSkuLedgerBatch(bil, bt) AND stockSkuLedger(bil)==st   //skuSkuLedger(bil)==skuBatch(bt)
    ORDER BY dateTimeSkuLedger(bil) DESC

    FILTERGROUP filterBalance
        FILTER 'Партии с остатком' 'F11' currentBalanceBatchStock(bt, st) DEFAULT
        FILTER 'Партии пришедшие за последний 1 день' 'F10' dateBatch(bt) >= subtractDate(currentDate(), 1)
        FILTER 'Партии пришедшие за последние 7 дней' 'F9' dateBatch(bt) >= subtractDate(currentDate(), 7)
        FILTER 'Партии пришедшие за последние 30 дней' 'F8' dateBatch(bt) >= subtractDate(currentDate(), 30)

    FILTERGROUP filterExpiry
        FILTER 'Партии с истекшим сроком годности' 'F7' expiryDateBatch(bt) < currentDate()
        FILTER 'Партии со сроком годности, истекающим через 1 день' 'F6' expiresBatchDate(bt, currentDate(), 1)
        FILTER 'Партии со сроком годности, истекающим через 7 дней' 'F5' expiresBatchDate(bt, currentDate(), 7)
        FILTER 'Партии со сроком годности, истекающим через 30 дней' 'F4' expiresBatchDate(bt, currentDate(), 30)
;

DESIGN currentBalanceBatchStock FROM DEFAULT {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            ADD PROPERTY (multipleStores());
            ADD PROPERTY (nameStock(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;

            NEW firstCase {
                fill = 1;
                type = SPLITV;
                ADD stockTree.tree.box { caption = 'Склады'; }
                ADD skuTree.tree.box { caption = 'Группы'; }
            }
            NEW secondCase {
                fill = 3;
                type = CONTAINERV;
                ADD stb.box { fill = 2; caption = 'Партии';}

                NEW ledger.box {
                    fill = 1;
                    type = TABBED;
                    ADD bil.box {caption = 'Движение';}
                }
             }            
            
        }

        ADD functions.box;
    }
}
@extendFormFilterStockGroupAccess(StockGroup, sg, currentBalanceBatchStock);
@extendFormFilterStockAccess(Stock, st, currentBalanceBatchStock);

@extendFormFilterStockAccess(Stock, ts, currentBalanceBatchStock);

FORM balanceBatchStock 'Остатки по партиям на дату'

    OBJECTS t=DATETIME FIXED PANEL
    PROPERTIES   valT = OBJVALUE(t)
    
    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) nameStock SELECTOR SHOWIF singleStore()
    FILTERS isCompanyStock(ss)  
    
    TREE stockTree a = STRING[3], sg = StockGroup PARENT parentStockGroup, ts = Stock
    PROPERTIES READONLY SHOWIF multipleStores() OBJVALUE(a), sgTreeName = nameStockGroup(sg), tsTreeName = nameStock(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroupStock(ts) == sg,
            isCompanyStock(ts)
    FILTERGROUP sginactiveStock FILTER 'Активный' 'ctrl F10' activeStock(ts) DEFAULT
    TREE skuTree sk = SkuGroup PARENT parentSkuGroup
    PROPERTIES READONLY skuTreeName = nameSkuGroup(sk)
    ORDER BY skuTreeName
    FILTERGROUP inactive FILTER 'Активные' 'F5' activeSkuGroup(sk) DEFAULT

    OBJECTS           stb=(st=Stock, bt=Batch)
    PROPERTIES        READONLY stockName = nameStock(st) SHOWIF multipleStores(), nameSkuBatch(bt)
    PROPERTIES        balanceBBatchStockDateTime(bt, st, t)
    PROPERTIES(bt)    READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, idBatch, shippedQuantityBatch, costBatch, expiryDateBatch
    FILTERS           isParentSkuGroupBatch(sk, bt),
                      st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts,
                      isCompanyStock(st)
    FILTERGROUP inactiveStock FILTER 'Активный' 'ctrl F10' activeStock(st) DEFAULT
    ORDER BY          dateTimeBatch(bt)

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger,
                    signedQuantitySkuLedger, signedPriceSkuLedger, signedSumSkuLedger, skipSkuLedger
    FILTERS isPostedSkuLedger(bil) AND skuSkuLedger(bil)==skuBatch(bt) AND stockSkuLedger(bil)==st,
            dateTimeSkuLedger(bil) < t
    ORDER BY dateTimeSkuLedger(bil) DESC

    FILTERGROUP filterBalance
        FILTER 'Партии с остатком' 'F11' balanceBBatchStockDateTime(bt, st, t) DEFAULT
        FILTER 'Партии пришедшие за последний 1 день' 'F10' dateTimeBatch(bt) >= subtractDateTimeSeconds(currentDateTime(), 1)
        FILTER 'Партии пришедшие за последние 7 дней' 'F9' dateTimeBatch(bt) >= subtractDateTimeSeconds(currentDateTime(), 7)
        FILTER 'Партии пришедшие за последние 30 дней' 'F8' dateTimeBatch(bt) >= subtractDateTimeSeconds(currentDateTime(), 30)

    FILTERGROUP filterExpiry
        FILTER 'Партии с истекшим сроком годности' 'F7' expiryDateBatch(bt) < toDate(t)
        FILTER 'Партии со сроком годности, истекающим через 1 день' 'F6' expiresBatchDateTime(bt, t, 1)
        FILTER 'Партии со сроком годности, истекающим через 7 дней' 'F5' expiresBatchDateTime(bt, t, 7)
        FILTER 'Партии со сроком годности, истекающим через 30 дней' 'F4' expiresBatchDateTime(bt, t, 30)
;

DESIGN balanceBatchStock FROM DEFAULT {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            ADD PROPERTY (valT);
            ADD PROPERTY (multipleStores());
            ADD PROPERTY (nameStock(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;
            
            NEW firstCaseTwo {
                fill = 1;
                type = SPLITV;
                ADD stockTree.tree.box { caption = 'Склады'; }
                ADD skuTree.tree.box { caption = 'Группы'; }
            }
            NEW secondCase {
                fill = 3;
                type = CONTAINERV;
                ADD stb.box {
                    fill = 2;
                    caption = 'Партии';
                }

                NEW ledger.box {
                    fill = 1;
                    type = TABBED;
                    ADD bil.box {caption = 'Движение';}

                }
            }            
            
            
        }

        ADD functions.box;
    }
}
@extendFormFilterStockGroupAccess(StockGroup, sg, balanceBatchStock);
@extendFormFilterStockAccess(Stock, st, balanceBatchStock);

@extendFormFilterStockAccess(Stock, ts, balanceBatchStock);

FORM skuLedger 'Регистр движений'

    OBJECTS dates = (dFrom = DATE, dTo = DATE) FIXED PANEL
    PROPERTIES valFrom = OBJVALUE(dFrom), valTo = OBJVALUE(dTo)

    OBJECTS s = SkuLedger
    PROPERTIES(s) READONLY dateSkuLedger, dateTimeSkuLedger, canonicalNameSkuGroupSkuLedger, nameSkuSkuLedger, descriptionSkuLedger, nameStockSkuLedger,
                           signedQuantitySkuLedger, signedPriceSkuLedger, signedSumSkuLedger, costSumSkuLedger
    PROPERTIES(s) editSkuLedger
    FILTERS isPostedSkuLedger(s)

    FILTERS dateSkuLedger(s) >= dFrom, dateSkuLedger(s) <= dTo
;

DESIGN skuLedger FROM DEFAULT {
    ADD dates.box {
        type = CONTAINERH;
    }
    ADD s.box {
        type = CONTAINERV;
    }
    ADD functions.box;
}

NAVIGATOR {
    stockNavigator {
        NEW balanceSku 'Остатки по товару' BEFORE stockReports {
            ADD currentBalanceSkuStock;
            ADD balanceSkuStock;
        }
        NEW balanceBatch 'Остатки по партиям' BEFORE stockReports {
            ADD currentBalanceBatchStock;
            ADD balanceBatchStock;
            ADD batches;
        }
        NEW stockCost 'Себестоимость' BEFORE stockReports {
            ADD costSkuLedger;
            ADD costSkuBatchLedger;
        }
        stockReports{
            ADD skuLedger;
        }
    }
}

// ----------------------------------------------------------------------------- //

skuGroup1Batch 'Категория' (batch) = skuGroup1Sku(skuBatch(batch));
nameSkuGroup1Batch 'Категория' (batch) = nameSkuGroup(skuGroup1Batch(batch));
 
skuGroup2Batch 'Направление' (batch) = skuGroup2Sku(skuBatch(batch));
nameSkuGroup2Batch 'Направление' (batch) = nameSkuGroup(skuGroup2Batch(batch));

skuGroup3Batch 'Группа' (batch) = skuGroup3Sku(skuBatch(batch));
nameSkuGroup3Batch 'Группа' (batch) = nameSkuGroup(skuGroup3Batch(batch));

skuGroup4Batch 'Подгруппа' (batch) = skuGroup4Sku(skuBatch(batch));
nameSkuGroup4Batch 'Подгруппа' (batch) = nameSkuGroup(skuGroup4Batch(batch));

skuGroup5Batch 'Субгруппа' (batch) = skuGroup5Sku(skuBatch(batch));
nameSkuGroup5Batch 'Субгруппа' (batch) = nameSkuGroup(skuGroup5Batch(batch));

// ---------------------------------------------- Макросы ------------------------------------------------ //

META implementSkuLedger(object, skuProp, stockProp)
    dateTimeDataSkuLedger (ledger) += dateTime###object(ledger);
    isPostedDataSkuLedger (ledger) += isPosted###object(ledger);
    skuDataSkuLedger (ledger) += skuProp###object(ledger);
    stockDataSkuLedger (ledger) += stockProp###object(ledger);
    descriptionDataSkuLedger (ledger) += description###object(ledger);
END

META defineSkuLedgerAggregation(primObject, aggrObject, skuProp, stockProp)
    dateTime###aggrObject (batch) = dateTime###primObject(primObject###aggrObject(batch));
    isPosted###aggrObject (batch) = isPosted###primObject(primObject###aggrObject(batch));
    sku###aggrObject (batch) = sku###primObject(primObject###aggrObject(batch));
    stock###aggrObject (batch) = stockProp###primObject(primObject###aggrObject(batch));
    description###aggrObject (batch) = description###primObject(primObject###aggrObject(batch));
END

META implementSkuLedgerInLIFO(object, skuProp, stockProp)
    EXTEND CLASS object : InLIFOSkuLedger;
    @implementSkuLedger(object, skuProp, stockProp);
END

META implementSkuLedgerInLIFOBatchBalancePostfix (object, stockProp, postfix)
    limitInLIFOSkuLedgerBatch(ledger, batch) += IF batch###object(ledger) THEN
                                                    quantity###object(ledger) IF batch == batch###object(ledger)
                                                 ELSE
                                                    outcome##postfix##Batch(batch) IF
                                                    countLedger##postfix##BatchStock(batch, stockProp###object(ledger));
    changedDataSkuLedger(ledger) += CHANGED(batch###object(ledger));
END

META implementSkuLedgerInLIFOBatchBalance (object, stockProp)
    @implementSkuLedgerInLIFOBatchBalancePostfix(object, stockProp, );
END

META implementSkuLedgerInLIFOBalancePostfix (object, stockProp, postfix)
    limitInLIFOSkuLedgerBatch(ledger, batch) += outcome##postfix##Batch(batch) IF
                                                countLedger##postfix##BatchStock(batch, stockProp###object(ledger));
END

META implementSkuLedgerInLIFOBalance (object, stockProp)
    @implementSkuLedgerInLIFOBalancePostfix(object, stockProp, );
END

META implementSkuLedgerOutFIFO(object, skuProp, stockProp)
    EXTEND CLASS object : OutFIFOSkuLedger;
    @implementSkuLedger(object, skuProp, stockProp);
END

META implementSkuLedgerOutFIFOBatchBalancePostfix (object, stockProp, postfix)
    limitOutFIFOSkuLedgerBatch(ledger, batch) += IF batch###object(ledger) THEN
                                                    quantity###object(ledger) IF batch == batch###object(ledger)
                                                 ELSE
                                                    currentBalance##postfix##BatchStock(batch, stockProp###object(ledger));
    changedDataSkuLedger(ledger) += CHANGED(batch###object(ledger));
END

META implementSkuLedgerOutFIFOBatchBalance (object, stockProp)
    @implementSkuLedgerOutFIFOBatchBalancePostfix(object, stockProp, );
END

META implementSkuLedgerOutFIFOBalancePostfix (object, stockProp, postfix)
    limitOutFIFOSkuLedgerBatch(ledger, batch) += currentBalance##postfix##BatchStock(batch, stockProp###object(ledger));
END

META implementSkuLedgerOutFIFOBalance (object, stockProp)
    @implementSkuLedgerOutFIFOBalancePostfix(object, stockProp, );
END

META implementBatchCustom(object, skuProp, stockProp, costProp)
    dateTimeBatch (batch) += dateTime###object(batch);
    isPostedBatch (batch) += isPosted###object(batch);
    skuBatch (batch) += skuProp###object(batch);
    stockBatch (batch) += stockProp###object(batch);
    descriptionBatch (batch) += description###object(batch);
    costBatch (batch) += costProp###object(batch);
END //-- (не забывать имплементить nameBatch)

META implementBatch(object, skuProp, stockProp, costProp)
    EXTEND CLASS object : Batch;
    @implementBatchCustom(object, skuProp, stockProp, costProp);
END

META defineConstraintSkuLedgerCosted (concrete, caption)
    CONSTRAINT (SET(changedCostDataSkuLedger(detail)) OR CHANGED(costedDataSkuLedger(detail))) AND isPosted###concrete##Detail(detail) AND NOT quantity###concrete##Detail(detail) == costedDataSkuLedger(detail)
        MESSAGE caption;
END

//-------------------------------------------------- Добавление партий в документ --------------------------------------//

META defineDocumentDetailBatchCustomPrefix(detail, batchProp, prefix)
    @defineDocumentDetailBatchCustomPrefixInner(detail, batchProp, ###batchProp, prefix);
END

META defineDocumentDetailBatchCustomPrefixInner(detail, batchProp, batchClass, prefix)
    prefix###batchProp###detail = DATA batchClass (###detail);
    prefix###description###batchProp###detail 'Партия' (detail) = descriptionBatch(prefix###batchProp###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
    prefix###name###batchProp###detail 'Партия' (detail) = nameBatch(prefix###batchProp###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;

    CONSTRAINT skuBatch(prefix###batchProp###detail(detail)) != prefix###sku###detail(detail) CHECKED BY prefix###batchProp###detail
        MESSAGE 'Товар партии строки должен соответствовать SKU строки';

    CONSTRAINT prefix###batchProp###detail(detail) AND NOT prefix###sku###detail(detail) CHECKED BY prefix###batchProp###detail
        MESSAGE 'Для строки задана партия, но не задан товар';
END

//META defineDocumentDetailBatchCustom(detail, batchProp)
//    batch###detail = DATA batchProp (Detail);
//    descriptionBatch###detail 'Партия' (detail) = descriptionBatch(batch###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
//
//    CONSTRAINT skuBatch(batch###detail(detail)) != sku###detail(detail) CHECKED BY batch###detail
//        MESSAGE 'Товар партии строки должен соответствовать SKU строки';
//
//    CONSTRAINT batch###detail(detail) AND NOT sku###detail(detail) CHECKED BY batch###detail
//        MESSAGE 'Для строки задана парктия, но не задан товар';
//END
META defineDocumentDetailBatchCustom(detail, batchProp)
    @defineDocumentDetailBatchCustomPrefix(detail, batchProp, );
END

META defineDocumentAbstractDetailBatchCustom(detail, batchProp)
    @defineDocumentAbstractDetailBatchCustomInner(detail, batchProp, ###batchProp);
END

META defineDocumentAbstractDetailBatchCustomInner(detail, batchProp, batchClass)
    batch###detail = ABSTRACT batchClass (###detail) PERSISTENT;
    descriptionBatch###detail 'Партия' (detail) = descriptionBatch(batch###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
    nameBatch###detail 'Партия' (detail) = nameBatch(batch###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
END
META defineDocumentInterfaceDetailBatchCustom(detail, batchProp)
    @defineDocumentAbstractDetailBatchCustom(detail, batchProp);
    @defineDocumentDetailBatchCustom(user###detail, batchProp);
    batch###detail(detail) += batch###user###detail(detail);
END

META defineDocumentDetailBatch(object, batchProp)
    @defineDocumentDetailBatchCustom(object##Detail, batchProp);
END
META defineDocumentAbstractDetailBatch(object, batchProp)
    @defineDocumentAbstractDetailBatchCustom(object##Detail, batchProp);
END
META defineDocumentInterfaceDetailBatch(object, batchProp)
    @defineDocumentInterfaceDetailBatchCustom(object##Detail, batchProp);
END

META defineDocumentDetailExpiryDateCustomPrefix(detail, prefix)
    prefix###expiryDate###detail 'Годен до' = DATA DATE (###detail);
END
META defineDocumentAbstractDetailExpiryDateCustomPrefix(detail, prefix)
    prefix###expiryDate###detail 'Годен до' = ABSTRACT DATE (###detail) PERSISTENT;
END
META defineDocumentInterfaceDetailExpiryDateCustomPrefix(detail, prefix)
    @defineDocumentAbstractDetailExpiryDateCustomPrefix(detail, prefix);
    @defineDocumentDetailExpiryDateCustomPrefix(user###detail, prefix);
    prefix###expiryDate###detail(detail) += prefix###expiryDate###user###detail(detail);
END

META defineDocumentInterfaceDetailExpiryDatePrefix(object, prefix)
    @defineDocumentInterfaceDetailExpiryDateCustomPrefix(object##Detail, prefix);
END

META defineDocumentInterfaceDetailExpiryDate(object)
    @defineDocumentInterfaceDetailExpiryDatePrefix(object, );
END

META defineDocumentDetailManufactureDateCustomPrefix(detail, prefix)
    prefix###manufactureDate###detail 'Дата изготовления' = DATA DATE (###detail);
END
META defineDocumentAbstractDetailManufactureDateCustomPrefix(detail, prefix)
    prefix###manufactureDate###detail 'Дата изготовления' = ABSTRACT DATE (###detail) PERSISTENT;
END
META defineDocumentInterfaceDetailManufactureDateCustomPrefix(detail, prefix)
    @defineDocumentAbstractDetailManufactureDateCustomPrefix(detail, prefix);
    @defineDocumentDetailManufactureDateCustomPrefix(user###detail, prefix);
    prefix###manufactureDate###detail(detail) += prefix###manufactureDate###user###detail(detail);
END

META defineDocumentInterfaceDetailManufactureDatePrefix(object, prefix)
    @defineDocumentInterfaceDetailManufactureDateCustomPrefix(object##Detail, prefix);
END

META defineDocumentInterfaceDetailManufactureDate(object)
    @defineDocumentInterfaceDetailManufactureDatePrefix(object, );
END

// ---------------------------------- Остаток (до) ----------------------- //

META defineDocumentDetailSkuBalanceCustom (detail)
    balanceBSku###detail 'Количество до' (detail) = DATA NUMERIC[14,3] (###detail);

END
META defineDocumentAbstractDetailSkuBalanceCustom (detail)
    balanceBSku###detail 'Количество до' (detail) = ABSTRACT NUMERIC[14,3] (###detail) PERSISTENT;
END

META defineDocumentInterfaceDetailSkuBalanceCustom(detail)
    @defineDocumentAbstractDetailSkuBalanceCustom(detail);
    @defineDocumentDetailSkuBalanceCustom(user###detail);
    balanceBSku###detail(detail) += balanceBSku###user###detail(detail);
END
META defineDocumentInterfaceDetailSkuBalance(object)
    @defineDocumentInterfaceDetailSkuBalanceCustom(object##Detail);
END

META deriveDocumentDetailSkuBalanceCustom (detail, skuProp, stockProp)
    balanceBSku###detail (detail)  <- [= PREV(balanceBSkuStockDateTime(sku, stock, dateTime) IF dateTime IS DATETIME)](skuProp###detail(detail), stockProp###detail(detail), dateTime###detail(detail))
        WHEN CHANGED(skuProp###detail(detail)) OR CHANGED(stockProp###detail(detail)) OR CHANGED(dateTime###detail(detail));
END
META deriveDocumentDetailSkuBalance (object, skuProp, stockProp)
    @deriveDocumentDetailSkuBalanceCustom(object##Detail, skuProp, stockProp);
END
