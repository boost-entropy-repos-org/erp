MODULE SkuLedger;

REQUIRE Stock, Sku, EmployeeStock, Document;

NAMESPACE Stock;

// ----------------------------------- Ledger ------------------------------------------ //

CLASS ABSTRACT COMPLEX SkuLedger 'Изменение остатка по товару';
TABLE skuLedger (SkuLedger) FULL;

CLASS ABSTRACT InSkuLedger 'Приход' : SkuLedger;
CLASS ABSTRACT OutSkuLedger 'Расход' : SkuLedger;

CLASS ABSTRACT Batch 'Партия' : InSkuLedger;

CLASS ABSTRACT DataSkuLedger 'Изменение остатка с первичной себестоимостью' : SkuLedger;

CLASS ABSTRACT InLIFOSkuLedger 'Приход по LIFO' : InSkuLedger, DataSkuLedger;
CLASS ABSTRACT OutFIFOSkuLedger 'Расход по FIFO' : OutSkuLedger, DataSkuLedger;

editSkuLedger 'Редактировать' = ABSTRACT ACTION LIST (SkuLedger) IMAGE 'edit.png' EDITKEY 'BACK_SPACE' HIDE TOOLBAR;
replaceSkuBatch = ABSTRACT ACTION LIST (Sku, Batch);
// --------------------------------- Партии ------------------------------------------------ //

TABLE batch(Batch);
TABLE skuLedgerBatch (SkuLedger, Batch);
TABLE batchStock(Batch, Stock);

dateTimeBatch 'Дата/время' (batch) = ABSTRACT DATETIME (Batch) PERSISTENT INDEXED;
dateBatch 'Дата' (batch) = toDate(dateTimeBatch(batch));
timeBatch 'Время' (batch) = toTime(dateTimeBatch(batch));

isPostedBatch 'Проведен' (batch) = ABSTRACT BOOLEAN (Batch) PERSISTENT;

isClosedBatch 'Закрыт' (batch) = ABSTRACT BOOLEAN (Batch);

skuBatch (batch) = ABSTRACT Sku (Batch) PERSISTENT INDEXED;
nameSkuBatch 'Наименование' (batch) = nameSku(skuBatch(batch)) IN recognize;

// Наименование для документов
overDocumentNameSkuBatch = ABSTRACT VARISTRING[255] (Batch) PERSISTENT;
documentNameSkuBatch 'Наименование (для документов)' (batch) = OVERRIDE nameSkuBatch(batch), overDocumentNameSkuBatch(batch);

useDocumentNameSku 'Использовать наименование для документов' = DATA BOOLEAN ();

EXTEND FORM options
    PROPERTIES() useDocumentNameSku
;

DESIGN options {
    pane {
        stock1 {
            MOVE PROPERTY(useDocumentNameSku());
        }
    }
}

lastBatchSku (sku) = GROUP LAST batch 
    BY skuBatch(batch)
    ORDER dateTimeBatch(batch), batch
    WHERE dateTimeBatch(batch);

netWeightSkuBatch 'Вес нетто' (batch) = netWeightSku(skuBatch(batch));
grossWeightSkuBatch 'Вес брутто' (batch) = grossWeightSku(skuBatch(batch));
prevNameSkuBatch 'Наименование' (batch) = PREV(nameSku(skuBatch(batch))) IN recognize;
activeSkuBatch 'Активные' (batch) = activeSku(skuBatch(batch));

UOMBatch(batch)= UOMSku(skuBatch(batch));
shortNameUOMBatch 'Единица измерений' (batch)= shortNameUOMSku(skuBatch(batch));

countryBatch (batch) = countrySku(skuBatch(batch));
sidOrigin2CountryBatch (batch) = sidOrigin2Country(countryBatch(batch));

stockBatch (batch) = ABSTRACT Stock (Batch) PERSISTENT INDEXED ;
nameStockBatch 'Склад' (batch) = nameStock(stockBatch(batch));

costBatch 'Себестоимость' (batch) = ABSTRACT NUMERIC[14,2] (Batch) PERSISTENT;
prevCostBatch 'Себестоимость' (batch) = PREV(costBatch(batch));

descriptionBatch 'Описание' (batch) = ABSTRACT VARSTRING[200] (Batch) PERSISTENT IN recognize MINCHARWIDTH 30 PREFCHARWIDTH 60;
nameBatch 'Название' (batch) = ABSTRACT VARISTRING[200] (Batch) PERSISTENT IN recognize MINCHARWIDTH 30 PREFCHARWIDTH 60;

expiryDateBatch 'Годен до' (batch) = ABSTRACT DATE (Batch) PERSISTENT INDEXED;
prevExpiryDateBatch 'Годен до' (batch) = PREV(expiryDateBatch(batch));

manufactureDateBatch 'Дата изготовления' (batch) = ABSTRACT DATE (Batch) PERSISTENT INDEXED;
prevManufactureDateBatch 'Дата изготовления' (batch) = PREV(manufactureDateBatch(batch));

numberBatch 'Номер документа' = ABSTRACT STRING[18] (Batch) MINCHARWIDTH 8 PERSISTENT;
seriesBatch 'Серия документа' = ABSTRACT STRING[2] (Batch) FIXEDCHARWIDTH 3 PERSISTENT;
seriesNumberBatch 'Серия/Номер' (o) = CONCAT '', seriesBatch(o), numberBatch(o) MINCHARWIDTH 7 PREFCHARWIDTH 10 MAXCHARWIDTH 20 PERSISTENT;
    
supplierBatch = ABSTRACT LegalEntity (Batch) PERSISTENT;
prevSupplierBatch (batch) = PREV(supplierBatch(batch));

nameSupplierBatch 'Поставщик' (batch) = nameLegalEntity(supplierBatch(batch));
fullNameSupplierBatch 'Поставщик' (batch) = fullNameLegalEntity(supplierBatch(batch));

idSupplierBatch 'Код поставщика' (batch) = idLegalEntity(supplierBatch(batch));
addressSupplierBatch 'Адрес поставщика' (batch) = addressLegalEntity(supplierBatch(batch));

supplierGroupBatch (batch) = legalEntityGroupLegalEntity(supplierBatch(batch));

supplierStockBatch = ABSTRACT Stock (Batch) PERSISTENT;
nameSupplierStockBatch 'Склад поставщика' (batch) = nameStock(supplierStockBatch(batch));

idBatch 'Код партии' (batch) = ABSTRACT VARSTRING[100] (Batch) PERSISTENT MINCHARWIDTH 10 PREFCHARWIDTH 15;
batchId (id) = GROUP MAX batch BY idBatch (batch);

expiresBatchDateTime(batch, dateTime, period) = expiryDateBatch(batch) < sumDate(toDate(dateTime), period);
expiresBatchDate(batch, date, period) = expiryDateBatch(batch) < sumDate(date, period);

orderBatch (batch) = STRUCT(dateTimeBatch(batch), batch) PERSISTENT;

isSkuBatch (batch, sku) = skuBatch(batch) == sku;

isParentSkuGroupBatch (skuGroup, batch) = isParentSkuGroupSku(skuGroup, skuBatch(batch));
isParentGroupBatch (group, batch) = isParentGroupSku(group, skuBatch(batch));

isItemBatch 'Товар' = isItemSku(skuBatch(bt));
isContainerBatch 'Тара' = isContainerSku(skuBatch(bt));

isNotItemBatch 'Не товар' = isNotItemSku(skuBatch(bt));
isNotContainerBatch 'Не тара' = isNotContainerSku(skuBatch(bt));

batchSkuLedger = ABSTRACT Batch (SkuLedger) PERSISTENT INDEXED;
nameBatchSkuLedger 'Партия' (l) = nameBatch(batchSkuLedger(l));

//---------------------------- Количественные регистры (конкретная реализация) ----------------------------------------//

dateTimeDataSkuLedger 'Дата/время' = ABSTRACT DATETIME (DataSkuLedger) PERSISTENT INDEXED;
dateDataSkuLedger 'Дата' (ledger) = toDate(dateTimeDataSkuLedger(ledger)) PERSISTENT;

isPostedDataSkuLedger 'Проведен' = ABSTRACT BOOLEAN (DataSkuLedger) PERSISTENT;

isClosedDataSkuLedger 'Закрыт' = ABSTRACT BOOLEAN (SkuLedger);

skuDataSkuLedger = ABSTRACT Sku (DataSkuLedger) PERSISTENT INDEXED;

stockDataSkuLedger = ABSTRACT Stock(DataSkuLedger) PERSISTENT INDEXED;

descriptionDataSkuLedger 'Название документа' = ABSTRACT VARSTRING[200] (DataSkuLedger) PERSISTENT;

changedDataSkuLedger = ABSTRACT BOOLEAN (DataSkuLedger);

// -------------------------------- Для всего ledger'а -------------------- //

dateTimeSkuLedger 'Дата/время' (ledger) = MULTI dateTimeDataSkuLedger (ledger), dateTimeBatch (ledger) PERSISTENT INDEXED IN recognize;
dateSkuLedger 'Дата' (ledger) = toDate(dateTimeSkuLedger(ledger)) PERSISTENT INDEXED;

isPostedSkuLedger 'Проведен' (ledger) = MULTI isPostedDataSkuLedger (ledger), isPostedBatch (ledger) PERSISTENT;

isClosedSkuLedger 'Закрыт' (ledger) = MULTI isClosedDataSkuLedger (ledger), isClosedBatch (ledger);

skuSkuLedger (ledger) = MULTI skuDataSkuLedger (ledger), skuBatch (ledger) PERSISTENT;
nameSkuSkuLedger 'SKU' (ledger) = nameSku(skuSkuLedger(ledger)) IN recognize;

INDEX skuSkuLedger, dateTimeSkuLedger;

canonicalNameSkuGroupSkuLedger 'Группа' (ledger) = canonicalNameGroup(skuGroupSku(skuSkuLedger(ledger)));

countSkuLedgerSku = GROUP SUM 1 BY skuSkuLedger(ledger);

stockSkuLedger (ledger) = MULTI stockDataSkuLedger (ledger), stockBatch (ledger) PERSISTENT INDEXED;
nameStockSkuLedger 'Склад' (ledger) = nameStock(stockSkuLedger(ledger)) IN recognize;
isCompanyStockSkuLedger (ledger) = isCompanyStock(stockSkuLedger(ledger));
idStockSkuLedger (ledger) = idStock(stockSkuLedger(ledger));

descriptionSkuLedger 'Описание' (ledger) = MULTI descriptionDataSkuLedger (ledger), descriptionBatch (ledger) PERSISTENT IN recognize;

isItemSkuLedger 'Товар' = isItemSku(skuSkuLedger(l));
isContainerSkuLedger 'Тара' = isContainerSku(skuSkuLedger(l));

isNotItemSkuLedger 'Не товар' = isNotItemSku(skuSkuLedger(l));
isNotContainerSkuLedger 'Не тара' = isNotContainerSku(skuSkuLedger(l));

// -------------------------------- Количества ---------------------------- //

quantityBatch 'Кол-во в партии' = ABSTRACT NUMERIC[14,3] (Batch) PERSISTENT;

extraShippedQuantityBatch = ABSTRACT NUMERIC[14,3] (Batch);
shippedQuantityBatch 'Кол-во в партии (всего)' (batch) = quantityBatch(batch) (+) extraShippedQuantityBatch(batch) PERSISTENT;

quantityInLIFOSkuLedger 'Кол-во' (ledger) = ABSTRACT NUMERIC[14,3] (InLIFOSkuLedger) PERSISTENT;

quantityInSkuLedger 'Кол-во' (ledger) = MULTI quantityBatch(ledger),
                                              quantityInLIFOSkuLedger(ledger) PERSISTENT;

quantityOutFIFOSkuLedger 'Кол-во' = ABSTRACT NUMERIC[14,3] (OutFIFOSkuLedger) PERSISTENT;

quantityOutSkuLedger 'Кол-во' (ledger) = MULTI quantityOutFIFOSkuLedger(ledger) PERSISTENT;

quantityDataSkuLedger 'Кол-во' (ledger) = MULTI quantityInLIFOSkuLedger(ledger),
                                                quantityOutFIFOSkuLedger(ledger) PERSISTENT;

quantitySkuLedger 'Кол-во' (ledger) = MULTI quantityInSkuLedger(ledger),
                                            quantityOutSkuLedger(ledger) PERSISTENT;

signedQuantitySkuLedger 'Кол-во' (ledger) = MULTI quantityInSkuLedger(ledger),
                                                  -quantityOutSkuLedger(ledger) PERSISTENT;

// -------------------------------------------- Расчет себестоимости -------------------------------------- //

explicitBatchLedgerStock 'Обязательный партионный учет' = ABSTRACT BOOLEAN (Stock) PERSISTENT IN bookkeeping;
skipExplicitBatchSkuLedger 'Разрешить регистр без партии' = ABSTRACT BOOLEAN (SkuLedger);
CONSTRAINT explicitBatchLedgerStock(stockSkuLedger(l)) AND isPostedSkuLedger(l) AND NOT batchSkuLedger(l) AND NOT skipExplicitBatchSkuLedger(l)
    MESSAGE 'Не выбрана партия для строки движения товара';
    
showPriceBatchLedgerStock(s) = isCompanyStock(s) AND NOT explicitBatchLedgerStock(s);   
dataPriceBatchLedgerStock 'Использовать свои цены для каждой партии' = ABSTRACT BOOLEAN (Stock);
priceBatchLedgerStock 'Использовать свои цены для каждой партии' (s) = dataPriceBatchLedgerStock(s) OR explicitBatchLedgerStock(s) PERSISTENT;  

orderDataSkuLedger (ledger) = STRUCT(dateTimeDataSkuLedger(ledger), ledger);

// Свойства для расчета себестоимости
quantityBatchBatch 'Кол-во' (ledger, batch) = quantityBatch(ledger) IF batch == ledger;

costDataSkuLedgerBatch 'Расписано из партии (перв.)' (ledger, batch) = DATA NUMERIC[14,3] (DataSkuLedger, Batch);

costSkuLedgerBatch 'Расписано из партии' (ledger, batch) = MULTI quantityBatchBatch(ledger, batch),
                                                                 costDataSkuLedgerBatch(ledger, batch) PERSISTENT;

maxBatchCostSkuLedger 'Последняя партия, из которой расписано' (ledger) = GROUP MAX batch IF  costSkuLedgerBatch(ledger, batch) BY ledger;
countBatchCostSkuLedger 'Кол-во партий' (ledger) = GROUP SUM 1 IF costSkuLedgerBatch(ledger, batch) BY ledger;


signedCostSkuLedgerBatch (ledger, batch) = IF ledger IS OutSkuLedger
                                              THEN -costSkuLedgerBatch(ledger, batch)
                                              ELSE costSkuLedgerBatch(ledger, batch);

// Расчет себестоимости по Action
costedDataSkuLedger 'Расписано' (ledger) = GROUP SUM costDataSkuLedgerBatch (ledger, batch) BY ledger PERSISTENT;
costedSkuLedger 'Расписано' (ledger) = GROUP SUM costSkuLedgerBatch (ledger, batch) BY ledger PERSISTENT;
notCostedSkuLedger 'Не расписано' (ledger) = quantitySkuLedger(ledger) (-) costedSkuLedger(ledger);
signedNotCostedSkuLedger 'Не расписано' (ledger) = IF ledger IS OutSkuLedger THEN
                                                                        quantitySkuLedger(ledger) (-) costedSkuLedger(ledger)
                                                                    ELSE
                                                                        costedSkuLedger(ledger) (-) quantitySkuLedger(ledger);

// Суммы

costSumSkuLedgerBatch 'Сумма поставщика без НДС' (ledger, batch) = NUMERIC[16,3](costSkuLedgerBatch(ledger, batch) * costBatch(batch));
costSumSkuLedger 'Сумма поставщика без НДС' = GROUP SUM costSumSkuLedgerBatch(ledger, batch) BY ledger;

// ---------------------------- Учетные цены и суммы ------------------------------- //

// сумма операции
sumInSkuLedger 'Сумма' (ledger) = ABSTRACT NUMERIC[16,2] (InSkuLedger) PERSISTENT;
sumOutSkuLedger 'Сумма' (ledger) = ABSTRACT NUMERIC[16,2] (OutSkuLedger) PERSISTENT;

sumSkuLedger 'Сумма' = MULTI sumInSkuLedger(ledger),
                             sumOutSkuLedger(ledger) PERSISTENT;
                              
signedSumSkuLedger 'Сумма' (ledger) = MULTI sumInSkuLedger(ledger),
                                            -sumOutSkuLedger(ledger) PERSISTENT;
                                            
signedPriceSkuLedger 'Цена' (ledger)= signedSumSkuLedger(ledger)/signedQuantitySkuLedger(ledger) IF NOT signedQuantitySkuLedger(ledger) == 0.0;                                            

// ---------------------------- Остаток по товару -------------------------------- //

TABLE skuStock(Sku, Stock);
TABLE extraSkuStock(Sku, Stock);
TABLE skuStockDate(Sku, Stock, DATE);
TABLE batchStockDate(Batch, Stock, DATE);

TABLE skuGroupStock(SkuGroup, Stock);
TABLE skuStockGroup(Sku, StockGroup);

META defineSkuLedgerBalanceProperties(postfix, caption)
    skip##postfix##SkuLedger 'Не проводить по учету'###caption = ABSTRACT BOOLEAN (SkuLedger) PERSISTENT;
    active##postfix##SkuLedger 'Активен'###caption (ledger) = isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;

    signedQuantityActive##postfix##SkuLedger(ledger) = signedQuantitySkuLedger(ledger) IF active##postfix##SkuLedger(ledger) PERSISTENT;

    currentBalance##postfix##SkuStock 'Текущий остаток'###caption (sku, stock) =
        GROUP SUM signedQuantityActive##postfix##SkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger) PERSISTENT;
    prevCurrentBalance##postfix##SkuStock 'Текущий остаток'###caption (sku, stock) = PREV(currentBalance##postfix##SkuStock(sku, stock));
    prevCurrentBalance##postfix##Sku 'Текущий остаток'###caption (sku) = GROUP SUM prevCurrentBalance##postfix##SkuStock(sku, stock) BY sku;
    countLedger##postfix##SkuStock 'Кол-во движений'###caption (sku, stock) =
        GROUP SUM 1 IF signedQuantityActive##postfix##SkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger) PERSISTENT TABLE extraSkuStock;

    quantityInActiveSkuLedger(ledger) = quantityInSkuLedger(ledger) IF isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;
    quantityIn##postfix##SkuStockDate (sku, stock, date) =
        GROUP SUM quantityInActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT;

    quantityOutActiveSkuLedger(ledger) = quantityOutSkuLedger(ledger) IF isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;
    quantityOut##postfix##SkuStockDate (sku, stock, date) =
        GROUP SUM quantityOutActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT;

    quantity##postfix##SkuStockDate (sku, stock, date) = quantityIn##postfix##SkuStockDate(sku, stock, date)
                                                         (+)
                                                         quantityOut##postfix##SkuStockDate(sku, stock, date) PERSISTENT;

    signedQuantity##postfix##SkuStockDate (sku, stock, date) = quantityIn##postfix##SkuStockDate(sku, stock, date)
                                                               (-)
                                                               quantityOut##postfix##SkuStockDate(sku, stock, date) PERSISTENT;

    quantitySumIn##postfix##SkuStockDateDate 'Кол-во товара пришедшего за период' (sku, stock, date1, date2) =
        GROUP SUM quantityIn##postfix##SkuStockDate(sku, stock, dateIn) IF dateIn>=date1 IF dateIn<=date2
        BY sku, stock, date1, date2;
    quantitySumIn##postfix##GroupStockDateDate 'Кол-во товара пришедшего за период' (group, stock, date1, date2) =
        GROUP SUM quantitySumIn##postfix##SkuStockDateDate(sku, stock, date1, date2) IF isParentGroupSku(group, sku)
        BY group, stock, date1, date2;

    quantitySumOut##postfix##SkuStockDateDate 'Кол-во товара ушедшего за период' (sku, stock, date1, date2) =
        GROUP SUM quantityOut##postfix##SkuStockDate(sku, stock, dateIn) IF dateIn>=date1 IF dateIn<=date2
        BY sku, stock, date1, date2;
    quantitySumOut##postfix##GroupStockDateDate 'Кол-во товара ушедшего за период' (group, stock, date1, date2) =
        GROUP SUM quantitySumOut##postfix##SkuStockDateDate (sku, stock, date1, date2) IF isParentGroupSku(group, sku)
        BY group, stock, date1, date2;

    // без учета текущей даты/времени
    balanceB##postfix##SkuStockDate 'Остаток на начало дня'###caption (sku, stock, date) = currentBalance##postfix##SkuStock(sku, stock)
                                                                      (-) [= GROUP SUM signedQuantity##postfix##SkuStockDate (sku, stock, dateIn) IF dateIn >= date
                                                                                 BY sku, stock, date](sku, stock, date);

    // с учетом текущей даты/времени
    balanceA##postfix##SkuStockDate 'Остаток на конец дня'###caption (sku, stock, date) = currentBalance##postfix##SkuStock(sku, stock)
                                                                     (-) [= GROUP SUM signedQuantity##postfix##SkuStockDate (sku, stock, dateIn) IF dateIn > date
                                                                                BY sku, stock, date](sku, stock, date);

    // без учета текущей даты/времени
    balanceB##postfix##SkuStockDateTime 'Остаток (до)'###caption (sku, stock, dateTime) = currentBalance##postfix##SkuStock(sku, stock)
                                                                              (-) [= GROUP SUM signedQuantityActive##postfix##SkuLedger(ledger) IF dateTimeSkuLedger(ledger) >= dateTime
                                                                                         BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateTime](sku, stock, dateTime);
    prevBalanceB##postfix##SkuStockDateTime 'Остаток (до)'###caption (sku, stock, dateTime) = PREV(balanceB##postfix##SkuStockDateTime(sku, stock, dateTime) IF dateTime IS DATETIME);

    // с учетом текущей даты/времени
    balanceA##postfix##SkuStockDateTime 'Остаток (после)'###caption (sku, stock, dateTime) = currentBalance##postfix##SkuStock(sku, stock)
                                                                             (-) [= GROUP SUM signedQuantityActive##postfix##SkuLedger(ledger) IF dateTimeSkuLedger(ledger) > dateTime
                                                                                        BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateTime](sku, stock, dateTime);
    prevBalanceA##postfix##SkuStockDateTime 'Остаток (после)'###caption (sku, stock, dateTime) = PREV(balanceA##postfix##SkuStockDateTime(sku, stock, dateTime) IF dateTime IS DATETIME);

    balanceA##postfix##GroupStockDateTime 'Остаток (после)'###caption (group,  stock, dateTime) =
        GROUP SUM balanceA##postfix##SkuStockDateTime (sku, stock, dateTime) IF isParentGroupSku(group, sku)
        BY group, stockSkuLedger(ledger), dateTime;
        
    balanceB##postfix##StockDate 'Остаток на начало дня' (stock, date) = GROUP SUM balanceB##postfix##SkuStockDate(sku, stock, date) BY stock, date;

    currentBalance##postfix##Sku 'Остаток (всего)'###caption (sku) = GROUP SUM currentBalance##postfix##SkuStock(sku, stock) BY sku;

    signedQuantityActive##postfix##SkuLedgerBatch(ledger, batch) = signedCostSkuLedgerBatch(ledger, batch) IF active##postfix##SkuLedger(ledger) PERSISTENT;
    
    signedActiveCostSum##postfix##SkuLedgerBatch 'Себестоимость' (ledger, batch) = NUMERIC[16,3](signedQuantityActive##postfix##SkuLedgerBatch(ledger, batch) * costBatch(batch));
    signedActiveCostSum##postfix##SkuLedger 'Себестоимость' = GROUP SUM signedActiveCostSum##postfix##SkuLedgerBatch(ledger, batch) BY ledger;
    
    currentBalance##postfix##BatchStock 'Текущий остаток'###caption (batch, stock) = GROUP SUM signedQuantityActive##postfix##SkuLedgerBatch(ledger, batch)
                                                                                           BY batch, stockSkuLedger(ledger) PERSISTENT;
    prevCurrentBalance##postfix##BatchStock 'Текущий остаток'###caption (batch, stock) = PREV(currentBalance##postfix##BatchStock(batch, stock));
    prevCurrentBalance##postfix##Batch 'Текущий остаток'###caption (batch) = GROUP SUM prevCurrentBalance##postfix##BatchStock(batch, stock) BY batch;    

    count##postfix##BatchSkuStock 'Кол-во партий' (sku, stock) = GROUP SUM 1  IF currentBalance##postfix##BatchStock(batch, stock)
                                                                 BY skuBatch(batch), stock;
    default##postfix##BatchSkuStock 'Партия по умолчанию' (sku, stock)= GROUP MIN batch IF currentBalance##postfix##BatchStock(batch, stock)
                                                                        BY skuBatch(batch), stock;
    
    countPositive##postfix##BatchSkuStock 'Кол-во партий' (sku, stock) = GROUP SUM 1  IF currentBalance##postfix##BatchStock(batch, stock) >0
                                                                 BY skuBatch(batch), stock;
    defaultPositive##postfix##BatchSkuStock 'Партия по умолчанию' (sku, stock)= GROUP MIN batch IF currentBalance##postfix##BatchStock(batch, stock) >0
                                                                        BY skuBatch(batch), stock;

    countLedger##postfix##BatchStock 'Кол-во движений'###caption (batch, stock) =
        GROUP SUM 1 IF signedQuantityActive##postfix##SkuLedgerBatch(ledger, batch) BY batch, stockSkuLedger(ledger) PERSISTENT;

    countLedger##postfix##BatchStockDateDate 'Кол-во движений за период'###caption (batch, stock, dateFrom, dateTo) =
        GROUP SUM 1 IF signedQuantityActive##postfix##SkuLedgerBatch(ledger, batch) AND dateSkuLedger(ledger) >= dateFrom AND dateSkuLedger(ledger) <= dateTo
        BY batch, stockSkuLedger(ledger), dateFrom, dateTo;
        
    lastOrderBatch##postfix##SkuStock(sku, stock)  =
        GROUP LAST batch
              BY skuBatch(batch), stock
              ORDER orderBatch(batch)
              WHERE countLedger##postfix##BatchStock(batch, stock) COMPLEX PERSISTENT TABLE extraSkuStock;

//    orderBatch##postfix##SkuStock (sku, stock) = GROUP MAX orderBatch(batch) IF countLedger##postfix##BatchStock(batch, stock)
//                                                       BY skuBatch(batch), stock PERSISTENT;
//    lastOrderBatch##postfix##SkuStock(sku, stock) = orderBatch##postfix##SkuStock(sku, stock)[2] PERSISTENT;
    prevLastOrderBatch##postfix##SkuStock(sku, stock) = PREV(lastOrderBatch##postfix##SkuStock(sku, stock));
    dateTimeLastOrderBatch##postfix##SkuStock 'Время последней партии' (sku, stock) = dateTimeBatch(lastOrderBatch##postfix##SkuStock(sku, stock));
    supplierLastOrderBatch##postfix##SkuStock (sku, stock) = supplierBatch(lastOrderBatch##postfix##SkuStock(sku, stock));
    nameSupplierLastOrderBatch##postfix##SkuStock 'Поставщик последней партии' (sku, stock) = nameSupplierBatch(lastOrderBatch##postfix##SkuStock(sku, stock));
    supplierStockLastOrderBatch##postfix##SkuStock (sku, stock) = supplierStockBatch(lastOrderBatch##postfix##SkuStock(sku, stock));
    
    lastBatchManufactureDate##postfix##SkuStock 'Дата изготовления последней партии' (sku, stock) = manufactureDateBatch(lastOrderBatch##postfix##SkuStock(sku, stock));
    lastBatchExpiryDate##postfix##SkuStock 'Срок годности последней партии' (sku, stock) = expiryDateBatch(lastOrderBatch##postfix##SkuStock(sku, stock));

    batchLastManufactureDate##postfix##SkuStock (sku, stock)  =
        GROUP LAST batch
              BY skuBatch(batch), stock
              ORDER orderBatch(batch)
              WHERE countLedgerBatchStock(batch, stock) AND manufactureDateBatch(batch) COMPLEX;
              
    batchLastExpiryDate##postfix##SkuStock (sku, stock)  =
        GROUP LAST batch
              BY skuBatch(batch), stock
              ORDER orderBatch(batch)
              WHERE countLedgerBatchStock(batch, stock) AND expiryDateBatch(batch) COMPLEX;    
              
    overLastManufactureDate##postfix##SkuStock 'Последняя дата изготовления' (sku, stock) = manufactureDateBatch(batchLastManufactureDate##postfix##SkuStock(sku, stock));
    overLastExpiryDate##postfix##SkuStock 'Последний срок годности' (sku, stock) = expiryDateBatch(batchLastExpiryDate##postfix##SkuStock(sku, stock));
    
    useFillBatchProperty 'Использовать последние: срок годности, дату и время изготовления' = DATA BOOLEAN ();
    EXTEND FORM options
        PROPERTIES() useFillBatchProperty
    ;
    DESIGN options {
        commons {
            MOVE PROPERTY(useFillBatchProperty());
        }
    }
    lastManufactureDate##postfix##SkuStock 'Дата изготовления' (sku, stock) = IF useFillBatchProperty() 
        THEN manufactureDateBatch(batchLastManufactureDate##postfix##SkuStock(sku, stock))
        ELSE manufactureDateBatch(lastOrderBatch##postfix##SkuStock(sku, stock));
    lastExpiryDate##postfix##SkuStock 'Срок годности (дата)' (sku, stock) = IF useFillBatchProperty()
        THEN expiryDateBatch(batchLastExpiryDate##postfix##SkuStock(sku, stock))
        ELSE expiryDateBatch(lastOrderBatch##postfix##SkuStock(sku, stock));    
    
    lastOrderBatch##postfix##Sku (sku) = GROUP MAX lastOrderBatch##postfix##SkuStock(sku, stock) BY sku;

    currentBalance##postfix##Batch 'Остаток (всего)'###caption (batch) = GROUP SUM currentBalance##postfix##BatchStock(batch, stock) BY batch PERSISTENT;
    outcome##postfix##Batch 'Расходовано'###caption (batch) = MAX shippedQuantityBatch(batch) (-) currentBalance##postfix##Batch(batch), 0;

    balanceASkuLedger 'Остаток (после)' (ledger) = balanceASkuStockDateTime(skuSkuLedger(ledger), stockSkuLedger(ledger), dateTimeSkuLedger(ledger));
    balanceBSkuLedger 'Остаток (до)' (ledger) = balanceBSkuStockDateTime(skuSkuLedger(ledger), stockSkuLedger(ledger), dateTimeSkuLedger(ledger));
    // ---------------------------- Суммы по товару -------------------------------- //

    signedSumActiveSkuLedger(ledger) = signedSumSkuLedger(ledger) IF isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;
    currentSum##postfix##SkuStock 'Сумма остатка'###caption (sku, stock) =
        GROUP SUM signedSumActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger) PERSISTENT;
    //-- по дате
    sumInActiveSkuLedger(ledger) = sumInSkuLedger(ledger) IF isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;
    sumIn##postfix##SkuStockDate (sku, stock, date) =
        GROUP SUM sumInActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT;

    sumOutActiveSkuLedger(ledger)  = sumOutSkuLedger(ledger) IF isPostedSkuLedger(ledger) AND NOT skip##postfix##SkuLedger(ledger) PERSISTENT;
    sumOut##postfix##SkuStockDate (sku, stock, date) =
        GROUP SUM sumOutActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT;

    sum##postfix##SkuStockDate (sku, stock, date) = sumIn##postfix##SkuStockDate(sku, stock, date)
                                                         (+)
                                                         sumOut##postfix##SkuStockDate(sku, stock, date) PERSISTENT;

    signedSum##postfix##SkuStockDate (sku, stock, date) = sumIn##postfix##SkuStockDate(sku, stock, date)
                                                               (-)
                                                               sumOut##postfix##SkuStockDate(sku, stock, date) PERSISTENT;

    // без учета текущей даты/времени
    sumB##postfix##SkuStockDate 'Сумма на начало дня'###caption (sku, stock, date) = currentSum##postfix##SkuStock(sku, stock)
                                                                      (-) [= GROUP SUM signedSum##postfix##SkuStockDate (sku, stock, dateIn) IF dateIn >= date
                                                                                 BY sku, stock, date](sku, stock, date);

    sumB##postfix##StockDate 'Сумма на начало дня' (stock, date) = GROUP SUM sumB##postfix##SkuStockDate(sku, stock, date) BY stock, date;

    sumB##postfix##SkuGroupStockDate 'Сумма на начало дня (по группе)' (group, stock, date) =
        GROUP SUM sumB##postfix##SkuStockDate (sku, stock, date)
        BY groupGroupTypeSku(groupType, sku), stock, date;

    sumRecB##postfix##SkuGroupStockDate 'Сумма на начало дня (всего)' (group, stock, date) =
        GROUP SUM sumB##postfix##SkuStockDate (sku, stock, date) IF isParentGroupSku(group, sku)
        BY group, stock, date;

    // с учетом текущей даты/времени
    sumA##postfix##SkuStockDate 'Сумма на конец дня'###caption (sku, stock, date) = currentSum##postfix##SkuStock(sku, stock)
                                                                     (-) [= GROUP SUM signedSum##postfix##SkuStockDate (sku, stock, dateIn) IF dateIn > date
                                                                                BY sku, stock, date](sku, stock, date);

    sumA##postfix##SkuGroupStockDate 'Сумма на конец дня (по группе)' (group, stock, date) =
        GROUP SUM sumA##postfix##SkuStockDate (sku, stock, date)
        BY groupGroupTypeSku(groupType, sku), stock, date;

    sumRecA##postfix##SkuGroupStockDate 'Сумма на конец дня (всего)' (group, stock, date) =
        GROUP SUM sumA##postfix##SkuStockDate (sku, stock, date) IF isParentGroupSku(group, sku)
        BY group, stock, date;

    //-- по дате/время
    sumIn##postfix##SkuStockDateTime (sku, stock, dateTime) =
        GROUP SUM sumInActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateTimeSkuLedger(ledger);

    sumOut##postfix##SkuStockDateTime (sku, stock, dateTime) =
        GROUP SUM sumOutActiveSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateTimeSkuLedger(ledger);

    sum##postfix##SkuStockDateTime (sku, stock, dateTime) = sumIn##postfix##SkuStockDateTime(sku, stock, dateTime)
                                                         (+)
                                                         sumOut##postfix##SkuStockDateTime(sku, stock, dateTime);

    signedSum##postfix##SkuStockDateTime (sku, stock, dateTime) = sumIn##postfix##SkuStockDateTime(sku, stock, dateTime)
                                                               (-)
                                                               sumOut##postfix##SkuStockDateTime(sku, stock, dateTime);

    // без учета текущей даты/времени
    sumB##postfix##SkuStockDateTime 'Сумма (до)'###caption (sku, stock, dateTime) = currentSum##postfix##SkuStock(sku, stock)
                                                                     (-) [= GROUP SUM signedSumActive##postfix##SkuLedger(ledger) IF dateTimeSkuLedger(ledger) >= dateTime
                                                                                BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateTime](sku, stock, dateTime);
       
    sumRecB##postfix##SkuGroupStockDateTime 'Учетная сумма (всего)' (group, stock, dateTime) =
        GROUP SUM sumB##postfix##SkuStockDateTime (sku, stock, dateTime) IF isParentGroupSku(group, sku)
        BY group, stock, dateTime;
        
    // с учетом текущей даты/времени
    sumA##postfix##SkuStockDateTime 'Сумма (после)'###caption (sku, stock, dateTime) = currentSum##postfix##SkuStock(sku, stock)
                                                                     (-) [= GROUP SUM signedSumActive##postfix##SkuLedger(ledger) IF dateTimeSkuLedger(ledger) > dateTime
                                                                                BY skuSkuLedger(ledger), stockSkuLedger(ledger), dateTime](sku, stock, dateTime);

    // суммы для периодов
    sumIn##postfix##SkuStockDateDate 'Сумма товара пришедшего за период' (sku, stock, dateFrom, dateTo) =
        GROUP SUM sumIn##postfix##SkuStockDate(sku, stock, dateIn) IF dateIn >= dateFrom AND dateIn <= dateTo
               BY sku, stock, dateFrom, dateTo;
    sumIn##postfix##GroupSkuStockDateDate 'Сумма товара пришедшего за период(по группе)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumIn##postfix##SkuStockDateDate (sku, stock, dateFrom, dateTo)
        BY groupGroupTypeSku(groupType, sku), stock, dateFrom, dateTo;
    sumRecIn##postfix##GroupSkuStockDateDate 'Сумма товара пришедшего за период(всего)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumIn##postfix##SkuStockDateDate (sku, stock, dateFrom, dateTo) IF isParentGroupSku(group, sku)
        BY group, stock, dateFrom, dateTo;

    sumOut##postfix##SkuStockDateDate 'Сумма товара ушедшего за период' (sku, stock, dateFrom, dateTo) =
        GROUP SUM sumOut##postfix##SkuStockDate(sku, stock, dateOut) IF dateOut >= dateFrom AND dateOut <= dateTo
               BY sku, stock, dateFrom, dateTo;
    sumOut##postfix##GroupSkuStockDateDate 'Сумма товара ушедшего за период(по группе)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumOut##postfix##SkuStockDateDate (sku, stock, dateFrom, dateTo)
        BY groupGroupTypeSku(groupType, sku), stock, dateFrom, dateTo;
    sumRecOut##postfix##GroupSkuStockDateDate 'Сумма товара ушедшего за период(всего)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumOut##postfix##SkuStockDateDate (sku, stock, dateFrom, dateTo) IF isParentGroupSku(group, sku)
        BY group, stock, dateFrom, dateTo;

    averagePrice##postfix##SkuStock 'Цена (средневзв.)'###caption (sku, stock) = currentSum##postfix##SkuStock(sku, stock) / currentBalance##postfix##SkuStock(sku, stock); // IF NOT currentBalance##postfix##SkuStock(sku, stock) == 0; (возможно не нужно, так как 0 не может быть в GROUP SUM )
    averagePriceA##postfix##SkuStockDateTime 'Цена (средневзв.)'###caption (sku, stock, dateTime) = sumA##postfix##SkuStockDateTime(sku, stock, dateTime) / balanceA##postfix##SkuStockDateTime(sku, stock, dateTime); // IF NOT currentBalance##postfix##SkuStock(sku, stock) == 0; (возможно не нужно, так как 0 не может быть в GROUP SUM )
    prevAveragePriceA##postfix##SkuStockDateTime 'Цена (средневзв.)'###caption (sku, stock, dateTime) = PREV(averagePriceA##postfix##SkuStockDateTime(sku, stock, dateTime));
    averagePriceB##postfix##SkuStockDateTime 'Цена (средневзв.)'###caption (sku, stock, dateTime) = sumB##postfix##SkuStockDateTime(sku, stock, dateTime) / balanceB##postfix##SkuStockDateTime(sku, stock, dateTime); // IF NOT currentBalance##postfix##SkuStock(sku, stock) == 0; (возможно не нужно, так как 0 не может быть в GROUP SUM )
    prevAveragePriceB##postfix##SkuStockDateTime 'Цена (средневзв.)'###caption (sku, stock, dateTime) = PREV(averagePriceB##postfix##SkuStockDateTime(sku, stock, dateTime));
END

@defineSkuLedgerBalanceProperties(,);

banNegativeSku 'Запретить расходовать больше чем в остатке по товару' = DATA BOOLEAN ();

EXTEND FORM options 
    PROPERTIES() banNegativeSku 
;

DESIGN options {
    stock1 {
        MOVE PROPERTY(banNegativeSku());
    }
}

CONSTRAINT currentBalanceSkuStock(sk, st) < 0.0 AND banNegativeSku()
    MESSAGE 'Текущий остаток должен быть больше нуля';

allowedEditSkuLedger (d) = NOT isClosedSkuLedger(d) OR allowedEditClosedDocumentsCustomUser(currentUser());
// -------------------------------------- Последнее движение ---------------------------------- //

dateTimeLastMovedSkuStock 'Время последнего движения' (sku, stock) =
    GROUP MAX dateTimeSkuLedger(ledger)
    BY skuSkuLedger(ledger), stockSkuLedger(ledger) PERSISTENT TABLE extraSkuStock;

dateTimeLastMovedSku 'Время последнего движения' (sku) =
    GROUP MAX dateTimeLastMovedSkuStock(sku, stock)
    BY sku;

movedSkuStockDateTimePeriod (item, departmentStore, dateTime, period) =
    dateTimeLastMovedSkuStock(item, departmentStore) >= toDateTime(subtractDate(toDate(dateTime), period));

balanceSkuStockDateTimePeriod (item, departmentStore, dateTime, period) =
    movedSkuStockDateTimePeriod (item, departmentStore, dateTime, period) OR balanceBSkuStockDateTime(item, departmentStore, dateTime);

movedSkuStockDatePeriod (item, departmentStore, date, period) =
    dateTimeLastMovedSkuStock(item, departmentStore) >= toDateTime(subtractDate(date, period));

balanceSkuStockDatePeriod (item, departmentStore, date, period) =
    movedSkuStockDatePeriod (item, departmentStore, date, period) OR balanceASkuStockDate(item, departmentStore, date);

//----------------------------------------- По партиям ---------------------------------------------//

signedQuantityBatchStockDate = GROUP SUM signedCostSkuLedgerBatch (ledger, batch) IF isPostedSkuLedger(ledger)
                                     BY batch, stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT; 
                                     
quantityBatchStockDate = GROUP SUM costSkuLedgerBatch (ledger, batch) IF isPostedSkuLedger(ledger)
                                     BY batch, stockSkuLedger(ledger), dateSkuLedger(ledger) PERSISTENT;                                      

// без учета текущей даты/времени
balanceBBatchStockDate 'Остаток на начало дня' (batch, stock, date) = currentBalanceBatchStock(batch, stock)
    (-) [= GROUP SUM signedQuantityBatchStockDate(batch, stock, dateIn) IF dateIn >= date
           BY batch, stock, date](batch, stock, date);

// с учетом текущей даты/времени
balanceABatchStockDate 'Остаток на конец дня' (batch, stock, date) = currentBalanceBatchStock(batch, stock)
    (-) [= GROUP SUM signedQuantityBatchStockDate(batch, stock, dateIn) IF dateIn > date
           BY batch, stock, date](batch, stock, date);

// без учета текущей даты/времени
balanceBBatchStockDateTime 'Остаток (до)' (batch, stock, dateTime) = currentBalanceBatchStock(batch, stock)
    (-) [= GROUP SUM signedQuantityActiveSkuLedgerBatch (ledger, batch) IF dateTimeSkuLedger(ledger) >= dateTime
    BY batch, stockSkuLedger(ledger), dateTime](batch, stock, dateTime);

// с учетом текущей даты/времени
balanceABatchStockDateTime 'Остаток (после)' (batch, stock, dateTime) = currentBalanceBatchStock(batch, stock)
    (-) [= GROUP SUM signedQuantityActiveSkuLedgerBatch (ledger, batch) IF dateTimeSkuLedger(ledger) > dateTime
    BY batch, stockSkuLedger(ledger), dateTime](batch, stock, dateTime);

// Остатки по себестоимости
costBBatchStockDate 'Себестоимость на начало дня' (batch, stock, date) = balanceBBatchStockDate(batch, stock, date) * costBatch(batch);
  
costABatchStockDate 'Себестоимость на конец дня' (batch, stock, dateTo) = balanceABatchStockDate(batch, stock, dateTo) * costBatch(batch);          

// Итоги по складам
costBStockDate 'Себестоимость на начало дня' = GROUP SUM costBBatchStockDate(b, s, d) BY s, d;
costAStockDate 'Себестоимость на конец дня' = GROUP SUM costABatchStockDate(b, s, d) BY s, d;

//---------------------------------------------- За период ------------------------------------------//

costInBalanceBatchStockDateFromTo 'Приход' (batch, stock, dateFrom, dateTo) = GROUP SUM costSkuLedgerBatch (ledger, batch)
    IF ledger IS InSkuLedger AND isPostedSkuLedger(ledger)
    AND dateSkuLedger(ledger) >= dateFrom AND dateSkuLedger(ledger)<= dateTo
    BY batch, stockSkuLedger(ledger), dateFrom, dateTo;

costSumInBalanceBatchStockDateFromTo 'Сумма прихода' (batch, stock, dateFrom, dateTo) =
    costBatch(batch) * costInBalanceBatchStockDateFromTo(batch, stock, dateFrom, dateTo);

costOutBalanceBatchStockDateFromTo 'Расход' (batch, stock, dateFrom, dateTo) = GROUP SUM costSkuLedgerBatch (ledger, batch)
    IF ledger IS OutSkuLedger AND isPostedSkuLedger(ledger)
    AND dateSkuLedger(ledger) >= dateFrom AND dateSkuLedger(ledger)<= dateTo
    BY batch, stockSkuLedger(ledger), dateFrom, dateTo;

costSumOutBalanceBatchStockDateFromTo 'Сумма расхода' (batch, stock, dateFrom, dateTo) =
    costBatch(batch) * costOutBalanceBatchStockDateFromTo(batch, stock, dateFrom, dateTo);
    
//---------------------------------------------- Себестоимость ------------------------------------------//    
    
currentCostSumSkuStock 'Текущая себестоимость' (sku, stock) =
    GROUP SUM signedActiveCostSumSkuLedger(ledger) BY skuSkuLedger(ledger), stockSkuLedger(ledger);
    
// без учета текущей даты/времени
costSumBSkuStockDate 'Себестоимость на начало дня' (sku, stock, date) = GROUP SUM costBBatchStockDate(batch, stock, date) BY skuBatch(batch), stock, date;

// с учетом текущей даты/времени
costSumASkuStockDate 'Себестоимость на конец дня' (sku, stock, date) = GROUP SUM costABatchStockDate(batch, stock, date) BY skuBatch(batch), stock, date; 

// ------------------------------------------------ Формы для партий ------------------------------ //
FORM batches 'Партии'

    TREE skuTree sk = SkuGroup PARENT parentSkuGroup
    PROPERTIES READONLY orderSkuGroup(sk), skuTreeName = nameSkuGroup(sk)
    ORDER BY orderSkuGroup(sk), skuTreeName
    FILTERGROUP inactive FILTER 'Активные' activeSkuGroup(sk) 'F5' DEFAULT

    OBJECTS           bt=Batch
    PROPERTIES(bt)    READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameSkuBatch, idBatch SHOWIF showIDs(), 
                               nameBatch, nameStockBatch, shippedQuantityBatch, costBatch, expiryDateBatch, currentBalanceBatch
    PROPERTIES(bt)    editSkuLedger SHOWIF allowedEditSkuLedger(bt)
    FILTERS           isParentSkuGroupBatch(sk, bt)
    ORDER BY          dateTimeBatch(bt)

    FILTERGROUP filterBalance
        FILTER 'Партии пришедшие за последний 1 день' dateBatch(bt) >= subtractDate(currentDate(), 1) 'F10'
        FILTER 'Партии пришедшие за последние 7 дней' dateBatch(bt) >= subtractDate(currentDate(), 7) 'F9'
        FILTER 'Партии пришедшие за последние 30 дней' dateBatch(bt) >= subtractDate(currentDate(), 30) 'F8'

    FILTERGROUP filterExpiry
        FILTER 'Партии с истекшим сроком годности' expiryDateBatch(bt) < currentDate() 'F7'
        FILTER 'Партии со сроком годности, истекающим через 1 день' expiresBatchDate(bt, currentDate(), 1) 'F6'
        FILTER 'Партии со сроком годности, истекающим через 7 дней' expiresBatchDate(bt, currentDate(), 7) 'F5'
        FILTER 'Партии со сроком годности, истекающим через 30 дней' expiresBatchDate(bt, currentDate(), 30) 'F4'

    DIALOG Batch OBJECT bt
;

DESIGN batches {
    main{
        preferredSize = (1024, 768);

        NEW topContainer {
            fill = 1;
            type = SPLITH;
            MOVE skuTree.tree.box { caption = 'Группы'; }
            MOVE bt.box { fill = 3; caption = 'Партии'; }
        }
        MOVE functions.box;
    }
}
@extendFormFilterAccessStock(Batch, bt, batches, stock, company);

FORM dialogBatch 'Партии'
    OBJECTS sk = Sku FIXED PANEL

    OBJECTS bt = Batch
    PROPERTIES (bt) READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameStockBatch,
                    nameSkuBatch, nameBatch, idBatch SHOWIF showIDs(), shippedQuantityBatch, costBatch, expiryDateBatch
    FILTERS skuBatch(bt) == sk

    ORDER BY dateTimeBatch(bt)
;

FORM dialogBatchStock 'Партии'
    OBJECTS st = Stock FIXED PANEL
    OBJECTS t = DATETIME FIXED PANEL
    OBJECTS sk = Sku FIXED PANEL

    OBJECTS bt = Batch
    PROPERTIES (bt) READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameSkuBatch, idBatch SHOWIF showIDs(), nameBatch, shippedQuantityBatch, costBatch, expiryDateBatch
    PROPERTIES  READONLY balanceBBatchStockDateTime(bt, st, t)
    FILTERS skuBatch(bt) == sk

    FILTERGROUP income
        FILTER 'Партии с приходом на склад' countLedgerBatchStock(bt, st) 'F10' DEFAULT  
    FILTERGROUP batch
        FILTER 'Партии с остатком' balanceBBatchStockDateTime(bt, st, t) 'F11' DEFAULT
;
DESIGN dialogBatchStock {
    main {
        PROPERTY (balanceBBatchStockDateTime(bt,st,t)) {
            caption = 'Текущий остаток';
        }
    }
}

// ------------------------------------------------- Себестоимость --------------------------- //

// Расчет себестоимости

needToCostDataSkuLedger 'Требуется расчет себестоимости' (ledger) = quantitySkuLedger(ledger) > 0 AND isPostedDataSkuLedger(ledger)
                                                                        AND NOT quantitySkuLedger(ledger) == costedDataSkuLedger(ledger);

limitInLIFOSkuLedgerBatch = ABSTRACT NUMERIC[14,3] (InLIFOSkuLedger, Batch);
orderInLIFOSkuLedgerBatch = ABSTRACT LONG (InLIFOSkuLedger, Batch);
limitNewInLIFOSkuLedgerBatch = IF ledger IS InLIFOSkuLedger THEN (
                                                     IF batchSkuLedger(ledger) THEN
                                                        quantityInLIFOSkuLedger(ledger) IF batch == batchSkuLedger(ledger)
                                                     ELSE
                                                        outcomeBatch(batch) IF
                                                        countLedgerBatchStock(batch, stockDataSkuLedger(ledger)));

quantityInLIFOSkuLedgerBatch (ledger, batch) =
        PARTITION UNGROUP quantityInLIFOSkuLedger
                  LIMIT STRICT limitNewInLIFOSkuLedgerBatch(ledger, batch) IF skuBatch(batch) == skuDataSkuLedger(ledger)
                  BY ledger
                  ORDER DESC orderInLIFOSkuLedgerBatch(ledger, batch), orderBatch(batch);

limitOutFIFOSkuLedgerBatch = ABSTRACT NUMERIC[14,3] (OutFIFOSkuLedger, Batch);
orderOutFIFOSkuLedgerBatch = ABSTRACT LONG (OutFIFOSkuLedger, Batch);
limitNewOutFIFOSkuLedgerBatch = IF ledger IS OutFIFOSkuLedger THEN (
                                                     IF batchSkuLedger(ledger) THEN
                                                        quantityOutFIFOSkuLedger(ledger) IF batch == batchSkuLedger(ledger)
                                                     ELSE
                                                        OVERRIDE 0.0 IF countLedgerBatchStock(batch, stockDataSkuLedger(ledger)), currentBalanceBatchStock(batch, stockDataSkuLedger(ledger)));

quantityOutFIFOSkuLedgerBatch (ledger, batch) =
        PARTITION UNGROUP quantityOutFIFOSkuLedger
                  LIMIT STRICT limitNewOutFIFOSkuLedgerBatch(ledger, batch) IF skuBatch(batch) == skuDataSkuLedger(ledger)
                  BY ledger
                  ORDER orderOutFIFOSkuLedgerBatch(ledger, batch), orderBatch(batch);

quantityDataSkuLedgerBatch (ledger, batch) = MULTI quantityInLIFOSkuLedgerBatch(ledger, batch) (+) 0, // (+) 0 делается, чтобы все 0 стали NULL 
                                                   quantityOutFIFOSkuLedgerBatch(ledger, batch);

resetCostDataSkuLedger 'Перерассчитать себестоимость' = ACTION (ledger) { //NEWSESSION AUTOAPPLY {
    ASSIGN costDataSkuLedgerBatch(ledger, batch) <- NULL;
    ASSIGN costDataSkuLedgerBatch(ledger, batch) <- quantityDataSkuLedgerBatch(ledger, batch);
}

// мгновенный расчет себестоимости
//WHEN SET(isPostedDataSkuLedger(ledger)) DO EXEC resetCostDataSkuLedger (ledger) ORDER orderDataSkuLedger(ledger);
changedCostDataSkuLedger 'Перерасчитывалась себестоимость' = DATA LOCAL BOOLEAN (DataSkuLedger);

changedSessionLedger = DATA LOCAL BOOLEAN (DataSkuLedger);
updateDataSkuLedgerBatchCost() = ACTION {
    costDataSkuLedgerBatch(ledger, batch) <- NULL WHERE changedSessionLedger(ledger);

    LOCAL orderedLedger = INTEGER (DataSkuLedger);
    orderedLedger(ledger) <- PARTITION SUM 1 IF changedSessionLedger(ledger) BY skuDataSkuLedger(ledger) ORDER orderDataSkuLedger(ledger);

    FOR iterate(i, 1, [= GROUP MAX orderedLedger(ledger)]()) DO {
        LOCAL itLedger = BOOLEAN (DataSkuLedger);
        itLedger(ledger) <- orderedLedger(ledger) == i; // чтобы определились классы
        changedCostDataSkuLedger(ledger) <- TRUE WHERE itLedger(ledger);
        costDataSkuLedgerBatch(ledger, batch) <- quantityDataSkuLedgerBatch(ledger, batch) WHERE itLedger(ledger);
    }
}

ON { // eventChangeLedger - так как внутрь рекурсивного события толь
    LOCAL eventChangedLedger = BOOLEAN (DataSkuLedger); 
    ASSIGN eventChangedLedger(ledger) <- SET(isPostedDataSkuLedger(ledger)) OR ((
                                  CHANGED(quantityDataSkuLedger(ledger))
                                  OR CHANGED(skuDataSkuLedger(ledger))
                                  OR CHANGED(batchSkuLedger(ledger))
                                  OR CHANGED(stockDataSkuLedger(ledger))
                                  OR CHANGED(changedDataSkuLedger(ledger)))
                                 AND isPostedDataSkuLedger(ledger));

    IF [= GROUP MAX eventChangedLedger(ledger)]() THEN
        NEWSESSION NESTED eventChangedLedger SINGLE {
            changedSessionLedger(ledger) <- eventChangedLedger(ledger);
            updateDataSkuLedgerBatchCost();
        }
}

setDataSkuLedgerBatchCost 'Дорассчитать себестоимость' = ACTION () NEWSESSION {
    APPLY SINGLE { 
        changedSessionLedger(ledger) <- needToCostDataSkuLedger(ledger);
        updateDataSkuLedgerBatchCost();
    }
} CONFIRM;

resetDataSkuLedgerBatchCost 'Перерассчитать себестоимость' = ACTION () NEWSESSION {
    FORM dialogDate MODAL;
    IF formResult() == FormResult.ok THEN {

        FOR d == chosenDate('d') DO {
            APPLY SINGLE { 
                changedSessionLedger(ledger) <- dateSkuLedger(ledger) >= d AND isPostedDataSkuLedger(ledger);
                updateDataSkuLedgerBatchCost();
            }
        }
    }
} CONFIRM;

clearDataSkuLedgerBatchCost 'Сбросить всю себестоимость' = ACTION() NEWSESSION {
    ASSIGN costDataSkuLedgerBatch(ledger, batch) <- NULL;
    apply();
} CONFIRM;

currentBalanceSkuLedgerBatch 'Текущий остаток' (bil, bt) = currentBalanceBatchStock(bt, stockSkuLedger(bil));
countLedgerSkuLedgerBatch 'Кол-во движений' (bil, bt) = countLedgerBatchStock(bt, stockSkuLedger(bil));

FORM costSkuLedger 'Себестоимость (операции)'
    OBJECTS bil = SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger, nameSkuSkuLedger, nameStockSkuLedger,
                             quantitySkuLedger, costedSkuLedger, sumSkuLedger
    PROPERTIES(bil)          resetCostDataSkuLedger FORCE GRID
    PROPERTIES(bil)          editSkuLedger SHOWIF allowedEditSkuLedger(bil)
    FILTERS activeSkuLedger(bil)
    ORDER BY dateTimeSkuLedger(bil)

    FILTERGROUP needToCostDataSkuLedger
        FILTER 'Нерасписанные строки' needToCostDataSkuLedger(bil) 'F9'

    OBJECTS bt = Batch
    PROPERTIES(bt) READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, shippedQuantityBatch, costBatch, currentBalanceBatch
    PROPERTIES(bil, bt)  FORCE GRID costSkuLedgerBatch, currentBalanceSkuLedgerBatch, countLedgerSkuLedgerBatch
    FILTERS skuBatch(bt) == skuSkuLedger(bil)
    ORDER BY dateTimeBatch(bt) DESC

    FILTERGROUP inSkuLedgerBatch
        FILTER 'Только расписанные партии' costSkuLedgerBatch (bil, bt) 'F10' DEFAULT

    FILTERGROUP currentBalance
        FILTER 'Только партии с остатком на складе' currentBalanceSkuLedgerBatch (bil, bt) 'F11'

    PROPERTIES() setDataSkuLedgerBatchCost, resetDataSkuLedgerBatchCost, clearDataSkuLedgerBatchCost
;

DESIGN costSkuLedger {
    NEW topContainer{
        fill = 1;
        type = SPLITV;

        MOVE bil.box;
        MOVE bt.box;
    }

    NEW buttonContainer {
        type = CONTAINERH;
        MOVE PROPERTY(setDataSkuLedgerBatchCost());
        MOVE PROPERTY(resetDataSkuLedgerBatchCost());
        MOVE PROPERTY(clearDataSkuLedgerBatchCost());
    }

    MOVE functions.box;
}
@extendFormFilterAccessStock(SkuLedger, bil, costSkuLedger, stock, company);

FORM costSkuBatchLedger 'Себестоимость (партии)'
    OBJECTS i = Sku FIXED PANEL
    PROPERTIES(i) SELECTOR nameSku//, idBarcodeSku

    OBJECTS bt = Batch
    PROPERTIES(bt) READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, shippedQuantityBatch, costBatch, currentBalanceBatch

    OBJECTS bil = SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger, nameStockSkuLedger,
                             quantitySkuLedger, costedSkuLedger
//    PROPERTIES(bil)          resetCostSkuLedger
    ORDER BY dateTimeSkuLedger(bil)

    FILTERGROUP needToCostSkuLedger
        FILTER 'Нерасписанные строки' needToCostDataSkuLedger(bil) 'F9'


    PROPERTIES(bil, bt)     READONLY costSkuLedgerBatch FORCE GRID
    FILTERS skuBatch(bt) == i,
            skuSkuLedger(bil) == i

    ORDER BY dateTimeBatch(bt) DESC

    FILTERGROUP inSkuLedgerBatch
        FILTER 'Только расписанные партии' costSkuLedgerBatch (bil, bt) 'F10' DEFAULT
;

DESIGN costSkuBatchLedger {
    NEW topContainer {
        fill = 1;
        type = SPLITV;

        MOVE bt.box;
        MOVE bil.box;
    }
    MOVE functions.box;
}

// ------------------------------------------------ Остатки по товарам ---------------------------------------- //

selectSku 'Отм.' = DATA LOCAL BOOLEAN (Sku);
resetAllSelectedSku 'Сбросить для всех' = ACTION () {
    selectSku(sku) <- NULL WHERE selectSku(sku);
} SHORTCUT selectSku;

selectSkuStock 'Отм.' = DATA LOCAL BOOLEAN (Sku, Stock);
resetAllSelectedSkuStock 'Сбросить для всех' = ACTION () {
    selectSkuStock(sku, stock) <- NULL WHERE selectSkuStock(sku, stock);
} SHORTCUT selectSkuStock;

countSelectSkus 'Отм.' = GROUP SUM 1 IF selectSku(sku) MINCHARWIDTH 3 PREFCHARWIDTH 3 TOOLBAR ;
countSelectSkuStocks 'Отм.' = GROUP SUM 1 IF selectSkuStock(sku, stock) MINCHARWIDTH 3 PREFCHARWIDTH 3 TOOLBAR;

multipleStores 'Несколько складов' = DATA LOCAL BOOLEAN ();
singleStore = NOT multipleStores();

FORM currentBalanceSkuStock 'Текущие остатки'
    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) nameStock SELECTOR SHOWIF singleStore()
    FILTERS isCompanyStock(ss)
    
    TREE stockTree a = STRING[3], sg = StockGroup PARENT parentStockGroup, ts = Stock
    PROPERTIES SHOWIF multipleStores() READONLY OBJVALUE(a), sgTreeName = nameStockGroup(sg), tsTreeName = nameStock(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroupStock(ts) == sg,
            isCompanyStock(ts)
    FILTERGROUP tsinactiveStock FILTER 'Активный' activeStock(ts) 'ctrl F10' DEFAULT
    
    TREE skuTree sk = SkuGroup PARENT parentSkuGroup
    PROPERTIES READONLY orderSkuGroup(sk), skuTreeName = nameSkuGroup(sk)
    ORDER BY orderSkuGroup(sk), skuTreeName
    FILTERGROUP inactive FILTER 'Активные' activeSkuGroup(sk) 'F5' DEFAULT

    OBJECTS           sts=(st=Stock, s=Sku)
    PROPERTIES        selectSkuStock(s,st)
    PROPERTIES        READONLY nameSku(s), nameCountrySku(s), stockName = nameStock(st) SHOWIF multipleStores(), nameUOMSku(s)  //  idBarcodeSku
    FILTERS           isParentSkuGroupSku(sk, s),
                      IF multipleStores() THEN 
                        st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                      ELSE 
                        st == ss,
                      isCompanyStock(st) OR NOT multipleStores()
    ORDER BY          nameSku(s)
    FILTERGROUP inactiveStock 
        FILTER 'Активный' (activeStock(st) OR NOT multipleStores()) AND activeSku(s) 'ctrl F10' DEFAULT
        FILTER 'Неактивный' inactiveSku(s) 'shift F10'
    FILTERGROUP container 
        FILTER 'Товар' isItemSku(s) 
        FILTER 'Тара' isContainerSku(s)
        
    PROPERTIES(s, st) READONLY currentBalanceSkuStock, averagePriceSkuStock, currentSumSkuStock, dateTimeLastMovedSkuStock
    PROPERTIES(s)     READONLY idSkuGroupSku, canonicalNameSkuGroupSku    
    PROPERTIES() READONLY countSelectSkuStocks SHOWIF countSelectSkuStocks() TODRAW sts 
    FILTERGROUP filters
        FILTER 'Товары с остатком' currentBalanceSkuStock(s, st) OR currentSumSkuStock(s, st) 'F10' DEFAULT
        FILTER 'Товары с движением не позднее 1 дня' balanceSkuStockDatePeriod(s, st, currentDate(), 1) 'F9'
        FILTER 'Товары с движением не позднее 7 дней' balanceSkuStockDatePeriod(s, st, currentDate(), 7) 'F8'
        FILTER 'Товары с движением не позднее 30 дней' balanceSkuStockDatePeriod(s, st, currentDate(), 30) 'F7'

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger, nameBatchSkuLedger,
                    signedQuantitySkuLedger, signedPriceSkuLedger, signedSumSkuLedger, skipSkuLedger
                    
    FILTERS isPostedSkuLedger(bil) AND skuSkuLedger(bil)==s AND stockSkuLedger(bil)==st
    ORDER BY dateTimeSkuLedger(bil) DESC

    OBJECTS bt=Batch
    PROPERTIES(bt) READONLY      numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, idBatch, shippedQuantityBatch, costBatch, expiryDateBatch
    PROPERTIES(bt, st) READONLY  currentBalanceBatchStock
    FILTERS isPostedBatch(bt) AND skuBatch(bt)==s
    ORDER BY dateTimeBatch(bt) DESC
;

DESIGN currentBalanceSkuStock {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            MOVE PROPERTY (multipleStores());
            MOVE PROPERTY (nameStock(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;

            NEW firstBottom {
                fill = 1;
                type = SPLITV;
                MOVE stockTree.tree.box { caption = 'Склады'; }
                MOVE skuTree.tree.box { caption = 'Группы'; }
            }

            NEW secondCase {
                fill = 3;
                type = SPLITV;
                NEW sku.box {
                    fill = 2;
                    MOVE sts.box {
                        fill = 2;
                    }
                }
                NEW ledger.box {
                    fill = 1;
                    caption = 'Изменение цен';
                    type = TABBED;
                    MOVE bil.box;
                    MOVE bt.box;
                    NEW actionContainer {
                        caption = 'Действия';
                        type = CONTAINERH;
                    }
                }
            }
        }

        MOVE functions.box;
    }
}
@extendFormFilterStockGroupAccess(sg, currentBalanceSkuStock);
EXTEND FORM currentBalanceSkuStock FILTERS accessCompanyEmployeeStock(currentUser(), st) OR NOT multipleStores();

@extendFormFilterStockAccess(ss, currentBalanceSkuStock);

@extendFormFilterStockAccess(ts, currentBalanceSkuStock);

//resetSelectedSkuStock 'Сбросить для текущих' = ACTION () {
//    FOR [= FILTER currentBalanceSkuStock.sts](st,s) DO {
//        selectSkuStock(s, st) <- NULL WHERE selectSkuStock(s, st);
//    }
//} SHORTCUT selectSkuStock;

FORM balanceSkuStock 'Остатки на дату'

    OBJECTS t=DATETIME FIXED PANEL
    PROPERTIES valT = OBJVALUE(t)

    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) nameStock SELECTOR SHOWIF singleStore()
    FILTERS isCompanyStock(ss)    

    TREE stockTree a = STRING[3], sg = StockGroup PARENT parentStockGroup, ts = Stock
    PROPERTIES READONLY SHOWIF multipleStores() OBJVALUE(a), sgTreeName = nameStockGroup(sg), tsTreeName = nameStock(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroupStock(ts) == sg,
            isCompanyStock(ts)
    FILTERGROUP sginactiveStock FILTER 'Активный' activeStock(ts) 'ctrl F10' DEFAULT
    TREE skuTree sk = SkuGroup PARENT parentSkuGroup
    PROPERTIES READONLY orderSkuGroup(sk), skuTreeName = nameSkuGroup(sk)
    ORDER BY orderSkuGroup(sk), skuTreeName
    FILTERGROUP inactive FILTER 'Активные' activeSkuGroup(sk) 'F5' DEFAULT

    OBJECTS           sts=(st=Stock, s=Sku)
    PROPERTIES        READONLY nameSku(s), nameCountrySku(s), stockName = nameStock(st) SHOWIF multipleStores(), nameUOMSku(s)  //  idBarcodeSku
    FILTERS           isParentSkuGroupSku(sk, s),
                      IF multipleStores() THEN 
                          st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                        ELSE 
                            st == ss,
                      isCompanyStock(st) OR NOT multipleStores()

    FILTERGROUP inactiveStock FILTER 'Активный' activeStock(st) OR NOT multipleStores() 'ctrl F10' DEFAULT

    PROPERTIES(s, st, t) READONLY balanceBSkuStockDateTime, averagePriceBSkuStockDateTime, sumBSkuStockDateTime
    PROPERTIES(s, st) READONLY dateTimeLastMovedSkuStock
    
    FILTERGROUP container 
        FILTER 'Товар' isItemSku(s) 
        FILTER 'Тара' isContainerSku(s)
        
    FILTERGROUP filters
        FILTER 'Товары с остатком' balanceBSkuStockDateTime(s, st, t) OR sumBSkuStockDateTime(s, st, t) 'F10' DEFAULT
        FILTER 'Товары с движением не позднее 1 дня' balanceSkuStockDateTimePeriod(s, st, t, 1) 'F9'
        FILTER 'Товары с движением не позднее 7 дней' balanceSkuStockDateTimePeriod(s, st, t, 7) 'F8'
        FILTER 'Товары с движением не позднее 30 дней' balanceSkuStockDateTimePeriod(s, st, t, 30) 'F7'

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger, nameBatchSkuLedger,
                    signedQuantitySkuLedger, signedPriceSkuLedger, signedSumSkuLedger
    FILTERS isPostedSkuLedger(bil) AND skuSkuLedger(bil)==s AND stockSkuLedger(bil)==st
    ORDER BY dateTimeSkuLedger(bil) DESC

    OBJECTS bt=Batch
    PROPERTIES(bt) READONLY      numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, idBatch, shippedQuantityBatch, costBatch
    PROPERTIES(bt, st, t) READONLY  balanceBBatchStockDateTime
    FILTERS isPostedBatch(bt) AND skuBatch(bt)==s
    ORDER BY dateTimeBatch(bt) DESC
;

DESIGN balanceSkuStock {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            MOVE PROPERTY (valT);
            MOVE PROPERTY (multipleStores());
            MOVE PROPERTY (nameStock(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;
            
            NEW firstCaseTwo {
                fill = 1;
                type = SPLITV;
                MOVE stockTree.tree.box { caption = 'Склады'; }
                MOVE skuTree.tree.box { caption = 'Группы'; }
            }

            NEW secondCase {
                fill = 3;
                type = SPLITV;
                NEW sku.box {
                    fill = 2;
                    MOVE sts.box {
                        fill = 2;
                    }
                }
                NEW ledger.box {
                    fill = 1;
                    caption = 'Изменение цен';
                    type = TABBED;
                    MOVE bil.box;
                    MOVE bt.box;
                }
            }
        }
        MOVE functions.box;
    }
}
@extendFormFilterStockGroupAccess(sg, balanceSkuStock);
EXTEND FORM balanceSkuStock FILTERS accessCompanyEmployeeStock(currentUser(), st) OR NOT multipleStores();

@extendFormFilterStockAccess(ss, balanceSkuStock);

@extendFormFilterStockAccess(ts, balanceSkuStock);

// ------------------------------------------------ Остатки по партиям ---------------------------------------- //

FORM currentBalanceBatchStock 'Текущие остатки по партиям'

    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) nameStock SELECTOR SHOWIF singleStore()
    FILTERS isCompanyStock(ss)   

    TREE stockTree a = STRING[3], sg = StockGroup PARENT parentStockGroup, ts = Stock
    PROPERTIES READONLY SHOWIF multipleStores() OBJVALUE(a), sgTreeName = nameStockGroup(sg), tsTreeName = nameStock(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroupStock(ts) == sg,
            isCompanyStock(ts)
    FILTERGROUP sginactiveStock FILTER 'Активный' activeStock(ts) 'ctrl F10' DEFAULT
    TREE skuTree sk = SkuGroup PARENT parentSkuGroup
    PROPERTIES READONLY orderSkuGroup(sk), skuTreeName = nameSkuGroup(sk)
    ORDER BY orderSkuGroup(sk), skuTreeName
    FILTERGROUP inactive FILTER 'Активные' activeSkuGroup(sk) 'F5' DEFAULT
       
    OBJECTS           stb=(st=Stock, bt=Batch)
    PROPERTIES        READONLY nameSkuBatch(bt), stockName = nameStock(st) SHOWIF multipleStores()
    PROPERTIES        READONLY currentBalanceBatchStock(bt, st)
    PROPERTIES(bt)    READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, idBatch, shippedQuantityBatch, costBatch, expiryDateBatch
    FILTERS           isParentSkuGroupBatch(sk, bt),
                      IF multipleStores() THEN 
                          st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                        ELSE 
                            st == ss,    
//                      st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts,
                      isCompanyStock(st) OR NOT multipleStores()
    FILTERGROUP inactiveStock FILTER 'Активный' activeStock(st) OR NOT multipleStores() 'ctrl F10' DEFAULT
    ORDER BY          dateTimeBatch(bt)

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger,
                    signedQuantitySkuLedger, signedPriceSkuLedger, signedSumSkuLedger, skipSkuLedger
    FILTERS isPostedSkuLedger(bil) AND (costSkuLedgerBatch(bil, bt) OR batchSkuLedger(bil)==bt) AND stockSkuLedger(bil)==st   //skuSkuLedger(bil)==skuBatch(bt)
    ORDER BY dateTimeSkuLedger(bil) DESC
    FILTERGROUP container 
        FILTER 'Товар' isItemBatch(bt) 
        FILTER 'Тара' isContainerBatch(bt)
        
    FILTERGROUP filterBalance
        FILTER 'Партии с остатком' currentBalanceBatchStock(bt, st) 'F11' DEFAULT
        FILTER 'Партии пришедшие за последний 1 день' dateBatch(bt) >= subtractDate(currentDate(), 1) 'F10'
        FILTER 'Партии пришедшие за последние 7 дней' dateBatch(bt) >= subtractDate(currentDate(), 7) 'F9'
        FILTER 'Партии пришедшие за последние 30 дней' dateBatch(bt) >= subtractDate(currentDate(), 30) 'F8'

    FILTERGROUP filterExpiry
        FILTER 'Партии с истекшим сроком годности' expiryDateBatch(bt) < currentDate() 'F7'
        FILTER 'Партии со сроком годности, истекающим через 1 день' expiresBatchDate(bt, currentDate(), 1) 'F6'
        FILTER 'Партии со сроком годности, истекающим через 7 дней' expiresBatchDate(bt, currentDate(), 7) 'F5'
        FILTER 'Партии со сроком годности, истекающим через 30 дней' expiresBatchDate(bt, currentDate(), 30) 'F4'
;

DESIGN currentBalanceBatchStock {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            MOVE PROPERTY (multipleStores());
            MOVE PROPERTY (nameStock(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;

            NEW firstCase {
                fill = 1;
                type = SPLITV;
                MOVE stockTree.tree.box { caption = 'Склады'; }
                MOVE skuTree.tree.box { caption = 'Группы'; }
            }
            NEW secondCase {
                fill = 3;
                type = SPLITV;
                NEW sku.box {
                    fill = 2;
                    MOVE stb.box {
                        caption = 'Партии';
                        fill = 2;
                    }
                }
                NEW ledger.box {
                    fill = 1;
                    type = TABBED;
                    MOVE bil.box {caption = 'Движение';}
                }
             }            
            
        }

        MOVE functions.box;
    }
}
@extendFormFilterStockGroupAccess(sg, currentBalanceBatchStock);
EXTEND FORM currentBalanceBatchStock FILTERS accessCompanyEmployeeStock(currentUser(), st) OR NOT multipleStores();

@extendFormFilterStockAccess(ss, currentBalanceBatchStock);

@extendFormFilterStockAccess(ts, currentBalanceBatchStock);

FORM balanceBatchStock 'Остатки по партиям на дату'

    OBJECTS t=DATETIME FIXED PANEL
    PROPERTIES   valT = OBJVALUE(t)
    
    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) nameStock SELECTOR SHOWIF singleStore()
    FILTERS isCompanyStock(ss)  
    
    TREE stockTree a = STRING[3], sg = StockGroup PARENT parentStockGroup, ts = Stock
    PROPERTIES READONLY SHOWIF multipleStores() OBJVALUE(a), sgTreeName = nameStockGroup(sg), tsTreeName = nameStock(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroupStock(ts) == sg,
            isCompanyStock(ts)
    FILTERGROUP sginactiveStock FILTER 'Активный' activeStock(ts) 'ctrl F10' DEFAULT
    TREE skuTree sk = SkuGroup PARENT parentSkuGroup
    PROPERTIES READONLY orderSkuGroup(sk), skuTreeName = nameSkuGroup(sk)
    ORDER BY orderSkuGroup(sk), skuTreeName
    FILTERGROUP inactive FILTER 'Активные' activeSkuGroup(sk) 'F5' DEFAULT

    OBJECTS           stb=(st=Stock, bt=Batch)
    PROPERTIES        READONLY stockName = nameStock(st) SHOWIF multipleStores(), nameSkuBatch(bt)
    PROPERTIES        READONLY  balanceBBatchStockDateTime(bt, st, t)
    PROPERTIES(bt)    READONLY numberBatch, seriesBatch, dateTimeBatch, nameSupplierBatch, nameBatch, idBatch, shippedQuantityBatch, costBatch, expiryDateBatch
    FILTERS           isParentSkuGroupBatch(sk, bt),
                      IF multipleStores() THEN 
                          st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                        ELSE 
                            st == ss,    
                      isCompanyStock(st) OR NOT multipleStores()
    FILTERGROUP inactiveStock FILTER 'Активный' activeStock(st) OR NOT multipleStores() 'ctrl F10' DEFAULT
    ORDER BY          dateTimeBatch(bt)

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTimeSkuLedger, descriptionSkuLedger,
                    signedQuantitySkuLedger, signedPriceSkuLedger, signedSumSkuLedger, skipSkuLedger
    FILTERS isPostedSkuLedger(bil) AND skuSkuLedger(bil)==skuBatch(bt) AND stockSkuLedger(bil)==st,
            dateTimeSkuLedger(bil) < t
    ORDER BY dateTimeSkuLedger(bil) DESC
    FILTERGROUP container 
        FILTER 'Товар' isItemBatch(bt) 
        FILTER 'Тара' isContainerBatch(bt)
        
    FILTERGROUP filterBalance
        FILTER 'Партии с остатком' balanceBBatchStockDateTime(bt, st, t) 'F11' DEFAULT
        FILTER 'Партии пришедшие за последний 1 день' dateTimeBatch(bt) >= subtractDateTimeSeconds(currentDateTime(), 1) 'F10'
        FILTER 'Партии пришедшие за последние 7 дней' dateTimeBatch(bt) >= subtractDateTimeSeconds(currentDateTime(), 7) 'F9'
        FILTER 'Партии пришедшие за последние 30 дней' dateTimeBatch(bt) >= subtractDateTimeSeconds(currentDateTime(), 30) 'F8'

    FILTERGROUP filterExpiry
        FILTER 'Партии с истекшим сроком годности' expiryDateBatch(bt) < toDate(t) 'F7'
        FILTER 'Партии со сроком годности, истекающим через 1 день' expiresBatchDateTime(bt, t, 1) 'F6'
        FILTER 'Партии со сроком годности, истекающим через 7 дней' expiresBatchDateTime(bt, t, 7) 'F5'
        FILTER 'Партии со сроком годности, истекающим через 30 дней' expiresBatchDateTime(bt, t, 30) 'F4'
;

DESIGN balanceBatchStock {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            MOVE PROPERTY (valT);
            MOVE PROPERTY (multipleStores());
            MOVE PROPERTY (nameStock(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;
            
            NEW firstCaseTwo {
                fill = 1;
                type = SPLITV;
                MOVE stockTree.tree.box { caption = 'Склады'; }
                MOVE skuTree.tree.box { caption = 'Группы'; }
            }
            NEW secondCase {
                fill = 3;
                type = SPLITV;
                NEW sku.box {
                    fill = 2;
                    MOVE stb.box {
                        caption = 'Партии';
                        fill = 2;
                    }
                }

                NEW ledger.box {
                    fill = 1;
                    type = TABBED;
                    MOVE bil.box {caption = 'Движение';}

                }
            }            
            
            
        }

        MOVE functions.box;
    }
}
@extendFormFilterStockGroupAccess(sg, balanceBatchStock);

EXTEND FORM balanceBatchStock FILTERS accessCompanyEmployeeStock(currentUser(), st) OR NOT multipleStores();

@extendFormFilterStockAccess(ss, balanceBatchStock);

@extendFormFilterStockAccess(ts, balanceBatchStock);

FORM skuLedger 'Регистр движений'

    OBJECTS dates = (dFrom = DATE, dTo = DATE) FIXED PANEL
    PROPERTIES valFrom = OBJVALUE(dFrom), valTo = OBJVALUE(dTo)

    OBJECTS s = SkuLedger
    PROPERTIES(s) READONLY dateSkuLedger, dateTimeSkuLedger, canonicalNameSkuGroupSkuLedger, nameSkuSkuLedger, descriptionSkuLedger, nameStockSkuLedger,
                           signedQuantitySkuLedger, signedPriceSkuLedger, signedSumSkuLedger, costSumSkuLedger
    PROPERTIES(s) editSkuLedger SHOWIF allowedEditSkuLedger(s)
    FILTERS isPostedSkuLedger(s)

    FILTERS dateSkuLedger(s) >= dFrom, dateSkuLedger(s) <= dTo
    
    FILTERGROUP container 
        FILTER 'Товар' isItemSkuLedger(s) 
        FILTER 'Тара' isContainerSkuLedger(s)    
;

DESIGN skuLedger {
    MOVE dates.box {
        type = CONTAINERH;
    }
    MOVE s.box {
        type = CONTAINERV;
    }
    MOVE functions.box;
}

NAVIGATOR {
    stockNavigator {
        NEW balanceSku 'Остатки по товару' BEFORE stockReports {
            ADD currentBalanceSkuStock;
            ADD balanceSkuStock;
        }
        NEW balanceBatch 'Остатки по партиям' BEFORE stockReports {
            ADD currentBalanceBatchStock;
            ADD balanceBatchStock;
            ADD batches;
        }
        NEW stockCost 'Себестоимость' BEFORE stockReports {
            ADD costSkuLedger;
            ADD costSkuBatchLedger;
        }
        stockReports{
            ADD skuLedger;
        }
    }
}

// ----------------------------------------------------------------------------- //

skuGroup1Batch 'Категория' (batch) = skuGroup1Sku(skuBatch(batch));
nameSkuGroup1Batch 'Категория' (batch) = nameSkuGroup(skuGroup1Batch(batch));
 
skuGroup2Batch 'Направление' (batch) = skuGroup2Sku(skuBatch(batch));
nameSkuGroup2Batch 'Направление' (batch) = nameSkuGroup(skuGroup2Batch(batch));

skuGroup3Batch 'Группа' (batch) = skuGroup3Sku(skuBatch(batch));
nameSkuGroup3Batch 'Группа' (batch) = nameSkuGroup(skuGroup3Batch(batch));

skuGroup4Batch 'Подгруппа' (batch) = skuGroup4Sku(skuBatch(batch));
nameSkuGroup4Batch 'Подгруппа' (batch) = nameSkuGroup(skuGroup4Batch(batch));

skuGroup5Batch 'Субгруппа' (batch) = skuGroup5Sku(skuBatch(batch));
nameSkuGroup5Batch 'Субгруппа' (batch) = nameSkuGroup(skuGroup5Batch(batch));

// ---------------------------------------------- Макросы ------------------------------------------------ //

META implementSkuLedger(object, skuProp, stockProp)
    dateTimeDataSkuLedger (ledger) += dateTime###object(ledger);
    isPostedDataSkuLedger (ledger) += isPosted###object(ledger);
    isClosedDataSkuLedger (ledger) += isClosed###object(ledger);
    skuDataSkuLedger (ledger) += skuProp###object(ledger);
    stockDataSkuLedger (ledger) += stockProp###object(ledger);
    descriptionDataSkuLedger (ledger) += description###object(ledger);
END

META defineSkuLedgerAggregation(primObject, aggrObject, skuProp, stockProp)
    dateTime###aggrObject (batch) = dateTime###primObject(primObject###aggrObject(batch));
    isPosted###aggrObject (batch) = isPosted###primObject(primObject###aggrObject(batch));
    isClosed###aggrObject (batch) = isClosed###primObject(primObject###aggrObject(batch));
    sku###aggrObject (batch) = sku###primObject(primObject###aggrObject(batch));
    stock###aggrObject (batch) = stockProp###primObject(primObject###aggrObject(batch));
    description###aggrObject (batch) = description###primObject(primObject###aggrObject(batch));
END

META implementSkuLedgerInLIFO(object, skuProp, stockProp)
    EXTEND CLASS object : InLIFOSkuLedger;
    @implementSkuLedger(object, skuProp, stockProp);
END

META implementSkuLedgerInLIFOBatchBalancePostfix (object, stockProp, postfix)
    limitInLIFOSkuLedgerBatch(ledger, batch) += IF batch###object(ledger) THEN
                                                    quantity###object(ledger) IF batch == batch###object(ledger)
                                                 ELSE
                                                    outcome##postfix##Batch(batch) IF
                                                    countLedger##postfix##BatchStock(batch, stockProp###object(ledger));
    changedDataSkuLedger(ledger) += CHANGED(batch###object(ledger));
END

META implementSkuLedgerInLIFOBatchBalance (object, stockProp)
    @implementSkuLedgerInLIFOBatchBalancePostfix(object, stockProp, );
END

META implementSkuLedgerInLIFOBalancePostfix (object, stockProp, postfix)
    limitInLIFOSkuLedgerBatch(ledger, batch) += outcome##postfix##Batch(batch) IF
                                                countLedger##postfix##BatchStock(batch, stockProp###object(ledger));
END

META implementSkuLedgerInLIFOBalance (object, stockProp)
    @implementSkuLedgerInLIFOBalancePostfix(object, stockProp, );
END

META implementSkuLedgerOutFIFO(object, skuProp, stockProp)
    EXTEND CLASS object : OutFIFOSkuLedger;
    @implementSkuLedger(object, skuProp, stockProp);
END

META implementSkuLedgerOutFIFOBatchBalancePostfix (object, stockProp, postfix)
    limitOutFIFOSkuLedgerBatch(ledger, batch) += IF batch###object(ledger) THEN
                                                    quantity###object(ledger) IF batch == batch###object(ledger)
                                                 ELSE
                                                    OVERRIDE 0.0 IF countLedger##postfix##BatchStock(batch, stockProp###object(ledger)), currentBalance##postfix##BatchStock(batch, stockProp###object(ledger));
    changedDataSkuLedger(ledger) += CHANGED(batch###object(ledger));
END

META implementSkuLedgerOutFIFOBatchBalance (object, stockProp)
    @implementSkuLedgerOutFIFOBatchBalancePostfix(object, stockProp, );
END

META implementSkuLedgerOutFIFOBalancePostfix (object, stockProp, postfix)
    limitOutFIFOSkuLedgerBatch(ledger, batch) += OVERRIDE 0.0 IF countLedger##postfix##BatchStock(batch, stockProp###object(ledger)), currentBalance##postfix##BatchStock(batch, stockProp###object(ledger));
END

META implementSkuLedgerOutFIFOBalance (object, stockProp)
    @implementSkuLedgerOutFIFOBalancePostfix(object, stockProp, );
END

META implementBatchCustom(object, skuProp, stockProp, costProp)
    dateTimeBatch (batch) += dateTime###object(batch);
    isPostedBatch (batch) += isPosted###object(batch);
    isClosedBatch (batch) += isClosed###object(batch);
    skuBatch (batch) += skuProp###object(batch);
    stockBatch (batch) += stockProp###object(batch);
    descriptionBatch (batch) += description###object(batch);
    costBatch (batch) += costProp###object(batch);
END //-- (не забывать имплементить nameBatch)

META implementBatch(object, skuProp, stockProp, costProp)
    EXTEND CLASS object : Batch;
    @implementBatchCustom(object, skuProp, stockProp, costProp);
END

META defineConstraintSkuLedgerCosted (concrete, caption)
    CONSTRAINT (SET(changedCostDataSkuLedger(detail)) OR CHANGED(costedDataSkuLedger(detail))) AND isPosted###concrete##Detail(detail) AND NOT quantity###concrete##Detail(detail) == costedDataSkuLedger(detail)
        MESSAGE caption;
END

//-------------------------------------------------- Добавление партий в документ --------------------------------------//

META defineDocumentDetailBatchCustomPrefix(detail, batchProp, prefix)
    @defineDocumentDetailBatchCustomPrefixInner(detail, batchProp, ###batchProp, prefix);
END

META defineDocumentDetailBatchCustomPrefixInner(detail, batchProp, batchClass, prefix)
    prefix###batchProp###detail = DATA batchClass (###detail) INDEXED;
    prefix###description###batchProp###detail 'Партия' (detail) = Stock.descriptionBatch(prefix###batchProp###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
    prefix###name###batchProp###detail 'Партия' (detail) = nameBatch(prefix###batchProp###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;

    CONSTRAINT skuBatch(prefix###batchProp###detail(detail)) != prefix###sku###detail(detail) CHECKED BY prefix###batchProp###detail
        MESSAGE 'Товар партии строки должен соответствовать SKU строки';

    CONSTRAINT prefix###batchProp###detail(detail) AND NOT prefix###sku###detail(detail) CHECKED BY prefix###batchProp###detail
        MESSAGE 'Для строки задана партия, но не задан товар';
END

//META defineDocumentDetailBatchCustom(detail, batchProp)
//    batch###detail = DATA batchProp (Detail);
//    descriptionBatch###detail 'Партия' (detail) = descriptionBatch(batch###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
//
//    CONSTRAINT skuBatch(batch###detail(detail)) != sku###detail(detail) CHECKED BY batch###detail
//        MESSAGE 'Товар партии строки должен соответствовать SKU строки';
//
//    CONSTRAINT batch###detail(detail) AND NOT sku###detail(detail) CHECKED BY batch###detail
//        MESSAGE 'Для строки задана парктия, но не задан товар';
//END
META defineDocumentDetailBatchCustom(detail, batchProp)
    @defineDocumentDetailBatchCustomPrefix(detail, batchProp, );
END

META defineDocumentAbstractDetailBatchCustom(detail, batchProp)
    @defineDocumentAbstractDetailBatchCustomInner(detail, batchProp, ###batchProp);
END

META defineDocumentAbstractDetailBatchCustomInner(detail, batchProp, batchClass)
    batch###detail = ABSTRACT batchClass (###detail) PERSISTENT INDEXED;
    descriptionBatch###detail 'Партия' (detail) = descriptionBatch(batch###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
    nameBatch###detail 'Партия' (detail) = nameBatch(batch###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
END
META defineDocumentInterfaceDetailBatchCustom(detail, batchProp)
    @defineDocumentAbstractDetailBatchCustom(detail, batchProp);
    @defineDocumentDetailBatchCustom(user###detail, batchProp);
    batch###detail(detail) += batch###user###detail(detail);
END

META defineDocumentDetailBatch(object, batchProp)
    @defineDocumentDetailBatchCustom(object##Detail, batchProp);
END
META defineDocumentAbstractDetailBatch(object, batchProp)
    @defineDocumentAbstractDetailBatchCustom(object##Detail, batchProp);
END
META defineDocumentInterfaceDetailBatch(object, batchProp)
    @defineDocumentInterfaceDetailBatchCustom(object##Detail, batchProp);
END

META defineDocumentDetailExpiryDateCustomPrefix(detail, prefix)
    prefix###expiryDate###detail 'Годен до' = DATA DATE (###detail);
END
META defineDocumentAbstractDetailExpiryDateCustomPrefix(detail, prefix)
    prefix###expiryDate###detail 'Годен до' = ABSTRACT DATE (###detail) PERSISTENT;
END
META defineDocumentInterfaceDetailExpiryDateCustomPrefix(detail, prefix)
    @defineDocumentAbstractDetailExpiryDateCustomPrefix(detail, prefix);
    @defineDocumentDetailExpiryDateCustomPrefix(user###detail, prefix);
    prefix###expiryDate###detail(detail) += prefix###expiryDate###user###detail(detail);
END

META defineDocumentInterfaceDetailExpiryDatePrefix(object, prefix)
    @defineDocumentInterfaceDetailExpiryDateCustomPrefix(object##Detail, prefix);
END

META defineDocumentInterfaceDetailExpiryDate(object)
    @defineDocumentInterfaceDetailExpiryDatePrefix(object, );
END

META defineDocumentDetailManufactureDateCustomPrefix(detail, prefix)
    prefix###manufactureDate###detail 'Дата изготовления' = DATA DATE (###detail);
END
META defineDocumentAbstractDetailManufactureDateCustomPrefix(detail, prefix)
    prefix###manufactureDate###detail 'Дата изготовления' = ABSTRACT DATE (###detail) PERSISTENT;
END
META defineDocumentInterfaceDetailManufactureDateCustomPrefix(detail, prefix)
    @defineDocumentAbstractDetailManufactureDateCustomPrefix(detail, prefix);
    @defineDocumentDetailManufactureDateCustomPrefix(user###detail, prefix);
    prefix###manufactureDate###detail(detail) += prefix###manufactureDate###user###detail(detail);
END

META defineDocumentInterfaceDetailManufactureDatePrefix(object, prefix)
    @defineDocumentInterfaceDetailManufactureDateCustomPrefix(object##Detail, prefix);
END

META defineDocumentInterfaceDetailManufactureDate(object)
    @defineDocumentInterfaceDetailManufactureDatePrefix(object, );
END

// ---------------------------------- Остаток (до) ----------------------- //

META defineDocumentDetailSkuBalanceCustom (detail)
    balanceBSku###detail 'Количество до' (detail) = DATA NUMERIC[14,3] (###detail);

END
META defineDocumentAbstractDetailSkuBalanceCustom (detail)
    balanceBSku###detail 'Количество до' (detail) = ABSTRACT NUMERIC[14,3] (###detail) PERSISTENT;
END

META defineDocumentInterfaceDetailSkuBalanceCustom(detail)
    @defineDocumentAbstractDetailSkuBalanceCustom(detail);
    @defineDocumentDetailSkuBalanceCustom(user###detail);
    balanceBSku###detail(detail) += balanceBSku###user###detail(detail);
END
META defineDocumentInterfaceDetailSkuBalance(object)
    @defineDocumentInterfaceDetailSkuBalanceCustom(object##Detail);
END

META deriveDocumentDetailSkuBalanceCustom (detail, skuProp, stockProp)
    balanceBSku###detail (detail)  <- prevBalanceBSkuStockDateTime(skuProp###detail(detail), stockProp###detail(detail), dateTime###detail(detail))
        WHEN CHANGED(skuProp###detail(detail)) OR CHANGED(stockProp###detail(detail)) OR CHANGED(dateTime###detail(detail));
END
META deriveDocumentDetailSkuBalance (object, skuProp, stockProp)
    @deriveDocumentDetailSkuBalanceCustom(object##Detail, skuProp, stockProp);
END

//замена товара у партии
allowReplaceItem = DATA LOCAL BOOLEAN ();

setSkuBatch 'Сменить товар' = ACTION (batch) {
    FORM skus MODAL;
    IF formResult() == FormResult.ok THEN {  
        allowReplaceItem() <- TRUE;
        replaceSkuBatch(chosenObject('s'), batch);
    }       
    apply();
} CONFIRM TOOLBAR;

EXTEND FORM currentBalanceBatchStock
	PROPERTIES(bt) setSkuBatch FORCE PANEL TOOLBAR
;