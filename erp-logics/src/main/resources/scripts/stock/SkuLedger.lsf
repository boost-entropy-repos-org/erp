MODULE SkuLedger;

REQUIRE Stock, Sku, EmployeeStock, Document;

NAMESPACE Stock;

// ----------------------------------- Ledger ------------------------------------------ //

CLASS ABSTRACT COMPLEX SkuLedger 'Изменение остатка по товару';
TABLE skuLedger (SkuLedger) FULL;

CLASS ABSTRACT InSkuLedger 'Приход' : SkuLedger;
CLASS ABSTRACT OutSkuLedger 'Расход' : SkuLedger;

CLASS ABSTRACT Batch 'Партия' : InSkuLedger;

CLASS ABSTRACT DataSkuLedger 'Изменение остатка с первичной себестоимостью' : SkuLedger;

CLASS ABSTRACT InLIFOSkuLedger 'Приход по LIFO' : InSkuLedger, DataSkuLedger;
CLASS ABSTRACT OutFIFOSkuLedger 'Расход по FIFO' : OutSkuLedger, DataSkuLedger;

edit 'Редактировать' = ACTION ABSTRACT MULTI (SkuLedger) IMAGE 'edit.png' EDITKEY 'BACK_SPACE' HIDE TOOLBAR;
show 'Просмотреть' = ACTION ABSTRACT MULTI (SkuLedger) TOOLBAR;
replace = ACTION ABSTRACT LIST (Sku, Batch);
// --------------------------------- Партии ------------------------------------------------ //

TABLE batch(Batch);
TABLE skuLedgerBatch (SkuLedger, Batch);
TABLE batchStock(Batch, Stock);

dateTime 'Дата/время' (batch) = ABSTRACT DATETIME (Batch) PERSISTENT INDEXED;
date 'Дата' (Batch batch) = toDate(dateTime(batch));
time 'Время' (Batch batch) = toTime(dateTime(batch));
prevDateTime (Batch b) = PREV(dateTime(b));

isPosted 'Проведен' (batch) = ABSTRACT BOOLEAN (Batch) PERSISTENT;

isClosed 'Закрыт' (batch) = ABSTRACT BOOLEAN (Batch);

sku (batch) = ABSTRACT Sku (Batch) PERSISTENT INDEXED;
prevSku (Batch b) = PREV(sku(b));
idSku 'Код товара' = id(sku(Batch b));
nameSku 'Наименование' (Batch batch) = name(sku(batch)) IN recognize;

// Наименование для документов
overDocumentNameSku = ABSTRACT VARISTRING[255] (Batch) PERSISTENT;
documentNameSku 'Наименование (для документов)' (Batch batch) = OVERRIDE nameSku(batch), overDocumentNameSku(batch);

useDocumentNameSku 'Использовать наименование для документов' = DATA BOOLEAN ();

EXTEND FORM options
    PROPERTIES() useDocumentNameSku
;

DESIGN options {
    pane {
        stock1 {
            MOVE PROPERTY(useDocumentNameSku());
        }
    }
}

lastBatch (sku) = GROUP LAST Batch batch 
    BY sku(batch)
    ORDER dateTime(batch), batch
    WHERE dateTime(batch);

netWeightSku 'Вес нетто' (Batch batch) = netWeight(sku(batch));
grossWeightSku 'Вес брутто' (Batch batch) = grossWeight(sku(batch));
prevNameSku 'Наименование' (Batch batch) = PREV(name(sku(batch))) IN recognize;
activeSku 'Активные' (Batch batch) = active(sku(batch));

UOM(Batch batch)= UOM(sku(batch));
shortNameUOM 'Единица измерений' (Batch batch)= shortNameUOM(sku(batch));

country (Batch batch) = country(sku(batch));
sidOrigin2Country (Batch batch) = sidOrigin2(country(batch));

stock (batch) = ABSTRACT Stock (Batch) PERSISTENT INDEXED ;
nameStock 'Склад' (Batch batch) = name(stock(batch));

cost 'Себестоимость' (batch) = ABSTRACT NUMERIC[14,2] (Batch) PERSISTENT;
prevCost 'Себестоимость' (Batch batch) = PREV(cost(batch));

description 'Описание' (batch) = ABSTRACT VARSTRING[200] (Batch) PERSISTENT IN recognize MINCHARWIDTH 30 PREFCHARWIDTH 60;
name 'Название' (batch) = ABSTRACT VARISTRING[200] (Batch) PERSISTENT IN recognize MINCHARWIDTH 30 PREFCHARWIDTH 60;

expiryDate 'Годен до' (batch) = ABSTRACT DATE (Batch) PERSISTENT INDEXED;
prevExpiryDate 'Годен до' (Batch batch) = PREV(expiryDate(batch));

manufactureDate 'Дата изготовления' (batch) = ABSTRACT DATE (Batch) PERSISTENT INDEXED;
prevManufactureDate 'Дата изготовления' (Batch batch) = PREV(manufactureDate(batch));

number 'Номер документа' = ABSTRACT VARSTRING[28] (Batch) MINCHARWIDTH 8 PERSISTENT;
series 'Серия документа' = ABSTRACT STRING[2] (Batch) FIXEDCHARWIDTH 3 PERSISTENT;
seriesNumber 'Серия/Номер' (Batch o) = CONCAT '', series(o), number(o) MINCHARWIDTH 7 PREFCHARWIDTH 10 MAXCHARWIDTH 20 PERSISTENT;
    
supplier = ABSTRACT LegalEntity (Batch) PERSISTENT;
prevSupplier (Batch batch) = PREV(supplier(batch));

nameSupplier 'Поставщик' (Batch batch) = name(supplier(batch));
fullNameSupplier 'Поставщик' (Batch batch) = fullName(supplier(batch));

idSupplier 'Код поставщика' (Batch batch) = id(supplier(batch));
addressSupplier 'Адрес поставщика' (Batch batch) = address(supplier(batch));

supplierGroup (Batch batch) = legalEntityGroup(supplier(batch));

supplierStock = ABSTRACT Stock (Batch) PERSISTENT;
nameSupplierStock 'Склад поставщика' (Batch batch) = name(supplierStock(batch));

id 'Код' = ABSTRACT VARSTRING[100] (Batch) PERSISTENT INDEXED MINCHARWIDTH 10 PREFCHARWIDTH 15;
batch = GROUP MAX Batch b BY id(b);

@defineOption(disableUniqueIdBatch, 'Не контролировать уникальность кодов партий', stock);
CONSTRAINT SETCHANGED(id(Batch b)) AND [= GROUP SUM 1 BY id(Batch b)](id(b)) > 1 AND NOT disableUniqueIdBatch() MESSAGE 'Нарушена уникальность свойства Код партии';

expires(Batch batch, DATETIME dateTime, LONG period) = expiryDate(batch) < sum(toDate(dateTime), period);
expires(Batch batch, DATE date, LONG period) = expiryDate(batch) < sum(date, period);

order (Batch batch) = STRUCT(dateTime(batch), batch) PERSISTENT;

isBatch (Batch batch, Sku sku) = sku(batch) == sku;

isParent (SkuGroup skuGroup, Batch batch) = isParent(skuGroup, sku(batch));
isParent (Group group, Batch batch) = isParent(group, sku(batch));

isItem 'Товар' = isItem(sku(Batch bt));
isContainer 'Тара' = isContainer(sku(Batch bt));

isNotItem 'Не товар' = isNotItem(sku(Batch bt));
isNotContainer 'Не тара' = isNotContainer(sku(Batch bt));

batch = ABSTRACT Batch (SkuLedger) PERSISTENT INDEXED;
nameBatch 'Партия' (SkuLedger l) = name(batch(l));

//---------------------------- Количественные регистры (конкретная реализация) ----------------------------------------//

dateTime 'Дата/время' = ABSTRACT DATETIME (DataSkuLedger) PERSISTENT INDEXED;
date 'Дата' (DataSkuLedger ledger) = toDate(dateTime(ledger)) PERSISTENT;

isPosted 'Проведен' = ABSTRACT BOOLEAN (DataSkuLedger) PERSISTENT;

isClosed 'Закрыт' = ABSTRACT BOOLEAN (DataSkuLedger);

sku = ABSTRACT Sku (DataSkuLedger) PERSISTENT INDEXED;

stock = ABSTRACT Stock(DataSkuLedger) PERSISTENT INDEXED;

description 'Название документа' = ABSTRACT VARSTRING[200] (DataSkuLedger) PERSISTENT;

changed = ABSTRACT BOOLEAN (DataSkuLedger);

// -------------------------------- Для всего ledger'а -------------------- //

dateTime 'Дата/время' (SkuLedger ledger) = MULTI dateTime[DataSkuLedger] (ledger), dateTime[Batch] (ledger) PERSISTENT INDEXED IN recognize;
date 'Дата' (SkuLedger ledger) = toDate(dateTime(ledger)) PERSISTENT INDEXED;

isPosted 'Проведен' (SkuLedger ledger) = MULTI isPosted[DataSkuLedger] (ledger), isPosted[Batch] (ledger) PERSISTENT;

isClosed 'Закрыт' (SkuLedger ledger) = MULTI isClosed[DataSkuLedger] (ledger), isClosed[Batch] (ledger);

sku (SkuLedger ledger) = MULTI sku[DataSkuLedger] (ledger), sku[Batch] (ledger) PERSISTENT;
nameSku 'SKU' (SkuLedger ledger) = name(sku(ledger)) IN recognize;

INDEX sku(SkuLedger l), dateTime(l);

canonicalNameSkuGroup 'Группа' (SkuLedger ledger) = canonicalName[Group](skuGroup(sku(ledger)));

countSkuLedger = GROUP SUM 1 BY sku(SkuLedger ledger);

stock (SkuLedger ledger) = MULTI stock[DataSkuLedger] (ledger), stock[Batch] (ledger) PERSISTENT;
nameStock 'Склад' (SkuLedger ledger) = name(stock(ledger)) IN recognize;
isCompanyStock (SkuLedger ledger) = isCompany(stock(ledger));
idStock (SkuLedger ledger) = id(stock(ledger));

INDEX stock(SkuLedger l), sku(l), dateTime(l);

description 'Описание' (SkuLedger ledger) = MULTI description[DataSkuLedger] (ledger), description[Batch] (ledger) PERSISTENT IN recognize;

isItem 'Товар' = isItem(sku(SkuLedger l));
isContainer 'Тара' = isContainer(sku(SkuLedger l));

isNotItem 'Не товар' = isNotItem(sku(SkuLedger l));
isNotContainer 'Не тара' = isNotContainer(sku(SkuLedger l));

// -------------------------------- Количества ---------------------------- //

quantity 'Кол-во в партии' = ABSTRACT NUMERIC[16,5] (Batch) PERSISTENT;

extraShippedQuantity = ABSTRACT NUMERIC[16,5] (Batch);
shippedQuantity 'Кол-во в партии (всего)' (Batch batch) = quantity(batch) (+) extraShippedQuantity(batch) PERSISTENT;

quantity 'Кол-во' (ledger) = ABSTRACT NUMERIC[16,5] (InLIFOSkuLedger) PERSISTENT;

quantity 'Кол-во' (InSkuLedger ledger) = MULTI quantity[Batch](ledger),
                                              quantity[InLIFOSkuLedger](ledger) PERSISTENT;

quantity 'Кол-во' = ABSTRACT NUMERIC[16,5] (OutFIFOSkuLedger) PERSISTENT;

quantityOut 'Кол-во' (OutFIFOSkuLedger ledger) = MULTI quantity(ledger) PERSISTENT;

quantity 'Кол-во' (DataSkuLedger ledger) = MULTI quantity[InLIFOSkuLedger](ledger),
                                                quantity[OutFIFOSkuLedger](ledger) PERSISTENT;

quantity 'Кол-во' (SkuLedger ledger) = MULTI quantity[InSkuLedger](ledger),
                                            quantityOut(ledger) PERSISTENT;

signedQuantity 'Кол-во' (SkuLedger ledger) = MULTI quantity[InSkuLedger](ledger),
                                                  -quantityOut(ledger) PERSISTENT;

// -------------------------------------------- Расчет себестоимости -------------------------------------- //

explicitBatchLedger 'Обязательный партионный учет' = ABSTRACT BOOLEAN (Stock) PERSISTENT IN bookkeeping;
skipExplicitBatch 'Разрешить регистр без партии' = ABSTRACT BOOLEAN (SkuLedger);
CONSTRAINT explicitBatchLedger(stock(SkuLedger l)) AND isPosted(l) AND NOT batch(l) AND NOT skipExplicitBatch(l)
    MESSAGE 'Не выбрана партия для строки движения товара';
    
showPriceBatchLedger(Stock s) = isCompany(s) AND NOT explicitBatchLedger(s);   
dataPriceBatchLedger 'Использовать свои цены для каждой партии' = ABSTRACT BOOLEAN (Stock);
priceBatchLedger 'Использовать свои цены для каждой партии' (Stock s) = dataPriceBatchLedger(s) OR explicitBatchLedger(s) PERSISTENT;  

order (DataSkuLedger ledger) = STRUCT(dateTime(ledger), ledger);

// Свойства для расчета себестоимости
quantity 'Кол-во' (Batch ledger, Batch batch) = quantity(ledger) IF batch == ledger;

cost 'Расписано из партии (перв.)' (ledger, batch) = DATA NUMERIC[16,5] (DataSkuLedger, Batch);

cost 'Расписано из партии' (SkuLedger ledger, Batch batch) = MULTI quantity[Batch,Batch](ledger, batch),
                                                                 cost[DataSkuLedger,Batch](ledger, batch) PERSISTENT;

maxBatchCost 'Последняя партия, из которой расписано' (ledger) = GROUP MAX Batch batch IF  cost(SkuLedger ledger, batch) BY ledger;
countBatchCost 'Кол-во партий' (ledger) = GROUP SUM 1 IF cost(SkuLedger ledger, Batch batch) BY ledger;


signedCost (SkuLedger ledger, Batch batch) = IF ledger IS OutSkuLedger
                                              THEN -cost(ledger, batch)
                                              ELSE cost(ledger, batch);

// Расчет себестоимости по Action
costed 'Расписано' (ledger) = GROUP SUM cost (DataSkuLedger ledger, Batch batch) BY ledger PERSISTENT;
costed 'Расписано' (ledger) = GROUP SUM cost (SkuLedger ledger, Batch batch) BY ledger PERSISTENT;
notCosted 'Не расписано' (SkuLedger ledger) = quantity(ledger) (-) costed(ledger);
signedNotCosted 'Не расписано' (SkuLedger ledger) = IF ledger IS OutSkuLedger THEN
                                                                        quantity(ledger) (-) costed(ledger)
                                                                    ELSE
                                                                        costed(ledger) (-) quantity(ledger);

// Суммы

costSum 'Сумма поставщика без НДС' (SkuLedger ledger, Batch batch) = NUMERIC[16,3](cost(ledger, batch) * cost(batch));
costSum 'Сумма поставщика без НДС' = GROUP SUM costSum(SkuLedger ledger, Batch batch) BY ledger;

// ---------------------------- Учетные цены и суммы ------------------------------- //

// сумма операции
sum 'Сумма' (ledger) = ABSTRACT NUMERIC[16,2] (InSkuLedger) PERSISTENT;
sum 'Сумма' (ledger) = ABSTRACT NUMERIC[16,2] (OutSkuLedger) PERSISTENT;

sum 'Сумма' = MULTI sum[InSkuLedger](SkuLedger ledger),
                             sum[OutSkuLedger](ledger) PERSISTENT;
                              
signedSum 'Сумма' (SkuLedger ledger) = MULTI sum[InSkuLedger](ledger),
                                            -sum[OutSkuLedger](ledger) PERSISTENT;
                                            
signedPrice 'Цена' (SkuLedger ledger)= NUMERIC[14,2](signedSum(ledger) / signedQuantity(ledger));                                            

// ---------------------------- Остаток по товару -------------------------------- //

TABLE skuStock(Sku, Stock);
TABLE sessionSkuStock(Session, Sku, Stock);

TABLE extraSkuStock(Sku, Stock);
TABLE skuStockDate(Sku, Stock, DATE);
TABLE batchStockDate(Batch, Stock, DATE);

TABLE skuGroupStock(SkuGroup, Stock);
TABLE sessionSkuGroupStock (Session, SkuGroup, Stock);

TABLE skuStockGroup(Sku, StockGroup);

META defineSkuLedgerBalanceProperties(postfix, caption)
    skip 'Не проводить по учету'###caption = ABSTRACT BOOLEAN (SkuLedger) PERSISTENT;
    active 'Активен'###caption (SkuLedger ledger) = isPosted(ledger) AND NOT skip(ledger) PERSISTENT;

    signedQuantityActive(SkuLedger ledger) = signedQuantity(ledger) IF active(ledger) PERSISTENT;

    currentBalance 'Текущий остаток'###caption (sku, stock) =
        GROUP SUM signedQuantityActive(SkuLedger ledger) BY sku(ledger), stock(ledger) PERSISTENT;
    prevCurrentBalance 'Текущий остаток'###caption (Sku sku, Stock stock) = PREV(currentBalance(sku, stock));
    prevCurrentBalance 'Текущий остаток'###caption (sku) = GROUP SUM prevCurrentBalance(Sku sku, Stock stock) BY sku;
    countLedger 'Кол-во движений'###caption (sku, stock) =
        GROUP SUM 1 IF signedQuantityActive(SkuLedger ledger) BY sku(ledger), stock(ledger) PERSISTENT TABLE extraSkuStock;

    quantityInActive(InSkuLedger ledger) = quantity(ledger) IF isPosted(ledger) AND NOT skip(ledger) PERSISTENT;
    quantityIn (sku, stock, date) =
        GROUP SUM quantityInActive(InSkuLedger ledger) BY sku(ledger), stock(ledger), date(ledger) PERSISTENT;

    quantityOutActive(OutFIFOSkuLedger ledger) = quantityOut(ledger) IF isPosted[SkuLedger](ledger) AND NOT skip(ledger) PERSISTENT;
    quantityOut (sku, stock, date) =
        GROUP SUM quantityOutActive(OutFIFOSkuLedger ledger) BY sku[SkuLedger](ledger), stock[SkuLedger](ledger), date[SkuLedger](ledger) PERSISTENT;

    quantity (Sku sku, Stock stock, DATE date) = quantityIn(sku, stock, date)
                                                         (+)
                                                         quantityOut(sku, stock, date) PERSISTENT;

    signedQuantity (Sku sku, Stock stock, DATE date) = quantityIn(sku, stock, date)
                                                               (-)
                                                               quantityOut(sku, stock, date) PERSISTENT;

    quantitySumIn 'Кол-во товара пришедшего за период' (sku, stock, date1, date2) =
        GROUP SUM quantityIn(Sku sku, Stock stock, DATE dateIn) IF dateIn>=DATE date1 IF dateIn<=DATE date2
        BY sku, stock, date1, date2;
    quantitySumIn 'Кол-во товара пришедшего за период' (group, stock, date1, date2) =
        GROUP SUM quantitySumIn(Sku sku, Stock stock, DATE date1, DATE date2) IF isParent(Group group, sku)
        BY group, stock, date1, date2;

    quantitySumOut 'Кол-во товара ушедшего за период' (sku, stock, date1, date2) =
        GROUP SUM quantityOut(Sku sku, Stock stock, DATE dateIn) IF dateIn>=DATE date1 IF dateIn<=DATE date2
        BY sku, stock, date1, date2;
    quantitySumOut 'Кол-во товара ушедшего за период' (group, stock, date1, date2) =
        GROUP SUM quantitySumOut (Sku sku, Stock stock, DATE date1, DATE date2) IF isParent(Group group, sku)
        BY group, stock, date1, date2;

    // без учета текущей даты/времени
    balanceB 'Остаток на начало дня'###caption (Sku sku, Stock stock, DATE date) = currentBalance(sku, stock)
                                                                      (-) [= GROUP SUM signedQuantity (Sku sku, Stock stock, DATE dateIn) IF dateIn >= DATE date
                                                                                 BY sku, stock, date](sku, stock, date);

    // с учетом текущей даты/времени
    balanceA 'Остаток на конец дня'###caption (Sku sku, Stock stock, DATE date) = currentBalance(sku, stock)
                                                                     (-) [= GROUP SUM signedQuantity (Sku sku, Stock stock, DATE dateIn) IF dateIn > DATE date
                                                                                BY sku, stock, date](sku, stock, date);

    // без учета текущей даты/времени
    balanceB 'Остаток (до)'###caption (Sku sku, Stock stock, DATETIME dateTime) = currentBalance(sku, stock)
                                                                              (-) [= GROUP SUM signedQuantityActive(SkuLedger ledger) IF dateTime(ledger) >= DATETIME dateTime
                                                                                         BY sku(ledger), stock(ledger), dateTime](sku, stock, dateTime);
    prevBalanceB 'Остаток (до)'###caption (Sku sku, Stock stock, DATETIME dateTime) = PREV(balanceB(sku, stock, dateTime) IF dateTime IS DATETIME);

    // с учетом текущей даты/времени
    balanceA 'Остаток (после)'###caption (Sku sku, Stock stock, DATETIME dateTime) = currentBalance(sku, stock)
                                                                             (-) [= GROUP SUM signedQuantityActive(SkuLedger ledger) IF dateTime(ledger) > DATETIME dateTime
                                                                                        BY sku(ledger), stock(ledger), dateTime](sku, stock, dateTime);
    prevBalanceA 'Остаток (после)'###caption (Sku sku, Stock stock, DATETIME dateTime) = PREV(balanceA(sku, stock, dateTime) IF dateTime IS DATETIME);

    balanceA 'Остаток (после)'###caption (group,  stock, dateTime) =
        GROUP SUM balanceA (Sku sku, Stock stock, DATETIME dateTime) IF isParent(Group group, sku)
        BY group, stock(SkuLedger ledger), dateTime;
        
    balanceB 'Остаток на начало дня' (stock, date) = GROUP SUM balanceB(Sku sku, Stock stock, DATE date) BY stock, date;

    currentBalance 'Остаток (всего)'###caption (sku) = GROUP SUM currentBalance(Sku sku, Stock stock) BY sku;

    signedQuantityActive(SkuLedger ledger, Batch batch) = signedCost(ledger, batch) IF active(ledger) PERSISTENT;
    
    signedActiveCostSum 'Себестоимость' (SkuLedger ledger, Batch batch) = NUMERIC[16,3](signedQuantityActive(ledger, batch) * cost(batch));
    signedActiveCostSum 'Себестоимость' = GROUP SUM signedActiveCostSum(SkuLedger ledger, Batch batch) BY ledger;
    
    currentBalance 'Текущий остаток'###caption (batch, stock) = GROUP SUM signedQuantityActive(SkuLedger ledger, Batch batch)
                                                                                           BY batch, stock(ledger) PERSISTENT;
    skuCurrentBalance (Batch batch, Stock stock) = sku(batch) IF currentBalance(batch, stock) PERSISTENT;
    INDEX skuCurrentBalance(Batch batch, Stock stock), stock;
    prevCurrentBalance 'Текущий остаток'###caption (Batch batch, Stock stock) = PREV(currentBalance(batch, stock));
    prevCurrentBalance 'Текущий остаток'###caption (batch) = GROUP SUM prevCurrentBalance(Batch batch, Stock stock) BY batch;    

    countBatch 'Кол-во партий' (sku, stock) = GROUP SUM 1  IF currentBalance(Batch batch, Stock stock)
                                                                 BY sku(batch), stock;
    defaultBatch 'Партия по умолчанию' (sku, stock)= GROUP MIN Batch batch IF currentBalance(batch, Stock stock)
                                                                        BY sku(batch), stock;
    
    countPositiveBatch 'Кол-во партий' (sku, stock) = GROUP SUM 1  IF currentBalance(Batch batch, Stock stock) >0
                                                                 BY sku(batch), stock;
    defaultPositiveBatch 'Партия по умолчанию' (sku, stock)= GROUP MIN Batch batch IF currentBalance(batch, Stock stock) >0
                                                                        BY sku(batch), stock;

    TABLE extraBatchStock(Batch, Stock);
    countLedger 'Кол-во движений'###caption (batch, stock) =
        GROUP SUM 1 IF signedQuantityActive(SkuLedger ledger, Batch batch) BY batch, stock(ledger) PERSISTENT TABLE extraBatchStock;
    skuLedger (Batch batch, Stock stock) = sku(batch) IF countLedger(batch, stock) PERSISTENT TABLE extraBatchStock;
    INDEX skuLedger (Batch batch, Stock stock), stock;

    countLedger 'Кол-во движений за период'###caption (batch, stock, dateFrom, dateTo) =
        GROUP SUM 1 IF signedQuantityActive(SkuLedger ledger, Batch batch) AND date(ledger) >= DATE dateFrom AND date(ledger) <= DATE dateTo
        BY batch, stock(ledger), dateFrom, dateTo;
        
    lastOrderBatch(sku, stock)  =
        GROUP LAST Batch batch
              BY skuLedger(batch, Stock stock), stock
              ORDER order(batch) PERSISTENT TABLE extraSkuStock;
              
              
    lastOrderBatchA(sku, stock, date)  =
        GROUP LAST Batch batch
              BY skuLedger##postfix##BatchStock, stock, DATE dateIn
              ORDER order(batch)
              WHERE date(batch) <= dateIn;   
                         
    lastOrderBatchA(sku, stock, dateTimeIn)  =
        GROUP LAST Batch batch
              BY skuLedger(batch, Stock stock), stock, DATETIME dateTimeIn
              ORDER order(batch)
              WHERE dateTime(batch) <= dateTimeIn;   
               
    lastOrderBatchB(sku, stock, date)  =
        GROUP LAST Batch batch
              BY skuLedger(batch, Stock stock), stock, DATE dateIn
              ORDER order(batch)
              WHERE date(batch) < dateIn;   
                         
    lastOrderBatchB(sku, stock, dateTimeIn)  =
        GROUP LAST Batch batch
              BY skuLedger(batch, Stock stock), stock, DATETIME dateTimeIn
              ORDER order(batch)
              WHERE dateTime(batch) < dateTimeIn;                 
               
              
//    orderBatch##postfix##SkuStock (sku, stock) = GROUP MAX orderBatch(batch) IF countLedger##postfix##BatchStock(batch, stock)
//                                                       BY skuBatch(batch), stock PERSISTENT;
//    lastOrderBatch##postfix##SkuStock(sku, stock) = orderBatch##postfix##SkuStock(sku, stock)[2] PERSISTENT;
    prevLastOrderBatch(Sku sku, Stock stock) = PREV(lastOrderBatch(sku, stock));
    dateTimeLastOrderBatch 'Время последней партии' (Sku sku, Stock stock) = dateTime(lastOrderBatch(sku, stock));
    supplierLastOrderBatch (Sku sku, Stock stock) = supplier(lastOrderBatch(sku, stock));
    nameSupplierLastOrderBatch 'Поставщик последней партии' (Sku sku, Stock stock) = nameSupplier(lastOrderBatch(sku, stock));
    supplierStockLastOrderBatch (Sku sku, Stock stock) = supplierStock(lastOrderBatch(sku, stock));
    
    lastBatchManufactureDate 'Дата изготовления последней партии' (Sku sku, Stock stock) = manufactureDate(lastOrderBatch(sku, stock));
    lastBatchExpiryDate 'Срок годности последней партии' (Sku sku, Stock stock) = expiryDate(lastOrderBatch(sku, stock));

    batchLastManufactureDate (sku, stock)  =
        GROUP LAST manufactureDate(Batch batch)
              BY skuLedger(batch, Stock stock), stock
              ORDER order(batch)
              WHERE manufactureDate(batch) COMPLEX;
              
    batchLastExpiryDate (sku, stock)  =
        GROUP LAST expiryDate(Batch batch)
              BY skuLedger(batch, Stock stock), stock
              ORDER order(batch)
              WHERE expiryDate(batch) COMPLEX;    
    
    useFillBatchProperty 'Использовать последние: срок годности, дату и время изготовления' = DATA BOOLEAN ();
    EXTEND FORM options
        PROPERTIES() useFillBatchProperty
    ;
    DESIGN options {
        commons {
            MOVE PROPERTY(useFillBatchProperty());
        }
    }
    lastManufactureDate 'Дата изготовления' (Sku sku, Stock stock) = IF useFillBatchProperty() 
        THEN batchLastManufactureDate(sku, stock)
        ELSE manufactureDate(lastOrderBatch(sku, stock));
    lastExpiryDate 'Срок годности (дата)' (Sku sku, Stock stock) = IF useFillBatchProperty()
        THEN batchLastExpiryDate(sku, stock)
        ELSE expiryDate(lastOrderBatch(sku, stock));    
    
    lastOrderBatch (sku) = GROUP MAX lastOrderBatch(Sku sku, Stock stock) BY sku;

    supplierLastOrderBatch (Sku sku) = supplier(lastOrderBatch(sku));
    prevSupplierLastOrderBatch (Sku sku) = PREV(supplierLastOrderBatch (sku));

    nameSupplierLastOrderBatch 'Поставщик (поставка)' (Sku sku) = name(supplierLastOrderBatch(sku)); 

    currentBalance 'Остаток (всего)'###caption (batch) = GROUP SUM currentBalance(Batch batch, Stock stock) BY batch PERSISTENT;
    outcome 'Расходовано'###caption (Batch batch) = MAX shippedQuantity(batch) (-) currentBalance(batch), 0;

    balanceA 'Остаток (после)' (SkuLedger ledger) = balanceA(sku(ledger), stock(ledger), dateTime(ledger));
    balanceB 'Остаток (до)' (SkuLedger ledger) = balanceB(sku(ledger), stock(ledger), dateTime(ledger));
    // ---------------------------- Суммы по товару -------------------------------- //

    signedSumActive(SkuLedger ledger) = signedSum(ledger) IF isPosted(ledger) AND NOT skip(ledger) PERSISTENT;
    currentSum 'Сумма остатка'###caption (sku, stock) =
        GROUP SUM signedSumActive(SkuLedger ledger) BY sku(ledger), stock(ledger) PERSISTENT;
    //-- по дате
    sumInActive(InSkuLedger ledger) = sum(ledger) IF isPosted(ledger) AND NOT skip(ledger) PERSISTENT;
    sumIn (sku, stock, date) =
        GROUP SUM sumInActive(InSkuLedger ledger) BY sku(ledger), stock(ledger), date(ledger) PERSISTENT;

    sumOutActive(OutSkuLedger ledger)  = sum(ledger) IF isPosted(ledger) AND NOT skip(ledger) PERSISTENT;
    sumOut (sku, stock, date) =
        GROUP SUM sumOutActive(OutSkuLedger ledger) BY sku(ledger), stock(ledger), date(ledger) PERSISTENT;

    sum (Sku sku, Stock stock, DATE date) = sumIn(sku, stock, date)
                                                         (+)
                                                         sumOut(sku, stock, date) PERSISTENT;

    signedSum (Sku sku, Stock stock, DATE date) = sumIn(sku, stock, date)
                                                               (-)
                                                               sumOut(sku, stock, date) PERSISTENT;

    // без учета текущей даты/времени
    sumB 'Сумма на начало дня'###caption (Sku sku, Stock stock, DATE date) = currentSum(sku, stock)
                                                                      (-) [= GROUP SUM signedSum (Sku sku, Stock stock, DATE dateIn) IF dateIn >= DATE date
                                                                                 BY sku, stock, date](sku, stock, date);

    sumB 'Сумма на начало дня' (stock, date) = GROUP SUM sumB(Sku sku, Stock stock, DATE date) BY stock, date;

    sumBSku 'Сумма на начало дня (по группе)' (group, stock, date) =
        GROUP SUM sumB (Sku sku, Stock stock, DATE date)
        BY group(GroupType groupType, sku), stock, date;

    sumRecBSku 'Сумма на начало дня (всего)' (group, stock, date) =
        GROUP SUM sumB (Sku sku, Stock stock, DATE date) IF isParent(Group group, sku)
        BY group, stock, date;

    // с учетом текущей даты/времени
    sumA 'Сумма на конец дня'###caption (Sku sku, Stock stock, DATE date) = currentSum(sku, stock)
                                                                     (-) [= GROUP SUM signedSum (Sku sku, Stock stock, DATE dateIn) IF dateIn > DATE date
                                                                                BY sku, stock, date](sku, stock, date);

    sumASku 'Сумма на конец дня (по группе)' (group, stock, date) =
        GROUP SUM sumA (Sku sku, Stock stock, DATE date)
        BY group(GroupType groupType, sku), stock, date;

    sumRecASku 'Сумма на конец дня (всего)' (group, stock, date) =
        GROUP SUM sumA (Sku sku, Stock stock, DATE date) IF isParent(Group group, sku)
        BY group, stock, date;

    //-- по дате/время
    sumIn (sku, stock, dateTime) =
        GROUP SUM sumInActive(InSkuLedger ledger) BY sku(ledger), stock(ledger), dateTime(ledger);

    sumOut (sku, stock, dateTime) =
        GROUP SUM sumOutActive(OutSkuLedger ledger) BY sku(ledger), stock(ledger), dateTime(ledger);

    sum (Sku sku, Stock stock, DATETIME dateTime) = sumIn(sku, stock, dateTime)
                                                         (+)
                                                         sumOut(sku, stock, dateTime);

    signedSum (Sku sku, Stock stock, DATETIME dateTime) = sumIn(sku, stock, dateTime)
                                                               (-)
                                                               sumOut(sku, stock, dateTime);

    // без учета текущей даты/времени
    sumB 'Сумма (до)'###caption (Sku sku, Stock stock, DATETIME dateTime) = currentSum(sku, stock)
                                                                     (-) [= GROUP SUM signedSumActive(SkuLedger ledger) IF dateTime(ledger) >= DATETIME dateTime
                                                                                BY sku(ledger), stock(ledger), dateTime](sku, stock, dateTime);
    //-- использовать только при условии explicitBatchLedger для склада                                                                            
    sumB 'Сумма (до)'###caption (Batch batch, Stock stock, DATETIME dateTime) = GROUP SUM signedSumActive(SkuLedger ledger) IF dateTime(ledger) < DATETIME dateTime
                                                                                    BY batch(ledger), stock(ledger), dateTime;
                                                                                       
                                                                                       
    sumRecBSku 'Учетная сумма (всего)' (group, stock, dateTime) =
        GROUP SUM sumB (Sku sku, Stock stock, DATETIME dateTime) IF isParent(Group group, sku)
        BY group, stock, dateTime;
        
    // с учетом текущей даты/времени
    sumA 'Сумма (после)'###caption (Sku sku, Stock stock, DATETIME dateTime) = currentSum(sku, stock)
                                                                     (-) [= GROUP SUM signedSumActive(SkuLedger ledger) IF dateTime(ledger) > DATETIME dateTime
                                                                                BY sku(ledger), stock(ledger), dateTime](sku, stock, dateTime);

    sumA 'Сумма (после)' (SkuLedger ledger) = sumA(sku(ledger), stock(ledger), dateTime(ledger));
    sumB 'Сумма (до)' (SkuLedger ledger) = sumB(sku(ledger), stock(ledger), dateTime(ledger));

    priceA 'Цена (после)' (SkuLedger ledger) = sumA(ledger) / balanceA(ledger);
    priceB 'Цена (до)' (SkuLedger ledger) = sumB(ledger) / balanceB(ledger);
    
    // суммы для периодов
    sumIn 'Сумма товара пришедшего за период' (sku, stock, dateFrom, dateTo) =
        GROUP SUM sumIn(Sku sku, Stock stock, DATE dateIn) IF dateIn >= DATE dateFrom AND dateIn <= DATE dateTo
               BY sku, stock, dateFrom, dateTo;
    sumInSku 'Сумма товара пришедшего за период(по группе)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumIn (Sku sku, Stock stock, DATE dateFrom, DATE dateTo)
        BY group(GroupType groupType, sku), stock, dateFrom, dateTo;
    sumRecInSku 'Сумма товара пришедшего за период(всего)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumIn (Sku sku, Stock stock, DATE dateFrom, DATE dateTo) IF isParent(Group group, sku)
        BY group, stock, dateFrom, dateTo;

    sumOut 'Сумма товара ушедшего за период' (sku, stock, dateFrom, dateTo) =
        GROUP SUM sumOut(Sku sku, Stock stock, DATE dateOut) IF dateOut >= DATE dateFrom AND dateOut <= DATE dateTo
               BY sku, stock, dateFrom, dateTo;
    sumOutSku 'Сумма товара ушедшего за период(по группе)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumOut (Sku sku, Stock stock, DATE dateFrom, DATE dateTo)
        BY group(GroupType groupType, sku), stock, dateFrom, dateTo;
    sumRecOutSku 'Сумма товара ушедшего за период(всего)' (group, stock, dateFrom, dateTo) =
        GROUP SUM sumOut (Sku sku, Stock stock, DATE dateFrom, DATE dateTo) IF isParent(Group group, sku)
        BY group, stock, dateFrom, dateTo;

    averagePrice 'Цена (средневзв.)'###caption (Sku sku, Stock stock) = currentSum(sku, stock) / currentBalance(sku, stock); // IF NOT currentBalance##postfix##SkuStock(sku, stock) == 0; (возможно не нужно, так как 0 не может быть в GROUP SUM )
    averagePriceA 'Цена (средневзв.)'###caption (Sku sku, Stock stock, DATETIME dateTime) = sumA(sku, stock, dateTime) / balanceA(sku, stock, dateTime); // IF NOT currentBalance##postfix##SkuStock(sku, stock) == 0; (возможно не нужно, так как 0 не может быть в GROUP SUM )
    prevAveragePriceA 'Цена (средневзв.)'###caption (Sku sku, Stock stock, DATETIME dateTime) = PREV(averagePriceA(sku, stock, dateTime));
    averagePriceB 'Цена (средневзв.)'###caption (Sku sku, Stock stock, DATETIME dateTime) = sumB(sku, stock, dateTime) / balanceB(sku, stock, dateTime); // IF NOT currentBalance##postfix##SkuStock(sku, stock) == 0; (возможно не нужно, так как 0 не может быть в GROUP SUM )
    prevAveragePriceB 'Цена (средневзв.)'###caption (Sku sku, Stock stock, DATETIME dateTime) = PREV(averagePriceB(sku, stock, dateTime));
END

@defineSkuLedgerBalanceProperties(,);

banNegativeSku 'Запретить расходовать больше чем в остатке по товару' = DATA BOOLEAN ();

EXTEND FORM options 
    PROPERTIES() banNegativeSku 
;

DESIGN options {
    stock1 {
        MOVE PROPERTY(banNegativeSku());
    }
}

CONSTRAINT currentBalance(Sku sk, Stock st) < 0.0 AND banNegativeSku()
    MESSAGE 'Текущий остаток должен быть больше нуля';

allowedEdit (SkuLedger d) = NOT isClosed(d) OR allowedEditClosedDocuments(currentUser());
// -------------------------------------- Последнее движение ---------------------------------- //

dateTimeLastMoved 'Время последнего движения' (sku, stock) =
    GROUP MAX dateTime(SkuLedger ledger) IF active(ledger)
    BY sku(ledger), stock(ledger) PERSISTENT TABLE extraSkuStock;

dateTimeLastMoved 'Время последнего движения' (sku) =
    GROUP MAX dateTimeLastMoved(Sku sku, Stock stock)
    BY sku;

moved (Sku item, Stock departmentStore, DATETIME dateTime, LONG period) =
    dateTimeLastMoved(item, departmentStore) >= toDateTime(subtract(toDate(dateTime), period));

balance (Sku item, Stock departmentStore, DATETIME dateTime, LONG period) =
    moved (item, departmentStore, dateTime, period) OR balanceB(item, departmentStore, dateTime);

moved (Sku item, Stock departmentStore, DATE date, LONG period) =
    dateTimeLastMoved(item, departmentStore) >= toDateTime(subtract(date, period));

balance (Sku item, Stock departmentStore, DATE date, LONG period) =
    moved (item, departmentStore, date, period) OR balanceA(item, departmentStore, date);

//----------------------------------------- По партиям ---------------------------------------------//

signedQuantity = GROUP SUM signedCost (SkuLedger ledger, Batch batch) IF isPosted(ledger)
                                     BY batch, stock(ledger), date(ledger) PERSISTENT; 
                                     
quantity = GROUP SUM cost (SkuLedger ledger, Batch batch) IF isPosted(ledger)
                                     BY batch, stock(ledger), date(ledger) PERSISTENT;                                      

// без учета текущей даты/времени
balanceB 'Остаток на начало дня' (Batch batch, Stock stock, DATE date) = currentBalance(batch, stock)
    (-) [= GROUP SUM signedQuantity(Batch batch, Stock stock, DATE dateIn) IF dateIn >= DATE date
           BY batch, stock, date](batch, stock, date);

// с учетом текущей даты/времени
balanceA 'Остаток на конец дня' (Batch batch, Stock stock, DATE date) = currentBalance(batch, stock)
    (-) [= GROUP SUM signedQuantity(Batch batch, Stock stock, DATE dateIn) IF dateIn > DATE date
           BY batch, stock, date](batch, stock, date);

// без учета текущей даты/времени
balanceB 'Остаток (до)' (Batch batch, Stock stock, DATETIME dateTime) = currentBalance(batch, stock)
    (-) [= GROUP SUM signedQuantityActive (SkuLedger ledger, Batch batch) IF dateTime(ledger) >= DATETIME dateTime
    BY batch, stock(ledger), dateTime](batch, stock, dateTime);
prevBalanceB 'Остаток (до)' (Batch batch, Stock stock, DATETIME dateTime) = PREV(balanceB(batch,stock,dateTime));

// с учетом текущей даты/времени
balanceA 'Остаток (после)' (Batch batch, Stock stock, DATETIME dateTime) = currentBalance(batch, stock)
    (-) [= GROUP SUM signedQuantityActive (SkuLedger ledger, Batch batch) IF dateTime(ledger) > DATETIME dateTime
    BY batch, stock(ledger), dateTime](batch, stock, dateTime);

// Остатки по себестоимости
costB 'Себестоимость на начало дня' (Batch batch, Stock stock, DATE date) = balanceB(batch, stock, date) * cost(batch);
  
costA 'Себестоимость на конец дня' (Batch batch, Stock stock, DATE dateTo) = balanceA(batch, stock, dateTo) * cost(batch);          

// Итоги по складам
costB 'Себестоимость на начало дня' = GROUP SUM costB(Batch b, Stock s, DATE d) BY s, d;
costA 'Себестоимость на конец дня' = GROUP SUM costA(Batch b, Stock s, DATE d) BY s, d;

//---------------------------------------------- За период ------------------------------------------//

costInBalance 'Приход' (batch, stock, dateFrom, dateTo) = GROUP SUM cost (InSkuLedger ledger, Batch batch)
    IF ledger IS InSkuLedger AND isPosted(ledger)
    AND date(ledger) >= DATE dateFrom AND date(ledger)<= DATE dateTo
    BY batch, stock(ledger), dateFrom, dateTo;

costSumInBalance 'Сумма прихода' (Batch batch, Stock stock, DATE dateFrom, DATE dateTo) =
    cost(batch) * costInBalance(batch, stock, dateFrom, dateTo);

costOutBalance 'Расход' (batch, stock, dateFrom, dateTo) = GROUP SUM cost (OutSkuLedger ledger, Batch batch)
    IF ledger IS OutSkuLedger AND isPosted(ledger)
    AND date(ledger) >= DATE dateFrom AND date(ledger)<= DATE dateTo
    BY batch, stock(ledger), dateFrom, dateTo;

costSumOutBalance 'Сумма расхода' (Batch batch, Stock stock, DATE dateFrom, DATE dateTo) =
    cost(batch) * costOutBalance(batch, stock, dateFrom, dateTo);
    
//---------------------------------------------- Себестоимость ------------------------------------------//    
    
currentCostSum 'Текущая себестоимость' (sku, stock) =
    GROUP SUM signedActiveCostSum(SkuLedger ledger) BY sku(ledger), stock(ledger);
    
// без учета текущей даты/времени
costSumB 'Себестоимость на начало дня' (sku, stock, date) = GROUP SUM costB(Batch batch, Stock stock, DATE date) BY sku(batch), stock, date;

// с учетом текущей даты/времени
costSumA 'Себестоимость на конец дня' (sku, stock, date) = GROUP SUM costA(Batch batch, Stock stock, DATE date) BY sku(batch), stock, date; 

// ------------------------------------------------ Формы для партий ------------------------------ //
FORM batches 'Партии'

    TREE skuTree sk = SkuGroup PARENT parent
    PROPERTIES READONLY order(sk), skuTreeName = name(sk)
    ORDER BY order(sk), skuTreeName
    FILTERGROUP inactive FILTER 'Активные' active(sk) 'F5' DEFAULT

    OBJECTS           bt=Batch
    PROPERTIES(bt)    READONLY number, series, dateTime, nameSupplier, nameSku, id SHOWIF showIDs(), 
                               name, nameStock, shippedQuantity, cost, expiryDate, currentBalance
    PROPERTIES(bt)    edit SHOWIF allowedEdit(bt), show
    FILTERS           isParent(sk, bt)
    ORDER BY          dateTime(bt)

    FILTERGROUP filterBalance
        FILTER 'Партии пришедшие за последний 1 день' date(bt) >= subtract(currentDate(), 1) 'F10'
        FILTER 'Партии пришедшие за последние 7 дней' date(bt) >= subtract(currentDate(), 7) 'F9'
        FILTER 'Партии пришедшие за последние 30 дней' date(bt) >= subtract(currentDate(), 30) 'F8'

    FILTERGROUP filterExpiry
        FILTER 'Партии с истекшим сроком годности' expiryDate(bt) < currentDate() 'F7'
        FILTER 'Партии со сроком годности, истекающим через 1 день' expires(bt, currentDate(), 1) 'F6'
        FILTER 'Партии со сроком годности, истекающим через 7 дней' expires(bt, currentDate(), 7) 'F5'
        FILTER 'Партии со сроком годности, истекающим через 30 дней' expires(bt, currentDate(), 30) 'F4'

    DIALOG Batch OBJECT bt
;

DESIGN batches {
    main{
        preferredSize = (1024, 768);

        NEW topContainer {
            fill = 1;
            type = SPLITH;
            MOVE skuTree.tree.box { caption = 'Группы'; }
            MOVE bt.box { fill = 3; caption = 'Партии'; }
        }
        MOVE functions.box;
    }
}
@extendFormFilterAccessStock(Batch, bt, batches, stock, company);

FORM dialogBatch 'Партии'
    OBJECTS sk = Sku FIXED PANEL

    OBJECTS bt = Batch
    PROPERTIES (bt) READONLY number, series, dateTime, nameSupplier, nameStock,
                    nameSku, name, id SHOWIF showIDs(), shippedQuantity, cost, expiryDate
    FILTERS sku(bt) == sk

    ORDER BY dateTime(bt)
;

FORM dialogBatchStockOut 'Партии (расход)'
    OBJECTS st = Stock FIXED PANEL
    OBJECTS t = DATETIME FIXED PANEL
    OBJECTS sk = Sku FIXED PANEL

    OBJECTS bt = Batch
    PROPERTIES (bt) READONLY number, series, dateTime, nameSupplier, nameSku, id SHOWIF showIDs(), name, shippedQuantity, cost, expiryDate
    PROPERTIES  READONLY balanceB(bt, st, t)
    PROPERTIES  READONLY currentBalance(bt, st)
    FILTERS sku(bt) == sk
    ORDER BY dateTime(bt)
    
    FILTERGROUP ledger
        FILTER 'С движением по складу' skuLedger(bt, st) == sk 'F6' DEFAULT 
    
    FILTERGROUP batch
        FILTER 'Партии с остатком до операции' balanceB(bt, st, t) 'F11'
        FILTER 'Партии с положительным остатком' currentBalance(bt, st) > 0 'F9'
        FILTER 'Партии с остатком' skuCurrentBalance(bt, st) == sk 'F8' DEFAULT
;
DESIGN dialogBatchStockOut {
    main {
        PROPERTY (balanceB(bt,st,t)) {
            caption = 'Остаток до операции';
        }
    }
}

FORM dialogBatchStockIn 'Партии (приход)'
    OBJECTS st = Stock FIXED PANEL
    OBJECTS t = DATETIME FIXED PANEL
    OBJECTS sk = Sku FIXED PANEL

    OBJECTS bt = Batch
    PROPERTIES (bt) READONLY number, series, dateTime, nameSupplier, nameSku, id SHOWIF showIDs(), name, shippedQuantity, cost, expiryDate
    PROPERTIES  READONLY balanceB(bt, st, t)
    PROPERTIES  READONLY currentBalance(bt, st)
    FILTERS sku(bt) == sk
    ORDER BY dateTime(bt)
    
    FILTERGROUP ledger
        FILTER 'С движением по складу' skuLedger(bt, st) == sk 'F6' 
    
    FILTERGROUP batch
        FILTER 'Партии с остатком до операции' balanceB(bt, st, t) 'F11'
        FILTER 'Партии с положительным остатком' currentBalance(bt, st) > 0 'F9'
        FILTER 'Партии с остатком' skuCurrentBalance(bt, st) == sk 'F8'
;
DESIGN dialogBatchStockIn {
    main {
        PROPERTY (balanceB(bt,st,t)) {
            caption = 'Остаток до операции';
        }
    }
}

// ------------------------------------------------- Себестоимость --------------------------- //

// Расчет себестоимости

needToCost 'Требуется расчет себестоимости' (DataSkuLedger ledger) = quantity[SkuLedger](ledger) > 0 AND isPosted(ledger)
                                                                        AND NOT quantity[SkuLedger](ledger) == costed(ledger);

order = ABSTRACT LONG (InLIFOSkuLedger, Batch);
limitNew = IF InLIFOSkuLedger ledger IS InLIFOSkuLedger THEN (
                                                     IF batch(ledger) THEN
                                                        quantity(ledger) IF Batch batch == batch(ledger)
                                                     ELSE
                                                        outcome(batch) IF
                                                        skuLedger(batch, stock(ledger)) == sku(ledger));

quantity (InLIFOSkuLedger ledger, Batch batch) =
        PARTITION UNGROUP quantity
                  LIMIT STRICT limitNew(ledger, batch)
                  BY ledger
                  ORDER DESC order(ledger, batch), order(batch);

order = ABSTRACT LONG (OutFIFOSkuLedger, Batch);
limitNew = IF OutFIFOSkuLedger ledger IS OutFIFOSkuLedger THEN (
                                                     IF batch(ledger) THEN
                                                        quantity(ledger) IF Batch batch == batch(ledger)
                                                     ELSE
                                                        OVERRIDE 0.0 IF skuLedger(batch, stock(ledger)) == sku(ledger), (currentBalance(batch, stock(ledger)) IF skuCurrentBalance(batch, stock(ledger)) == sku(ledger)));

quantity (OutFIFOSkuLedger ledger, Batch batch) =
        PARTITION UNGROUP quantity
                  LIMIT STRICT limitNew(ledger, batch)
                  BY ledger
                  ORDER order(ledger, batch), order(batch);

quantity (DataSkuLedger ledger, Batch batch) = MULTI quantity[InLIFOSkuLedger,Batch](ledger, batch) (+) 0, // (+) 0 делается, чтобы все 0 стали NULL 
                                                   quantity[OutFIFOSkuLedger,Batch](ledger, batch);

resetCost 'Перерассчитать себестоимость'(DataSkuLedger ledger) = ACTION { //NEWSESSION AUTOAPPLY {
    ASSIGN cost(ledger, Batch batch) <- NULL;
    ASSIGN cost(ledger, Batch batch) <- quantity(ledger, batch);
}

// мгновенный расчет себестоимости
//WHEN SET(isPostedDataSkuLedger(ledger)) DO EXEC resetCostDataSkuLedger (ledger) ORDER orderDataSkuLedger(ledger);
changedCost 'Перерасчитывалась себестоимость' = DATA LOCAL BOOLEAN (DataSkuLedger);

changedSession = DATA LOCAL BOOLEAN (DataSkuLedger);
updateDataSkuLedgerBatchCost() = ACTION {
    cost(DataSkuLedger ledger, Batch batch) <- NULL WHERE changedSession(ledger);

    LOCAL ordered = INTEGER (DataSkuLedger);
    ordered(DataSkuLedger ledger) <- PARTITION SUM 1 IF changedSession(ledger) BY sku(ledger) ORDER order(ledger);

    FOR iterate(INTEGER i, 1, [= GROUP MAX ordered(DataSkuLedger ledger)]()) DO {
        LOCAL it = BOOLEAN (DataSkuLedger);
        it(DataSkuLedger ledger) <- ordered(ledger) == i; // чтобы определились классы
        changedCost(DataSkuLedger ledger) <- TRUE WHERE it(ledger);
        cost(DataSkuLedger ledger, Batch batch) <- quantity(ledger, batch) WHERE it(ledger);
    }
}

ON { // eventChangeLedger - так как внутрь рекурсивного события толь
    LOCAL eventChanged = BOOLEAN (DataSkuLedger); 
    ASSIGN eventChanged(DataSkuLedger ledger) <- SET(isPosted(ledger)) OR ((
                                  CHANGED(quantity(ledger))
                                  OR CHANGED(sku(ledger))
                                  OR CHANGED(batch(ledger))
                                  OR CHANGED(stock(ledger))
                                  OR CHANGED(changed(ledger)))
                                 AND isPosted(ledger));

    IF [= GROUP MAX eventChanged(DataSkuLedger ledger)]() THEN
        NEWSESSION NESTED eventChanged[DataSkuLedger] SINGLE {
            changedSession(DataSkuLedger ledger) <- eventChanged(ledger);
            updateDataSkuLedgerBatchCost();
        }
}

setDataSkuLedgerBatchCost 'Дорассчитать себестоимость'() = ACTION NEWSESSION {
    APPLY SINGLE { 
        changedSession(DataSkuLedger ledger) <- needToCost(ledger);
        updateDataSkuLedgerBatchCost();
    }
} CONFIRM;

resetDataSkuLedgerBatchCost 'Перерассчитать себестоимость'() = ACTION NEWSESSION {
    FORM dialogDate MODAL;
    IF formResult() == FormResult.ok THEN {

        FOR DATE d == chosenDate('d') DO {
            APPLY SINGLE { 
                changedSession(DataSkuLedger ledger) <- date[SkuLedger](ledger) >= d AND isPosted(ledger);
                updateDataSkuLedgerBatchCost();
            }
        }
    }
} CONFIRM;

clearDataSkuLedgerBatchCost 'Сбросить всю себестоимость'() = ACTION NEWSESSION {
    ASSIGN cost(DataSkuLedger ledger, Batch batch) <- NULL;
    apply();
} CONFIRM;

currentBalance 'Текущий остаток' (SkuLedger bil, Batch bt) = currentBalance(bt, stock(bil));
countLedger 'Кол-во движений' (SkuLedger bil, Batch bt) = countLedger(bt, stock(bil));

FORM costSkuLedger 'Себестоимость (операции)'
    OBJECTS bil = SkuLedger
    PROPERTIES(bil) READONLY dateTime, description, nameSku, nameStock,
                             quantity, costed, sum
    PROPERTIES(bil)          resetCost FORCE GRID
    PROPERTIES(bil)          edit SHOWIF allowedEdit(bil), show
    FILTERS active(bil)
    ORDER BY dateTime(bil)

    FILTERGROUP needToCostDataSkuLedger
        FILTER 'Нерасписанные строки' needToCost(bil) 'F9'

    OBJECTS bt = Batch
    PROPERTIES(bt) READONLY number, series, dateTime, nameSupplier, name, shippedQuantity, cost, currentBalance
    PROPERTIES(bil, bt)  FORCE GRID cost, currentBalance, countLedger
    FILTERS sku(bt) == sku(bil)
    ORDER BY dateTime(bt) DESC

    FILTERGROUP inSkuLedgerBatch
        FILTER 'Только расписанные партии' cost (bil, bt) 'F10' DEFAULT

    FILTERGROUP currentBalance
        FILTER 'Только партии с остатком на складе' currentBalance (bil, bt) 'F11'

    PROPERTIES() setDataSkuLedgerBatchCost, resetDataSkuLedgerBatchCost, clearDataSkuLedgerBatchCost
;

DESIGN costSkuLedger {
    NEW topContainer{
        fill = 1;
        type = SPLITV;

        MOVE bil.box;
        MOVE bt.box;
    }

    NEW buttonContainer {
        type = CONTAINERH;
        MOVE PROPERTY(setDataSkuLedgerBatchCost());
        MOVE PROPERTY(resetDataSkuLedgerBatchCost());
        MOVE PROPERTY(clearDataSkuLedgerBatchCost());
    }

    MOVE functions.box;
}
@extendFormFilterAccessStock(SkuLedger, bil, costSkuLedger, stock, company);

FORM costSkuBatchLedger 'Себестоимость (партии)'
    OBJECTS i = Sku FIXED PANEL
    PROPERTIES(i) SELECTOR name//, idBarcodeSku

    OBJECTS bt = Batch
    PROPERTIES(bt) READONLY number, series, dateTime, nameSupplier, name, shippedQuantity, cost, currentBalance

    OBJECTS bil = SkuLedger
    PROPERTIES(bil) READONLY dateTime, description, nameStock,
                             quantity, costed
//    PROPERTIES(bil)          resetCostSkuLedger
    ORDER BY dateTime(bil)

    FILTERGROUP needToCostSkuLedger
        FILTER 'Нерасписанные строки' needToCost(bil) 'F9'


    PROPERTIES(bil, bt)     READONLY cost FORCE GRID
    FILTERS sku(bt) == i,
            sku(bil) == i

    ORDER BY dateTime(bt) DESC

    FILTERGROUP inSkuLedgerBatch
        FILTER 'Только расписанные партии' cost (bil, bt) 'F10' DEFAULT
;

DESIGN costSkuBatchLedger {
    NEW topContainer {
        fill = 1;
        type = SPLITV;

        MOVE bt.box;
        MOVE bil.box;
    }
    MOVE functions.box;
}

// ------------------------------------------------ Остатки по товарам ---------------------------------------- //

select 'Отм.' = DATA LOCAL NESTED BOOLEAN (Sku);
resetAllSelectedSku 'Сбросить для всех'() = ACTION {
    select(Sku sku) <- NULL WHERE select(sku);
} SHORTCUT select[Sku];

select 'Отм.' = DATA LOCAL NESTED BOOLEAN (Sku, Stock);
resetAllSelectedSkuStock 'Сбросить для всех'() = ACTION {
    select(Sku sku, Stock stock) <- NULL WHERE select(sku, stock);
} SHORTCUT select[Sku,Stock];

countSelectSkus 'Отм.' = GROUP SUM 1 IF select(Sku sku) MINCHARWIDTH 3 PREFCHARWIDTH 3 TOOLBAR ;
countSelectSkuStocks 'Отм.' = GROUP SUM 1 IF select(Sku sku, Stock stock) MINCHARWIDTH 3 PREFCHARWIDTH 3 TOOLBAR;

multipleStores 'Несколько складов' = DATA LOCAL BOOLEAN ();
singleStore = NOT multipleStores();

// Пока вот так, так иначе будет циклическая зависимость, а Extend'ить ON SHORTCUT нельзя
showBalanceMovementSku 'Показать движение товара по складу' (sku, stock) = ACTION ABSTRACT (Sku, Stock);
showBalancePriceSku 'Показать изменение цены товара по складу' (sku, stock) = ACTION ABSTRACT (Sku, Stock);
showBalanceReserveSku 'Показать резерв товара по складу' (sku, stock) = ACTION ABSTRACT (Sku, Stock);

backgroundBalance  = ABSTRACT CASE COLOR (Sku, Stock);
backgroundBalance  = ABSTRACT CASE COLOR (Sku, Stock, DATETIME);

FORM currentBalanceSkuStock 'Текущие остатки'
    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) name SELECTOR SHOWIF singleStore()
    FILTERS isCompany(ss)
    
    TREE stockTree a = STRING[3], sg = StockGroup PARENT parent, ts = Stock
    PROPERTIES SHOWIF multipleStores() READONLY OBJVALUE(a), sgTreeName = name(sg), tsTreeName = name(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroup(ts) == sg,
            isCompany(ts)
    FILTERGROUP tsinactiveStock FILTER 'Активный' active(ts) 'ctrl F10' DEFAULT
    
    TREE skuTree sk = SkuGroup PARENT parent
    PROPERTIES READONLY order(sk), skuTreeName = name(sk)
    ORDER BY order(sk), skuTreeName
    FILTERGROUP inactive FILTER 'Активные' active(sk) 'F5' DEFAULT

    OBJECTS           sts=(st=Stock, s=Sku)
    PROPERTIES        select(s,st)
    PROPERTIES        BACKGROUND backgroundBalance(s,st) READONLY name(s) ON SHORTCUT showBalanceMovementSku(s, st) ON SHORTCUT showBalancePriceSku(s, st) ON SHORTCUT showBalanceReserveSku(s,st), id(s) SHOWIF showIDs(), nameCountry(s), 
                      stockName = name(st) SHOWIF multipleStores(), nameUOM(s)  //  idBarcodeSku
    FILTERS           isParent(sk, s),
                      IF multipleStores() THEN 
                        st == ts AND sg IS StockGroup OR isParent(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                      ELSE 
                        st == ss,
                      isCompany(st) OR NOT multipleStores()
    ORDER BY          name(s)
    FILTERGROUP inactiveStock 
        FILTER 'Активный' (active(st) OR NOT multipleStores()) AND active(s) 'ctrl F10' DEFAULT
        FILTER 'Неактивный' inactive(s) 'shift F10'
    FILTERGROUP container 
        FILTER 'Товар' isItem(s) 
        FILTER 'Тара' isContainer(s)
        
    PROPERTIES(s, st) READONLY currentBalance, averagePrice, currentSum, dateTimeLastMoved, nameSupplierLastOrderBatch
    PROPERTIES(s)     READONLY idSkuGroup, canonicalNameSkuGroup    
    PROPERTIES() READONLY countSelectSkuStocks SHOWIF countSelectSkuStocks() TODRAW sts 
    FILTERGROUP filters
        FILTER 'Товары с остатком' currentBalance(s, st) OR currentSum(s, st) 'F10' DEFAULT
        FILTER 'Товары с движением не позднее 1 дня' balance(s, st, currentDate(), 1) 'F9'
        FILTER 'Товары с движением не позднее 7 дней' balance(s, st, currentDate(), 7) 'F8'
        FILTER 'Товары с движением не позднее 30 дней' balance(s, st, currentDate(), 30) 'F7'

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTime, description, nameBatch,
                    signedQuantity, signedPrice, signedSum, skip
                    
    FILTERS isPosted(bil) AND sku(bil)==s AND stock(bil)==st
    ORDER BY dateTime(bil) DESC

    OBJECTS bt=Batch
    PROPERTIES(bt) READONLY      number, series, dateTime, nameSupplier, name, id, shippedQuantity, cost, expiryDate
    PROPERTIES(bt, st) READONLY  currentBalance
    FILTERS isPosted(bt) AND sku(bt)==s
    ORDER BY dateTime(bt) DESC
;

DESIGN currentBalanceSkuStock {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            MOVE PROPERTY (multipleStores());
            MOVE PROPERTY (name(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;

            NEW firstBottom {
                fill = 1;
                type = SPLITV;
                MOVE stockTree.tree.box { caption = 'Склады'; }
                MOVE skuTree.tree.box { caption = 'Группы'; }
            }

            NEW secondCase {
                fill = 3;
                type = SPLITV;
                NEW sku.box {
                    fill = 2;
                    MOVE sts.box {
                        fill = 2;
                    }
                }
                NEW ledger.box {
                    fill = 1;
                    caption = 'Изменение цен';
                    type = TABBED;
                    MOVE bil.box;
                    MOVE bt.box;
                    NEW actionContainer {
                        caption = 'Действия';
                        type = CONTAINERH;
                    }
                }
            }
        }

        MOVE functions.box;
    }
}
@extendFormFilterStockGroupAccess(sg, currentBalanceSkuStock);
EXTEND FORM currentBalanceSkuStock FILTERS accessCompany(currentUser(), st) OR NOT multipleStores();

@extendFormFilterStockAccess(ss, currentBalanceSkuStock);

@extendFormFilterStockAccess(ts, currentBalanceSkuStock);

//resetSelectedSkuStock 'Сбросить для текущих' = ACTION () {
//    FOR [= FILTER currentBalanceSkuStock.sts](st,s) DO {
//        selectSkuStock(s, st) <- NULL WHERE selectSkuStock(s, st);
//    }
//} SHORTCUT selectSkuStock;

FORM balanceSkuStock 'Остатки на дату'

    OBJECTS t=DATETIME FIXED PANEL
    PROPERTIES valT = OBJVALUE(t)

    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) name SELECTOR SHOWIF singleStore()
    FILTERS isCompany(ss)    

    TREE stockTree a = STRING[3], sg = StockGroup PARENT parent, ts = Stock
    PROPERTIES READONLY SHOWIF multipleStores() OBJVALUE(a), sgTreeName = name(sg), tsTreeName = name(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroup(ts) == sg,
            isCompany(ts)
    FILTERGROUP sginactiveStock FILTER 'Активный' active(ts) 'ctrl F10' DEFAULT
    TREE skuTree sk = SkuGroup PARENT parent
    PROPERTIES READONLY order(sk), skuTreeName = name(sk)
    ORDER BY order(sk), skuTreeName
    FILTERGROUP inactive FILTER 'Активные' active(sk) 'F5' DEFAULT

    OBJECTS           sts=(st=Stock, s=Sku)
    PROPERTIES        READONLY BACKGROUND backgroundBalance(s,st,t) name(s) ON SHORTCUT showBalanceMovementSku(s, st) ON SHORTCUT showBalancePriceSku(s, st) ON SHORTCUT showBalanceReserveSku(s,st), id(s) SHOWIF showIDs(), nameCountry(s), stockName = name(st) SHOWIF multipleStores(), nameUOM(s)  //  idBarcodeSku
    FILTERS           isParent(sk, s),
                      IF multipleStores() THEN 
                          st == ts AND sg IS StockGroup OR isParent(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                        ELSE 
                            st == ss,
                      isCompany(st) OR NOT multipleStores()

    FILTERGROUP inactiveStock FILTER 'Активный' active(st) OR NOT multipleStores() 'ctrl F10' DEFAULT

    PROPERTIES(s, st, t) READONLY balanceB, averagePriceB, sumB
    PROPERTIES(s, st) READONLY dateTimeLastMoved
    
    FILTERGROUP container 
        FILTER 'Товар' isItem(s) 
        FILTER 'Тара' isContainer(s)
        
    FILTERGROUP filters
        FILTER 'Товары с остатком' balanceB(s, st, t) OR sumB(s, st, t) 'F10' DEFAULT
        FILTER 'Товары с движением не позднее 1 дня' balance(s, st, t, 1) 'F9'
        FILTER 'Товары с движением не позднее 7 дней' balance(s, st, t, 7) 'F8'
        FILTER 'Товары с движением не позднее 30 дней' balance(s, st, t, 30) 'F7'

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTime, description, nameBatch,
                    signedQuantity, signedPrice, signedSum
    FILTERS isPosted(bil) AND sku(bil)==s AND stock(bil)==st
    ORDER BY dateTime(bil) DESC

    OBJECTS bt=Batch
    PROPERTIES(bt) READONLY      number, series, dateTime, nameSupplier, name, id, shippedQuantity, cost
    PROPERTIES(bt, st, t) READONLY  balanceB
    FILTERS isPosted(bt) AND sku(bt)==s
    ORDER BY dateTime(bt) DESC
;

DESIGN balanceSkuStock {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            MOVE PROPERTY (valT);
            MOVE PROPERTY (multipleStores());
            MOVE PROPERTY (name(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;
            
            NEW firstCaseTwo {
                fill = 1;
                type = SPLITV;
                MOVE stockTree.tree.box { caption = 'Склады'; }
                MOVE skuTree.tree.box { caption = 'Группы'; }
            }

            NEW secondCase {
                fill = 3;
                type = SPLITV;
                NEW sku.box {
                    fill = 2;
                    MOVE sts.box {
                        fill = 2;
                    }
                }
                NEW ledger.box {
                    fill = 1;
                    caption = 'Изменение цен';
                    type = TABBED;
                    MOVE bil.box;
                    MOVE bt.box;
                }
            }
        }
        MOVE functions.box;
    }
}
@extendFormFilterStockGroupAccess(sg, balanceSkuStock);
EXTEND FORM balanceSkuStock FILTERS accessCompany(currentUser(), st) OR NOT multipleStores();

@extendFormFilterStockAccess(ss, balanceSkuStock);

@extendFormFilterStockAccess(ts, balanceSkuStock);

// ------------------------------------------------ Остатки по партиям ---------------------------------------- //

FORM currentBalanceBatchStock 'Текущие остатки по партиям'

    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) name SELECTOR SHOWIF singleStore()
    FILTERS isCompany(ss)   

    TREE stockTree a = STRING[3], sg = StockGroup PARENT parent, ts = Stock
    PROPERTIES READONLY SHOWIF multipleStores() OBJVALUE(a), sgTreeName = name(sg), tsTreeName = name(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroup(ts) == sg,
            isCompany(ts)
    FILTERGROUP sginactiveStock FILTER 'Активный' active(ts) 'ctrl F10' DEFAULT
    TREE skuTree sk = SkuGroup PARENT parent
    PROPERTIES READONLY order(sk), skuTreeName = name(sk)
    ORDER BY order(sk), skuTreeName
    FILTERGROUP inactive FILTER 'Активные' active(sk) 'F5' DEFAULT
       
    OBJECTS           stb=(st=Stock, bt=Batch)
    PROPERTIES        READONLY nameSku(bt), stockName = name(st) SHOWIF multipleStores(), documentNameSku(bt) SHOWIF useDocumentNameSku()
    PROPERTIES        READONLY currentBalance(bt, st)
    PROPERTIES(bt)    READONLY number, series, dateTime, nameSupplier, name, id, shippedQuantity, cost, expiryDate
    FILTERS           isParent(sk, bt),
                      IF multipleStores() THEN 
                          st == ts AND sg IS StockGroup OR isParent(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                        ELSE 
                            st == ss,    
//                      st == ts AND sg IS StockGroup OR isParentStockGroupStock(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts,
                      isCompany(st) OR NOT multipleStores()
    FILTERGROUP inactiveStock FILTER 'Активный' active(st) OR NOT multipleStores() 'ctrl F10' DEFAULT
    ORDER BY          dateTime(bt)

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTime, description,
                    signedQuantity, signedPrice, signedSum, skip
    PROPERTIES      READONLY cost(bil, bt) AFTER signedQuantity(bil)
    FILTERS isPosted(bil) AND (cost(bil, bt) OR batch(bil)==bt) AND stock(bil)==st   //skuSkuLedger(bil)==skuBatch(bt)
    ORDER BY dateTime(bil) DESC
    FILTERGROUP container 
        FILTER 'Товар' isItem(bt) 
        FILTER 'Тара' isContainer(bt)
    
    FILTERGROUP filterBalance
        FILTER 'Партии с остатком' currentBalance(bt, st) 'F11' DEFAULT
        FILTER 'Партии с движением по складу' countLedger(bt, st) 'F3'
        FILTER 'Партии пришедшие за последний 1 день' date(bt) >= subtract(currentDate(), 1) 'F10'
        FILTER 'Партии пришедшие за последние 7 дней' date(bt) >= subtract(currentDate(), 7) 'F9'
        FILTER 'Партии пришедшие за последние 30 дней' date(bt) >= subtract(currentDate(), 30) 'F8'

    FILTERGROUP filterExpiry
        FILTER 'Партии с истекшим сроком годности' expiryDate(bt) < currentDate() 'F7'
        FILTER 'Партии со сроком годности, истекающим через 1 день' expires(bt, currentDate(), 1) 'F6'
        FILTER 'Партии со сроком годности, истекающим через 7 дней' expires(bt, currentDate(), 7) 'F5'
        FILTER 'Партии со сроком годности, истекающим через 30 дней' expires(bt, currentDate(), 30) 'F4'
;

DESIGN currentBalanceBatchStock {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            MOVE PROPERTY (multipleStores());
            MOVE PROPERTY (name(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;

            NEW firstCase {
                fill = 1;
                type = SPLITV;
                MOVE stockTree.tree.box { caption = 'Склады'; }
                MOVE skuTree.tree.box { caption = 'Группы'; }
            }
            NEW secondCase {
                fill = 3;
                type = SPLITV;
                NEW sku.box {
                    fill = 2;
                    MOVE stb.box {
                        caption = 'Партии';
                        fill = 2;
                    }
                }
                NEW ledger.box {
                    fill = 1;
                    type = TABBED;
                    MOVE bil.box {caption = 'Движение';}
                }
             }            
            
        }

        MOVE functions.box;
    }
}
@extendFormFilterStockGroupAccess(sg, currentBalanceBatchStock);
EXTEND FORM currentBalanceBatchStock FILTERS accessCompany(currentUser(), st) OR NOT multipleStores();

@extendFormFilterStockAccess(ss, currentBalanceBatchStock);

@extendFormFilterStockAccess(ts, currentBalanceBatchStock);

FORM balanceBatchStock 'Остатки по партиям на дату'

    OBJECTS t=DATETIME FIXED PANEL
    PROPERTIES   valT = OBJVALUE(t)
    
    PROPERTIES() multipleStores
    
    OBJECTS ss = Stock FIXED PANEL
    PROPERTIES(ss) name SELECTOR SHOWIF singleStore()
    FILTERS isCompany(ss)  
    
    TREE stockTree a = STRING[3], sg = StockGroup PARENT parent, ts = Stock
    PROPERTIES READONLY SHOWIF multipleStores() OBJVALUE(a), sgTreeName = name(sg), tsTreeName = name(ts)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a),
            stockGroup(ts) == sg,
            isCompany(ts)
    FILTERGROUP sginactiveStock FILTER 'Активный' active(ts) 'ctrl F10' DEFAULT
    TREE skuTree sk = SkuGroup PARENT parent
    PROPERTIES READONLY order(sk), skuTreeName = name(sk)
    ORDER BY order(sk), skuTreeName
    FILTERGROUP inactive FILTER 'Активные' active(sk) 'F5' DEFAULT

    OBJECTS           stb=(st=Stock, bt=Batch)
    PROPERTIES        READONLY stockName = name(st) SHOWIF multipleStores(), nameSku(bt)
    PROPERTIES        READONLY  balanceB(bt, st, t)
    PROPERTIES(bt)    READONLY number, series, dateTime, nameSupplier, name, id, shippedQuantity, cost, expiryDate
    FILTERS           isParent(sk, bt),
                      IF multipleStores() THEN 
                          st == ts AND sg IS StockGroup OR isParent(sg, st) AND NOT ts OR st IS Stock AND NOT sg AND NOT ts
                        ELSE 
                            st == ss,    
                      isCompany(st) OR NOT multipleStores()
    FILTERGROUP inactiveStock FILTER 'Активный' active(st) OR NOT multipleStores() 'ctrl F10' DEFAULT
    ORDER BY          dateTime(bt)

    OBJECTS bil=SkuLedger
    PROPERTIES(bil) READONLY dateTime, description,
                    signedQuantity, signedPrice, signedSum, skip
    PROPERTIES      READONLY cost(bil, bt) AFTER signedQuantity(bil)
    FILTERS isPosted(bil) AND (cost(bil, bt) OR batch(bil)==bt) AND stock(bil)==st,
            dateTime(bil) < t
    ORDER BY dateTime(bil) DESC
    FILTERGROUP container 
        FILTER 'Товар' isItem(bt) 
        FILTER 'Тара' isContainer(bt)
        
    FILTERGROUP filterBalance
        FILTER 'Партии с остатком' balanceB(bt, st, t) 'F11' DEFAULT
        FILTER 'Партии с движением по складу' countLedger(bt, st) 'F3'
        FILTER 'Партии пришедшие за последний 1 день' dateTime(bt) >= subtractSeconds(currentDateTime(), 1) 'F10'
        FILTER 'Партии пришедшие за последние 7 дней' dateTime(bt) >= subtractSeconds(currentDateTime(), 7) 'F9'
        FILTER 'Партии пришедшие за последние 30 дней' dateTime(bt) >= subtractSeconds(currentDateTime(), 30) 'F8'

    FILTERGROUP filterExpiry
        FILTER 'Партии с истекшим сроком годности' expiryDate(bt) < toDate(t) 'F7'
        FILTER 'Партии со сроком годности, истекающим через 1 день' expires(bt, t, 1) 'F6'
        FILTER 'Партии со сроком годности, истекающим через 7 дней' expires(bt, t, 7) 'F5'
        FILTER 'Партии со сроком годности, истекающим через 30 дней' expires(bt, t, 30) 'F4'
;

DESIGN balanceBatchStock {
    main{
        preferredSize = (1024, 768);
        NEW filter {
            type = CONTAINERH;
            MOVE PROPERTY (valT);
            MOVE PROPERTY (multipleStores());
            MOVE PROPERTY (name(ss));
        }
        NEW topContainer {
            fill = 1;
            type = SPLITH;
            
            NEW firstCaseTwo {
                fill = 1;
                type = SPLITV;
                MOVE stockTree.tree.box { caption = 'Склады'; }
                MOVE skuTree.tree.box { caption = 'Группы'; }
            }
            NEW secondCase {
                fill = 3;
                type = SPLITV;
                NEW sku.box {
                    fill = 2;
                    MOVE stb.box {
                        caption = 'Партии';
                        fill = 2;
                    }
                }

                NEW ledger.box {
                    fill = 1;
                    type = TABBED;
                    MOVE bil.box {caption = 'Движение';}

                }
            }            
            
            
        }

        MOVE functions.box;
    }
}
@extendFormFilterStockGroupAccess(sg, balanceBatchStock);

EXTEND FORM balanceBatchStock FILTERS accessCompany(currentUser(), st) OR NOT multipleStores();

@extendFormFilterStockAccess(ss, balanceBatchStock);

@extendFormFilterStockAccess(ts, balanceBatchStock);

FORM skuLedger 'Регистр движений'

    OBJECTS dates = (dFrom = DATE, dTo = DATE) FIXED PANEL
    PROPERTIES valFrom = OBJVALUE(dFrom), valTo = OBJVALUE(dTo)

    OBJECTS s = SkuLedger
    PROPERTIES(s) READONLY date, dateTime, canonicalNameSkuGroup, nameSku, description, nameStock,
                           signedQuantity, signedPrice, signedSum, costSum
    PROPERTIES(s) edit SHOWIF allowedEdit(s), show
    FILTERS isPosted(s)

    FILTERS date(s) >= dFrom, date(s) <= dTo
    
    FILTERGROUP container 
        FILTER 'Товар' isItem(s) 
        FILTER 'Тара' isContainer(s)    
;

DESIGN skuLedger {
    MOVE dates.box {
        type = CONTAINERH;
    }
    MOVE s.box {
        type = CONTAINERV;
    }
    MOVE functions.box;
}

NAVIGATOR {
    stockNavigator {
        NEW balanceSku 'Остатки по товару' BEFORE stockReports {
            ADD currentBalanceSkuStock;
            ADD balanceSkuStock;
        }
        NEW balanceBatch 'Остатки по партиям' BEFORE stockReports {
            ADD currentBalanceBatchStock;
            ADD balanceBatchStock;
            ADD batches;
        }
        NEW stockCost 'Себестоимость' BEFORE stockReports {
            ADD costSkuLedger;
            ADD costSkuBatchLedger;
        }
        stockReports{
            ADD skuLedger;
        }
    }
}

// ----------------------------------------------------------------------------- //

skuGroup1 'Категория' (Batch batch) = skuGroup1(sku(batch));
nameSkuGroup1 'Категория' (Batch batch) = name(skuGroup1(batch));
 
skuGroup2 'Направление' (Batch batch) = skuGroup2(sku(batch));
nameSkuGroup2 'Направление' (Batch batch) = name(skuGroup2(batch));

skuGroup3 'Группа' (Batch batch) = skuGroup3(sku(batch));
nameSkuGroup3 'Группа' (Batch batch) = name(skuGroup3(batch));

skuGroup4 'Подгруппа' (Batch batch) = skuGroup4(sku(batch));
nameSkuGroup4 'Подгруппа' (Batch batch) = name(skuGroup4(batch));

skuGroup5 'Субгруппа' (Batch batch) = skuGroup5(sku(batch));
nameSkuGroup5 'Субгруппа' (Batch batch) = name(skuGroup5(batch));

// ---------------------------------------------- Макросы ------------------------------------------------ //

META implementSkuLedger(object, skuProp, stockProp)
    dateTime[Data###skuProp##Ledger] (###object ledger) += dateTime(ledger);
    isPosted[Data###skuProp##Ledger] (###object ledger) += isPosted(ledger);
    isClosed[Data###skuProp##Ledger] (###object ledger) += isClosed(ledger);
    skuProp[Data###skuProp##Ledger] (###object ledger) += skuProp(ledger);
    stock[Data###skuProp##Ledger] (###object ledger) += stockProp(ledger);
    description[Data###skuProp##Ledger] (###object ledger) += description(ledger);
END

META defineSkuLedgerAggregation(primObject, aggrObject, skuProp, stockProp)
    dateTime (###aggrObject batch) = dateTime(primObject(batch));
    isPosted (###aggrObject batch) = isPosted(primObject(batch));
    isClosed (###aggrObject batch) = isClosed(primObject(batch));
    skuProp (###aggrObject batch) = skuProp(primObject(batch));
    stock (###aggrObject batch) = stockProp(primObject(batch));
    description (###aggrObject batch) = description(primObject(batch));
END

META implementSkuLedgerInLIFO(object, skuProp, stockProp)
    EXTEND CLASS object : InLIFOSkuLedger;
    @implementSkuLedger(object, skuProp, stockProp);
END

META implementSkuLedgerInLIFOBatchBalancePostfix (object, stockProp, postfix)
    changed(###object ledger) += CHANGED(batch(ledger));
END

META implementSkuLedgerInLIFOBatchBalance (object, stockProp)
    @implementSkuLedgerInLIFOBatchBalancePostfix(object, stockProp, );
END

META implementSkuLedgerOutFIFO(object, skuProp, stockProp)
    EXTEND CLASS object : OutFIFOSkuLedger;
    @implementSkuLedger(object, skuProp, stockProp);
END

META implementSkuLedgerOutFIFOBatchBalancePostfix (object, stockProp, postfix)
    changed(###object ledger) += CHANGED(batch(ledger));
END

META implementSkuLedgerOutFIFOBatchBalance (object, stockProp)
    @implementSkuLedgerOutFIFOBatchBalancePostfix(object, stockProp, );
END

META implementBatchCustom(object, skuProp, stockProp, costProp)
    dateTime[Batch] (object batch) += dateTime(batch);
    isPosted[Batch] (object batch) += isPosted(batch);
    isClosed[Batch] (object batch) += isClosed(batch);
    skuProp[Batch] (object batch) += skuProp(batch);
    stockProp[Batch] (object batch) += stockProp(batch);
    description[Batch] (object batch) += description(batch);
    cost[Batch] (object batch) += costProp(batch);
END //-- (не забывать имплементить nameBatch)

META implementBatch(object, skuProp, stockProp, costProp)
    EXTEND CLASS object : Batch;
    @implementBatchCustom(object, skuProp, stockProp, costProp);
END

META defineConstraintSkuLedgerCosted (concrete, caption)
    CONSTRAINT (SET(changedCostDataSkuLedger(detail)) OR CHANGED(costedDataSkuLedger(detail))) AND isPosted###concrete##Detail(detail) AND NOT quantity###concrete##Detail(detail) == costedDataSkuLedger(detail)
        MESSAGE caption;
END

//-------------------------------------------------- Добавление партий в документ --------------------------------------//

META defineDocumentDetailBatchCustomPrefix(detail, batchProp, prefix)
    @defineDocumentDetailBatchCustomPrefixInner(detail, batchProp, ###batchProp, prefix);
END

META defineDocumentDetailBatchCustomPrefixInner(detail, batchProp, batchClass, prefix)
    batchProp = DATA batchClass (###detail) INDEXED;
    description##batchClass 'Партия' (###detail detail) = Stock.description(batchProp(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
    name##batchClass 'Партия' (###detail detail) = name(batchProp(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
    documentName##batchClass 'Наименование (для документов)' (###detail detail) = documentNameSku(batchProp(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
    
    CONSTRAINT sku(batchProp(###detail detail)) != sku(detail) CHECKED BY batchProp[###detail]
        MESSAGE 'Товар партии строки должен соответствовать SKU строки';

    CONSTRAINT batchProp(###detail detail) AND NOT sku(detail) CHECKED BY batchProp[###detail]
        MESSAGE 'Для строки задана партия, но не задан товар';
END

//META defineDocumentDetailBatchCustom(detail, batchProp)
//    batch###detail = DATA batchProp (Detail);
//    descriptionBatch###detail 'Партия' (detail) = descriptionBatch(batch###detail(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
//
//    CONSTRAINT skuBatch(batch###detail(detail)) != sku###detail(detail) CHECKED BY batch###detail
//        MESSAGE 'Товар партии строки должен соответствовать SKU строки';
//
//    CONSTRAINT batch###detail(detail) AND NOT sku###detail(detail) CHECKED BY batch###detail
//        MESSAGE 'Для строки задана парктия, но не задан товар';
//END
META defineDocumentDetailBatchCustom(detail, batchProp)
    @defineDocumentDetailBatchCustomPrefix(detail, batchProp, );
END

META defineDocumentAbstractDetailBatchCustom(detail, batchProp)
    @defineDocumentAbstractDetailBatchCustomInner(detail, batchProp, ###batchProp);
END

META defineDocumentAbstractDetailBatchCustomInner(detail, batchProp, batchClass)
    batchProp = ABSTRACT batchClass (###detail) PERSISTENT INDEXED;
    description##batchClass 'Партия' (###detail detail) = description(batchProp(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
    name##batchClass 'Партия' (###detail detail) = name(batchProp(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
    documentName##batchClass 'Наименование (для документов)' (###detail detail) = documentNameSku(batchProp(detail)) MINCHARWIDTH 20 PREFCHARWIDTH 40;
END
META defineDocumentInterfaceDetailBatchCustom(detail, batchProp)
    @defineDocumentAbstractDetailBatchCustom(detail, batchProp);
    @defineDocumentDetailBatchCustom(user###detail, batchProp);
    batchProp(User###detail detail) += batchProp(detail);
END

META defineDocumentDetailBatch(object, batchProp)
    @defineDocumentDetailBatchCustom(object##Detail, batchProp);
END
META defineDocumentAbstractDetailBatch(object, batchProp)
    @defineDocumentAbstractDetailBatchCustom(object##Detail, batchProp);
END
META defineDocumentInterfaceDetailBatch(object, batchProp)
    @defineDocumentInterfaceDetailBatchCustom(object##Detail, batchProp);
END
META showDocumentInterfaceDetailBatch(object)
    disableShowBatch = ABSTRACT BOOLEAN (###object);
    showBatch (###object i) = is(i) AND NOT disableShowBatch(i);
    showBatch (User###object i) = is(i) AND NOT disableShowBatch(i);
END
META showDocumentDetailBatch(object)
    disableShowBatch = ABSTRACT BOOLEAN (###object);
    showBatch = is(###object i) AND NOT disableShowBatch(i);
END

META defineDocumentDetailExpiryDateCustomPrefix(detail, prefix)
    prefix###expiryDate 'Годен до' = DATA DATE (###detail);
END
META defineDocumentAbstractDetailExpiryDateCustomPrefix(detail, prefix)
    prefix###expiryDate 'Годен до' = ABSTRACT DATE (###detail) PERSISTENT;
END
META defineDocumentInterfaceDetailExpiryDateCustomPrefix(detail, prefix)
    @defineDocumentAbstractDetailExpiryDateCustomPrefix(detail, prefix);
    @defineDocumentDetailExpiryDateCustomPrefix(user###detail, prefix);
    prefix###expiryDate(User###detail detail) += prefix###expiryDate(detail);
END

META defineDocumentInterfaceDetailExpiryDatePrefix(object, prefix)
    @defineDocumentInterfaceDetailExpiryDateCustomPrefix(object##Detail, prefix);
END

META defineDocumentInterfaceDetailExpiryDate(object)
    @defineDocumentInterfaceDetailExpiryDatePrefix(object, );
END

META defineDocumentDetailManufactureDateCustomPrefix(detail, prefix)
    prefix###manufactureDate 'Дата изготовления' = DATA DATE (###detail);
END
META defineDocumentAbstractDetailManufactureDateCustomPrefix(detail, prefix)
    prefix###manufactureDate 'Дата изготовления' = ABSTRACT DATE (###detail) PERSISTENT;
END
META defineDocumentInterfaceDetailManufactureDateCustomPrefix(detail, prefix)
    @defineDocumentAbstractDetailManufactureDateCustomPrefix(detail, prefix);
    @defineDocumentDetailManufactureDateCustomPrefix(user###detail, prefix);
    prefix###manufactureDate(User###detail detail) += prefix###manufactureDate(detail);
END

META defineDocumentInterfaceDetailManufactureDatePrefix(object, prefix)
    @defineDocumentInterfaceDetailManufactureDateCustomPrefix(object##Detail, prefix);
END

META defineDocumentInterfaceDetailManufactureDate(object)
    @defineDocumentInterfaceDetailManufactureDatePrefix(object, );
END

// ---------------------------------- Остаток (до) ----------------------- //

META defineDocumentDetailSkuBalanceCustom (detail)
    balanceBSku 'Количество до' (detail) = DATA NUMERIC[16,5] (###detail);

END
META defineDocumentAbstractDetailSkuBalanceCustom (detail)
    balanceBSku 'Количество до' (detail) = ABSTRACT NUMERIC[16,5] (###detail) PERSISTENT;
END

META defineDocumentInterfaceDetailSkuBalanceCustom(detail)
    @defineDocumentAbstractDetailSkuBalanceCustom(detail);
    @defineDocumentDetailSkuBalanceCustom(user###detail);
    balanceBSku(User###detail detail) += balanceBSku(detail);
END
META defineDocumentInterfaceDetailSkuBalance(object)
    @defineDocumentInterfaceDetailSkuBalanceCustom(object##Detail);
END

META deriveDocumentDetailSkuBalanceCustom (detail, skuProp, stockProp)
    balanceB###skuProp (###detail detail)  <- prevBalanceB(skuProp(detail), stockProp(detail), dateTime(detail))
        WHEN CHANGED(skuProp(detail)) OR CHANGED(stockProp(detail)) OR CHANGED(dateTime(detail));
END
META deriveDocumentDetailSkuBalance (object, skuProp, stockProp)
    @deriveDocumentDetailSkuBalanceCustom(object##Detail, skuProp, stockProp);
END

//замена товара у партии
allowReplaceItem = DATA LOCAL BOOLEAN ();

setSku 'Сменить товар'(Batch batch) = ACTION {
    FORM skus MODAL;
    IF formResult() == FormResult.ok THEN {  
        allowReplaceItem() <- TRUE;
        replace(chosenObject('s'), batch);
    }       
    apply();
} CONFIRM TOOLBAR;

EXTEND FORM currentBalanceBatchStock
	PROPERTIES(bt) setSku FORCE PANEL TOOLBAR
;