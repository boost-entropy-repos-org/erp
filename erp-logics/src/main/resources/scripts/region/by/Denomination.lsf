MODULE Denomination;

REQUIRE Reflection, SQLUtils, Machinery, Utils, Backup, PriceListLedger;

countDedomination = GROUP SUM 1 IF annotation(TableColumn p) == 'denomination' BY table(p);
countCurrency = GROUP SUM 1 IF annotation(TableColumn p) == 'denominationCurrency' BY table(p);
currencyField = GROUP MIN sid(TableColumn p) IF annotation(p) == 'currency' BY table(p);

countAnnotation = GROUP SUM 1 IF annotation(TableColumn p) AND NOT annotation(p) == 'currency' BY table(p);
orderDen(Table t) = rows(t) * OVERRIDE 5, countAnnotation(t);

denominationFilter(Table t) = countAnnotation(t) 
                                      OR sid(t) == 'Currency_rateExchange'
                                      OR sid(t) == 'PriceList_priceListDetailDataPriceListType' 
                                      OR sid(t) == 'PriceList_priceListLedgerLedgerPriceListTypeStock'
                                      OR sid(t) == 'PriceList_priceListLedgerLedgerPriceListType'
                                      OR sid(t) == 'PriceList_calcPriceListTypeGroup'
                                      OR sid(t) == 'PriceList_calcPriceListTypeSku';

skipDenomination(Table t) = sid(t) == 'ZReport_receiptDetail'
                          OR sid(t) == 'ZReport_receiptSaleDetail' 
                          OR sid(t) == 'ZReport_receiptSection'
                          OR sid(t) == 'ZReport_payment'
                          OR sid(t) == 'ZReport_receipt';

priceListTypesBy = GROUP CONCAT  TEXT (LedgerPriceListType t) IF t IS LedgerPriceListType AND (shortName(currency(t)) == 'BLR' OR NOT currency(t)),',';

denominationStart 'Старт деноминации' = DATA DATETIME (Table);
denominationEnd 'Окончание деноминации' = DATA DATETIME (Table);
vacuum 'Статус упаковки' = DATA INTEGER (Table);

EXTEND FORM physicalModel
    PROPERTIES (t) denominationStart, denominationEnd, vacuum
;

minDenominationTime = GROUP MIN OVERRIDE (denominationStart(Table t) IF NOT denominationEnd(t)), (denominationEnd(t) IF vacuum(t) == 1);
toVacuum = GROUP LAST Table t IF denominationEnd(t) AND NOT denominationEnd(t) > minDenominationTime() AND NOT vacuum(t) ORDER DESC orderDen(t);

doVacuum() = ACTION NEWSESSION {
    applyOnlyData();
    
    LOCAL NESTED vacuum = Table ();
    
    APPLY SERIALIZABLE {
        vacuum()<- toVacuum();
        vacuum(t1) <- 1 WHERE t1 == vacuum(); 
    }
    printToLog(currentDateTime() + ': start vacuum table ' + sid(vacuum()));
    
    IF vacuum() THEN IF
        denominationFilter(vacuum()) THEN {
            runSQL( 'VACUUM FULL ANALYZE ' + sid(vacuum()));
            vacuum(t1) <- 2 WHERE t1 == vacuum();
        } ELSE {
            vacuum(t1) <- 3 WHERE t1 == vacuum(); //таблица помечена как деноминированая но упаковка не требуется
        }
    APPLY {}
    printToLog(currentDateTime() + ': end vacuum table ' + sid(vacuum()));
    applyAll();
}


denominateZReport(INTEGER threads, BOOLEAN vacuum) = ACTION
    NEWEXECUTOR FOR skipDenomination(Table t) AND NOT denominationEnd(t) ORDER orderDen(t) DO NEWTHREAD { NEWSESSION NEWSQL {
        applyOnlyData();
        
        printToLog(currentDateTime() + ': start denomination table ' + sid(t));
        
        APPLY {
            denominationStart(t) <- currentDateTime();
        }
        APPLY {
            IF countDedomination(t) THEN 
                runSQL( 'LOCK ' + sid(t) + '; \n' +
                        'UPDATE ' + sid(t) + ' SET \n' +
                        [= GROUP CONCAT '   ' + sid(TableColumn p) + ' = ' + sid(p) + ' / 10000.0'  IF annotation( p) == 'denomination', ', \n' BY table(p)](t)
                      );
             
            denominationEnd(t) <- currentDateTime();
        }
        
        printToLog(currentDateTime() + ': end denomination table ' + sid(t));
        
        IF vacuum AS BOOLEAN THEN doVacuum();
        applyAll();
    }} THREADS threads;

denominate(INTEGER threads, BOOLEAN zreport, BOOLEAN vacuum, BOOLEAN disableRecalculate) = ACTION {

    denominationStart(Table all) <- NULL WHERE NOT denominationEnd(all);
    denominationStart(Table all) <- currentDateTime() WHERE NOT denominationFilter(all) AND NOT denominationStart(all);
    denominationEnd(Table all) <- currentDateTime() WHERE NOT denominationFilter(all) AND NOT denominationEnd(all);
    vacuum(Table all) <- NULL WHERE vacuum(all) == 1;
    vacuum(Table all) <- 3 WHERE NOT denominationFilter(all);
    APPLY {}
    
    NEWEXECUTOR FOR sid(Table t) AND (NOT skipDenomination(t) AND NOT zreport OR zreport) AND NOT denominationEnd(t) ORDER orderDen(t) DO NEWTHREAD { NEWSESSION NEWSQL {
        applyOnlyData();
        
        IF vacuum AS BOOLEAN THEN doVacuum();
        
        printToLog(currentDateTime() + ': start denomination table ' + sid(t));
        
        APPLY {        
            denominationStart(t) <- currentDateTime();
        }
        
        APPLY {
            
            runSQL('LOCK ' + sid(t) + ';');
            
            //обновляем поля независимые от валюты
            IF countDedomination(t) THEN 
                runSQL( 'UPDATE ' + sid(t) + ' SET \n' +
                        (CONCAT ', \n' , 
                            [= GROUP CONCAT TEXT ('   ' + sid(TableColumn p) + ' = ' + sid(p) + ' / 10000.0')  IF annotation( p) == 'denomination', ', \n' BY table(p)](t),
                            ('key3 = key3 / 10000.0' IF sid(t) == 'ReceiptSkuLedger_departmentStoreSkuDatePrice')) //цена в ключе
                      );
            
            //поля зависимые от валюты обновляем по связи с currency только для белорусского рубля
            IF countCurrency(t) THEN {
                runSQL( 'UPDATE ' + sid(t) + ' SET \n' +
                        [= GROUP CONCAT TEXT ('   ' + sid(TableColumn p) + ' = ' + sid(p) + ' / 10000.0')  IF annotation( p) == 'denominationCurrency', ', \n' BY table(p)](t) +
                        ' FROM currency_currency t1 ' +
                        ' WHERE '+  currencyField(t) + ' = t1.key0 AND t1.currency_shortname_currency = \'BLR\''
                      );
             }
                      
            //курсы делим если > 10
            FOR table(TableColumn p) == t AND annotation(p) == 'denominationRate' DO
                runSQL( 'UPDATE ' + sid(t) + ' SET ' + sid(p) + ' = ' + sid(p) + ' / 10000.0 WHERE '+ sid(p) + ' > 10.0');
                
            IF sid(t) == 'Currency_rateExchange' THEN 
                runSQL( 'UPDATE currency_rateexchange SET currency_rate_typeexchange_currency_date = currency_rate_typeexchange_currency_date / 10000.0 WHERE currency_rate_typeexchange_currency_date > 10.0' );
            
            
            
            //прайслисты через ссылку на PriceListType                   
            IF sid(t) == 'PriceList_priceListDetailDataPriceListType' THEN
                runSQL( 'UPDATE PriceList_priceListDetailDataPriceListType t SET ' +
                        '   PriceList_price_PriceListDetail_DataPriceListType = PriceList_price_PriceListDetail_DataPriceListType / 10000.0, \n' +
                        '   PriceList_price_UserPriceListDetail_DataPriceListType = PriceList_price_UserPriceListDetail_DataPriceListType / 10000.0 \n' +
                        '   WHERE t.key1 IN (' + priceListTypesBy() + ')'
                      );
    
            //принудительное деление 
            IF sid(t) == 'PriceList_priceListLedgerLedgerPriceListTypeStock' THEN {
                runSQL( 'UPDATE PriceList_priceListLedgerLedgerPriceListTypeStock t SET \n' +
                        '   PriceList_price_PriceListLedger_LedgerPriceListType_Stock = PriceList_price_PriceListLedger_LedgerPriceListType_Stock / 10000.0 \n'  +
                        '   WHERE t.key1 IN (' + priceListTypesBy() + ')'
                      );
            }
            IF sid(t) == 'PriceList_priceListLedgerLedgerPriceListType' THEN {
                runSQL( 'UPDATE PriceList_priceListLedgerLedgerPriceListType t SET \n' +
                        '   PriceList_price_PriceListLedger_LedgerPriceListType = PriceList_price_PriceListLedger_LedgerPriceListType / 10000.0, \n'  +
                        '   PriceList_price_PriceListLedger_SystemLedgerPriceListType = PriceList_price_PriceListLedger_SystemLedgerPriceListType / 10000.0 \n'  +
                        '   WHERE t.key1 IN (' + priceListTypesBy() + ')'
                      );
            }
            
            //предельные надбавки на овощи
            IF sid(t) == 'PriceList_calcPriceListTypeGroup' THEN {
                runSQL( 'UPDATE PriceList_calcPriceListTypeGroup t SET \n' +
                        '   PriceList_dataMarkup_CalcPriceListType_Group = PriceList_dataMarkup_CalcPriceListType_Group / 10000.0 \n'  +
                        '   WHERE PriceList_dataMarkup_CalcPriceListType_Group >= 300.0'
                      );
            }
            
            IF sid(t) == 'PriceList_calcPriceListTypeSku' THEN {
                runSQL( 'UPDATE PriceList_calcPriceListTypeSku t SET \n' +
                        '   PriceList_dataMarkup_CalcPriceListType_Sku = PriceList_dataMarkup_CalcPriceListType_Sku / 10000.0 \n'  +
                        '   WHERE PriceList_dataMarkup_CalcPriceListType_Sku >= 300.0'
                      );
            }
        
        }
        
        APPLY {
            denominationEnd(t) <- currentDateTime();
        }
        printToLog(currentDateTime() + ': end denomination table ' + sid(t));
        
        IF vacuum AS BOOLEAN THEN doVacuum();
        
        applyAll();
    }} THREADS threads;
    
    applyOnlyData();
    //округление по умолчанию
    FOR name(Currency c) == 'Белорусский рубль' AND currency(RoundCondition r) == c AND name(r) == 'До копеек' DO 
        defaultRoundCondition(c) <- r;
    
    FOR RoundCondition rc IS RoundCondition DO {
        priceRound(rc) <- 2;
        denominatorPrice(rc) <- denominatorPrice(rc) / 10000.0 WHERE denominatorPrice(rc) > 1.0;
        minPrice(rc) <- minPrice(rc) / 10000.0 WHERE minPrice(rc) > 1.0;
        FOR roundCondition(PriceInterval p) == rc DO {
            from(p) <- from(p) / 10000.0 WHERE from(p) > 1.0;
            to(p) <- to(p) / 10000.0 WHERE to(p) > 1.0;
            modifier(p) <- modifier(p) / 10000.0 WHERE modifier(p) > 1.0;
        }
    }
    apply();
    applyAll();
    
    FOR name(RoundCondition rc) == 'До 100 рублей' DO
        DELETE PriceInterval p WHERE roundCondition(p) == rc;
        
    //переводим оборудование
    denominationStage(GroupMachinery groupMachinery) <- DenominationStage.fusion WHERE NOT denominationStage(groupMachinery) == DenominationStage.after;
    
    //убираем пересчет не числовых агрегаций
    notRecalculate(TableColumn c) <- TRUE WHERE NOT startsWith(return(property(c)), 'NUMERIC') AND disableRecalculate; 
        
    APPLY {}  
} 


denominateLite() = ACTION {
    makeBackup();
    denominate(4, TRUE, TRUE, NULL);
    recalculateMultiThreadAction(4, NULL);
}