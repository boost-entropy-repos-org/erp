//////////////// MODULE HEADER //////////////////
// Syntax:
// MODULE moduleName;
// [REQUIRE moduleName1, ..., moduleNameN;]
// [PRIORITY namespace1, ..., namespaceK;]
// [NAMESPACE namespaceName;]

MODULE Features;

REQUIRE System, I18n, Utils, Country, Email, Security, Service;

/////////// GROUP STATEMENT ////////////

// Syntax:
// GROUP name ['caption'] [: parentGroup];
GROUP base 'Основная группа' : base;
GROUP simpleGroup;
GROUP sampleGroup : System.base; // явная квалификация имен

/////////// CLASS STATEMENT ////////////
// Syntax:
// CLASS [ABSTRACT] name ['caption']
// [{
//      instanceName1 ['instanceCaption1'],
//      ...
//      instanceNameN ['instanceCaptionN']
// }]
// [: baseClass1 [, baseClass2, ..., baseClassN]];

CLASS ABSTRACT Named 'Объект с именем' ;
name(obj) = DATA STRING[100] (Named);

CLASS EmptyClass;
CLASS Article 'Товар' : Named;
CLASS Store 'Склад' : Named;
CLASS ABSTRACT Document 'Документ';
CLASS IncomeDocument 'Приход' : Document;
CLASS OutcomeDocument 'Расход' : Document, EmptyClass;

date(doc) = DATA DATE (Document);

CLASS EmptyInst;

CLASS StoreSize 'Размер склада' {} : Named;

EXTEND CLASS StoreSize
{
    huge 'огромный',
    big 'большой'
}

// Extending class
// Syntax:
// EXTEND CLASS className
// [{
//      instanceName1 ['instanceCaption1']
//      ...
//      instanceNameN ['instanceCaptionN']
// }]
// [: baseClass1 [, baseClass2, ..., baseClassN];]
EXTEND CLASS IncomeDocument : EmptyClass;

EXTEND CLASS Features.StoreSize
{
    medium 'средний',
    small 'маленький'
}


//////////// PROPERTY STATEMENT///////////
// Common syntax:
// name ['caption'] [(namedParam1, ..., namedParamN)] = propertyExpression [IN group] [PERSISTENT] [TABLE <table name>]
//                                                                                                 [TOOLBAR]
//                                                                                                 [SHORTCUT propertyName]
//                                                                                                 [ASONCHANGE propertyName]
//                                                                                                 [ASONCHANGEWYS propertyName]
//                                                                                                 [ASONEDIT propertyName]
//                                                                                                 [FIXEDCHARWIDTH <int value>]
//                                                                                                 [MINCHARWIDTH <int value>]
//                                                                                                 [MAXCHARWIDTH <int value>]
//                                                                                                 [PREFCHARWIDTH <int value>]
//                                                                                                 [IMAGE 'name'] [EDITKEY '<key code>' [SHOW | HIDE]] [AUTOSET] [CONFIRM]
//                                                                                                 [REGEXP '<expression>' ['<regExp message>']] [LOGGABLE] [ECHO] [INDEXED]
//                                                                                                 [AGGPROP] [NOT NULL [DELETE] [APPLY | SESSION] [FORMS form1, ..., formN]]
//                                                                                                 [ON (CHANGE | CHANGEWYS | EDIT) action]
//                                                                                                 [EVENTID 'id'];

// Если именованные параметры не указываются, то они выводятся из propertyExpression
// Специальные имена свойств: PREV, CHANGED, ASSIGNED

// Data property
// Expression syntax:
// DATA [SESSION] returnClass ( [paramClass1, ..., paramClassN] )
// If SESSION modifier is specified, than session data property will be created.
// Built-in types: INTEGER, LONG, DOUBLE, BOOLEAN, DATE, DATETIME, TEXT, STRING, ISTRING, TIME, WORDFILE, IMAGEFILE, PDFFILE, CUSTOMFILE, EXCELFILE, NUMERIC, COLOR
store(document) = DATA Store (Document) IN base;
quantity(document, article) = DATA DOUBLE (Document, Article) IN base;
storeSize(store) = DATA StoreSize (Store) IN base;

sessionObj() = DATA SESSION Object ();

// Join property
// Expression syntax:
// [JOIN] (name | '[' propertyDefinition ']') (param1, ..., paramN)
storeName 'Склад' (document) = JOIN name(store(document)) IN base;
storeSizeName = staticCaption(storeSize(store)) IN base; // можем не указывать именованные параметры слева от '=', но все равно пользоваться ими

// IS, AS
// Expression syntax:
// propertyExpression (AS | IS) className
// IS - is(), AS - object()
isIncomeDocument(document) = document IS IncomeDocument;


// AND, IF (идентичны по действию)
// Expression syntax:
// propertyExpression (AND | IF) [NOT] propertyExpression
inQuantity(document, article) = quantity(document, article) IF isIncomeDocument(document);
outQuantity(document, article) = quantity($1, $2) IF $1 IS OutcomeDocument;  // указание номеров параметров вместо имен

// Group property
// SUM, MAX, MIN, EQUAL group property
// Expression syntax:
// GROUP (SUM | MAX | MIN | EQUAL) propertyExpression [BY propertyExpression1, ..., propertyExpressionN]
incomeQuantity(store, article) = GROUP SUM inQuantity(document, article) BY store(document), article;
outcomeQuantity(store, article) = GROUP SUM outQuantity(doc, art) BY store(doc), art;

incomeQuantity2(store, article) = GROUP SUM quantity(document, article) IF document IS IncomeDocument BY store(document), article;
outcomeQuantity2(store, article) = GROUP SUM quantity(doc, art) IF doc IS OutcomeDocument BY store(doc), art;

// CONCAT group property
// GROUP CONCAT propertyExpr, separatorPropertyExpr [BY propertyExpr1, ..., propertyExprN] [ORDER [DESC] orderPropertyExpr1, ..., orderPropertyExprK]
allNames() = GROUP CONCAT name(obj) IF obj IS Named, ', ' ORDER DESC name(obj);

// AGGR group property
// GROUP AGGR propertyExpression [BY propertyExpression1, ..., propertyExpressionN] [WHERE propertyExpression]
nameToCountry(name) = GROUP AGGR country BY name(country);


testUnion(store, article) = incomeQuantity(store, article) (+) outcomeQuantity(store, article);

// OR property
// Expression syntax:
// propertyExpression1 OR propertyExpression2

// Recursive property
// Expression syntax:
// RECURSION initPropertyExpression STEP stepPropertyExpression [CYCLES (YES | NO | IMPOSSIBLE)]
// Previous value syntax: $param
// Default: CYCLES NO

// IF THEN ELSE property
// Expression syntax:
// IF propertyExpression0 THEN propertyExpression1 [ELSE propertyExpression2]
documentTypeString 'Тип документа' (doc) = IF doc IS IncomeDocument
                                                THEN 'Приход'
                                                ELSE 'Расход' IF doc IS OutcomeDocument;

// Case property
// Expression syntax:
// CASE [OVERRIDE | EXCLUSIVE]
//      WHEN whenPropertyExpression1 THEN thenPropertyExpression1
//      ...
//      WHEN whenPropertyExpressionN THEN thenPropertyExpressionN
//      [ELSE defaultPropertyExpression]
sizeCode 'Размер склада (код)' (ss) = CASE
                                          WHEN ss == StoreSize.huge THEN 'HUGE'
                                          WHEN ss == StoreSize.big THEN 'BIG'
                                          WHEN ss == StoreSize.medium THEN 'MEDIUM'
                                          WHEN ss == StoreSize.small THEN 'SMALL'
                                      ;

// Multi property
// Expression syntax:
// MULTI propertyExpression1, ..., propertyExpressionN [EXCLUSIVE | OVERRIDE]

CLASS CaseA;
CLASS CaseB : CaseA;
CLASS CaseC : CaseA;
CLASS CaseD : CaseC;

caseData1 = DATA INTEGER (CaseA);
caseData2 = DATA INTEGER (CaseA);
caseData3 = DATA INTEGER (CaseA);

caseDataB = DATA INTEGER (CaseB);
caseDataC = DATA INTEGER (CaseC);

overrideTest 'OVERRIDE' (a) = OVERRIDE caseData1(a), caseData2(a), caseData3(a);
exclusiveTest 'EXCLUSIVE' (a) = EXCLUSIVE caseData1(a), caseData2(a), caseData3(a);

testInt(a) = DATA INTEGER (CaseA);

caseTest(a) = CASE
                    WHEN testInt(a) < 5 THEN caseData1(a)
                    WHEN testInt(a) < 6 THEN caseData2(a)
                    WHEN testInt(a) < 7 THEN caseData3(a)
                    ELSE 0 IF a IS CaseA;
              ;

caseTest2(a) = CASE EXCLUSIVE
                    WHEN testInt(a) >= 5 THEN caseData1(a)
                    WHEN testInt(a) < 5 THEN caseData2(a)
                    WHEN testInt(a) == 5 THEN caseData3(a)
               ;

multiTest 'MULTI' (a) = MULTI caseDataB(a), caseDataC(a);
multiTest2 'MULTI OVER' (a) = MULTI caseDataB(a), caseDataC(a) OVERRIDE;

caseActionTest(a) = ACTION CASE
                        WHEN testInt(a) > 7 THEN { MESSAGE '>7'; }
                        WHEN testInt(a) > 6 THEN { MESSAGE '>6'; }
                        WHEN testInt(a) > 5 THEN { MESSAGE '>5'; }
                    ;

caseActionTest2(a) = ACTION CASE EXCLUSIVE
                        WHEN testInt(a) > 7 THEN { MESSAGE '>7'; }
                        WHEN testInt(a) > 6 THEN { MESSAGE '>6'; }
                        WHEN testInt(a) > 5 THEN { MESSAGE '>5'; }
                     ;

multiActionTest(a) = ACTION MULTI IF a IS CaseB THEN MESSAGE caseDataB(a), IF a IS CaseC THEN MESSAGE caseDataC(a);
multiActionTest2(a) = ACTION MULTI OVERRIDE IF a IS CaseB THEN MESSAGE caseDataB(a), IF a IS CaseC THEN MESSAGE caseDataC(a);


FORM caseTest 'Тест CASE'
OBJECTS a=CaseA//, b=CaseB, c=CaseC
PROPERTIES(a) ADDOBJ, testInt, caseData1, caseData2, caseData3, overrideTest, exclusiveTest, caseTest, caseTest2, multiTest, multiTest2
PROPERTIES(a) caseActionTest, caseActionTest2, multiActionTest, multiActionTest2
//PROPERTIES ADDOBJ(b), ADDOBJ(c), caseDataB(b), caseDataC(c), multiTest(b, c), multiTest2(b, c)
;

storeSizeCode 'Размер склада (код)' (s) = sizeCode(storeSize(s));

// Partition property
// SUM, PREV partition property
// Expression syntax:
// PARTITION (SUM | PREV) propertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
// [WINDOW EXCEPTLAST]
testPartition(store, article) = PARTITION SUM incomeQuantity(store, article) BY store ORDER DESC name(article);

// UNGROUP PROPORTION partition property
// PARTITION UNGROUP propertyObject PROPORTION [STRICT] ROUND(precision) proportionPropertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
testAmount(store) = 20.0 IF store IS Store;
testData(article) = DATA DOUBLE (Article);
testPropPartition(store, article) = PARTITION UNGROUP testAmount PROPORTION STRICT ROUND(2) testData(article) BY store ORDER name(article);

// UNGROUP LIMIT partition property
// PARTITION UNGROUP propertyObject LIMIT [STRICT] limitPropertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
testLimitPartition(store, article) = PARTITION UNGROUP testAmount LIMIT STRICT testData(article) BY store ORDER DESC name(article);


// Concatenation/Deconcatenation property
// Expression syntax:
// STRUCT(propertyExpression1[, ..., propertyExpressionN])
// Access expression syntax with one-base indices:
// concatenatePropertyExpression[2]
ioQuantity(store, article) = STRUCT(incomeQuantity(store, article), outcomeQuantity(store, article)) PERSISTENT;
onlyIncomeQuantity 'Test STRUCT' (store, article) = ioQuantity(store, article)[1];

tstData = DATA INTEGER (Store);
tstStruct(store) = STRUCT(tstData(store), 5) PERSISTENT;
tstDestruct(store) = tstStruct(store)[1];

// Abstract property
// Expression syntax:
// ABSTRACT returnClass (paramClass1, ..., paramClassN) [EXCLUSIVE]
testAbstract(named) = ABSTRACT INTEGER (Named);
// overriding abstract property syntax:
// propertyName(namedParam1, ..., namedParamN) += expression;
testAbstract(named) += 5 IF named IS Article;
testAbstract(named) += 6 IF named IS Store;

// Abstract action property
// Expression syntax:
// ABSTRACT ACTION (className1, ..., classNameN)

testAbstractAction = ABSTRACT ACTION (Object);
// overriding abstract action property syntax:
// propertyName(namedParam1, ..., namedParamN) += ACTION actionBody;

testAbstractAction(store) += ACTION IF store IS Store THEN MESSAGE 'testing store';
testAbstractAction(store) += ACTION IF store IS Store THEN MESSAGE 'testing store2';
testAbstractAction(document) += ACTION IF document IS Document THEN MESSAGE 'testing document';
testAbstractAction(document) += ACTION IF document IS Document THEN MESSAGE 'testing document2';

// Formula property
// Expression syntax:
// FORMULA [primitiveType] 'formula text $1 + $2'
sum12 = FORMULA DOUBLE '($1)+($2)*2';
testFormula(store, article) = sum12(incomeQuantity(store, article), outcomeQuantity(store, article));

// Computational expressions
// Priority:
// OR
// AND  IF
// ==  !=
// <  >  <=  >=
// (+) (-)
// +  -
// *  /
// - (unary)
//
// Instances: 5, 5L, 6.35, 6.35d, TRUE, 'some string', class.object, 2011_10_25, 2011_10_25_18:00, 18:00, NULL, #ff0000, RGB(255, 0, 0)
balanceQuantity(store, article) = incomeQuantity(store, article) - outcomeQuantity(store, article) PERSISTENT;

foo(store, article) = 5 * incomeQuantity($1, $2) - outcomeQuantity($1, $2);
foo2(store, article) = - outcomeQuantity(store, article) + 5 * incomeQuantity(store, article);
bar = incomeQuantity(store, article) * 5 - 3 - 4 + outcomeQuantity(store, article);
bar2(store, article) = 3.5 * incomeQuantity($1, $2) - (5 + outcomeQuantity($1, $2));
foobar(store, article) = [x*x + y](foo(store, article), bar(store, article));   // lambda-like syntax
baz(store, article) = bar(store, article) > bar2(store, article) IN base;
baz2 = foo(s, a) >= 15 == foo2(s, a) >= 15;

storeIsHuge(store) = storeSize(store) == StoreSize.huge;                        // static object
storeIsBig(store) = storeSize(store) == StoreSize.big;
storeIsMedium(store) = storeSize(store) == StoreSize.medium;
storeIsSmall(store) = storeSize(store) == StoreSize.small;
storeIsHuge2(store) = (storeSize(store) == StoreSize.huge) == TRUE;

documentBalance(document, article) = balanceQuantity(store(document), article);

////////////////ACTION PROPERTIES////////////////
// General Syntax:
// ACTION [(param1, ..., paramN)] actionStatement

// List action
// statement syntax:
// [NEWSESSION [AUTOAPPLY]]  {
//      actionStatement1 | LOCAL name = returnClass ( [paramClass1, ..., paramClassK1] )
//      ...
//      actionStatementN | LOCAL name = returnClass ( [paramClass1, ..., paramClassKN] );
// }
//
// If NEWSESSION is specified than action will be performed in new session.
// If AUTOAPPLY is specified - this new session will be applied by default,
// if not - one should do 'EXEC apply();' explicitly.

// Exec action
// statement syntax:
// [EXEC] actionPropertyName(propertyExpr1, ..., propertyExprN)
// or
// [EXEC] [actionPropertyExpr](propertyExpr1, ..., propertyExprN)

// Set action
// statement syntax:
// [SET] name(param1, .., paramN) <- propertyExpressionFrom [WHERE conditionalExpression]

// If action
// statement syntax:
// IF propertyExpresson
//      THEN actionStatement1
//     [ELSE actionStatement2]

// Case action
// statement syntax
// CASE [OVERRIDE | EXCLUSIVE]
//      WHEN propertyExpr1 THRN action1
//      ...
//      WHEN propertyExprN THEN actionN

// Multi action
// statement syntax:
// MULTI [OVERRIDE | EXCLUSIVE] action1, ..., actionN

// For/While action
// statement syntax:
// (FOR | WHILE) propertyExpression [ORDER [DESC] orderExpression1, ..., orderExpressionN] DO actionStatement

// Form action
// statement syntax:
// FORM formName
// [OBJECTS object1 =mappingExpr1, ..., objectN =mappinExprN]
// [NEWSESSION | MANAGESESSION | OLDSESSION] [DOCKED | MODAL | FULLSCREEN | DOCKEDMODAL] [CHECK] [SHOWDROP]


// Add object action
// statement syntax:
// ADDOBJ className [WHERE expression] [TO propertyName(param1, ..., paramN)]

CLASS AOA : Named;
CLASS AOB : Named;

AOBforAOA(a) = DATA AOB (AOA);
countAOAAOB(a, b) = DATA INTEGER (AOA, AOB);
countAOA(a) = DATA INTEGER (AOA);

addA() = ACTION ADDOBJ AOA;
addB() = ACTION ADDOBJ AOB;

addAllBTo() = ACTION ADDOBJ AOB WHERE countAOA(a) > 5 TO AOBforAOA(a);

FORM testAddObject
    OBJECTS a=AOA, b=AOB
    PROPERTIES name(a), name(b), countAOA(a), addA(), addB(), addAllBTo(), AOBforAOA(a), countAOAAOB(a, b)
;


// Add/Edit form action
// statement syntax:
// (ADDFORM | EDITFORM) [SESSION] className
addActionTest() = ACTION ADDFORM Store;
editActionTest(obj) = ACTION EDITFORM Store;

// Custom action
// statement syntax:
// CUSTOM 'javaClassName'

// Message action
// statement syntax:
// MESSAGE propertyExpr

// Delete action
// statement syntax:
// DELETE object [WHERE expression]

// Change class action
// statement syntax:
// CHANGECLASS object TO className [WHERE expression]
// built-in or abstract class names are forbidden

CLASS CCA : Named;
CLASS CCB : Named;

CCBforCCA(a) = DATA CCB (CCA);
countCCACCB(a, b) = DATA INTEGER (CCA, CCB);
countCCA(a) = DATA INTEGER (CCA);
countCCB(b) = DATA INTEGER (CCB);
changeAWhenCountB 'countCCB > 5' (a, b) = ACTION CHANGECLASS a TO CCB WHERE countCCB(b) > 5;
changeAWhenCountAB 'countCCACCB > 5' (a, b) = ACTION CHANGECLASS a TO CCB WHERE countCCACCB(a, b) > 5;
changeA(a) = ACTION CHANGECLASS a TO CCB;
changeAllA 'all where CCA > 5' () = ACTION CHANGECLASS a TO CCB WHERE countCCA(a) > 5;
deleteA 'delete A > 5' () = ACTION DELETE a WHERE countCCA(a) > 5;

changeAllAWhenCountAB 'all count CCACCB > 5' (b) = ACTION CHANGECLASS a TO CCB WHERE countCCACCB(a, b) > 5;
changeAllAWhenCountB 'all count CCB > 5' (b) = ACTION CHANGECLASS a TO CCB WHERE countCCB(b) > 5 AND a IS CCA;

FORM testChangeClass
    OBJECTS a=CCA, b=CCB
    PROPERTIES name(a), name(b), countCCA(a), countCCB(b), CCBforCCA(a), countCCACCB(a, b)
    PROPERTIES changeA(a), changeAllA(), deleteA(), changeAWhenCountB(a, b), changeAWhenCountAB(a, b)
    PROPERTIES changeAllAWhenCountAB(b), changeAllAWhenCountB(b), DELETE(a), DELETESESSION(a)
;

// File open/load action
// statement syntax:
// [OPENFILE | LOADFILE] propertyExpression

// Email action
// statement syntax:
// EMAIL
//  [FROM propertyExpression]
//  SUBJECT propertyExpression
//  (TO || CC || BCC) propertyExpression [ (TO || CC || BCC) propertyExpression ...]
//  [(INLINE formName OBJECTS obj1=propertyExpression1, ..., objN=propertyExpressionN) ...]
//  [(ATTACH (PDF, DOCX, HTML, RTF) [NAME propertyExpression] formName OBJECTS obj1=propertyExpression1, ..., objN=propertyExpressionN) ...]

// Confirm action
// statement syntax:
// CONFIRM propertyExpression

// Request action
// statement syntax:
// REQUEST type (INPUT | [objectName] actionStatement)
// type can be built-in type or OBJECT

// Eval action
// statement syntax:
// EVAL expression

script(doc) = DATA TEXT (Document);
evalScript(doc) = ACTION EVAL script(doc);

FORM TestEvalActionForm 'Тест скриптов'
OBJECTS d=Document
PROPERTIES(d) store, script, evalScript;


copyStoreNameToArticles 'Скопировать имя склада в имена артиклей' (s) = ACTION(s) {
    name(a) <- (name(s) IF s IS Store) WHERE a IS Article;
};

copyStoreNameToArticle 'Добавить имя склада к имени артикля' (s, a) = ACTION(s, a) NEWSESSION AUTOAPPLY {
    name(a) <- [FORMULA STRING[20] '$1 || $2'](name(a), name(s));
};

copyStoreNameToArticleError 'Скопировать имя склада в имя артикля (с ошибкой)' (s, a) = ACTION(s, a) NEWSESSION {
    name(a) <- name(s);
    apply();
};

createNewStore 'Добавить большой склад' = ACTION () {
    ADDOBJ Store;

    sessionObj() <- addedObject();

    name(k) <- [FORMULA STRING[20] '$1 || CAST($2 as char(20))']('New store ', sessionObj()) WHERE k == sessionObj() ;
    storeSize(k) <- StoreSize.big WHERE k == sessionObj();
} TOOLBAR IMAGE 'add.png';

//////////////// TEST PUSHING FOR //////

selCur = DATA SESSION BOOLEAN (Document, Article);
selAll = DATA SESSION BOOLEAN (Document, Article);
selArt = DATA SESSION BOOLEAN (Article);

testExec = ACTION (document, article) {
    IF quantity(document, article) > 3 THEN
        name(article) <- 'More then 3';
}

testPush = ACTION(document) {

    FOR selArt(article) DO // to be pushed
        testExec(document, article);

    FOR selCur(document, article) ORDER date(document) DO {  // to be pushed
        quantity(document, article) <- 5.0d;
    }

    LOCAL i = INTEGER ();
    i() <- 0;
    FOR selArt(article) DO // not to be pushed
        i() <- i() + 1;
    MESSAGE [FORMULA STRING[20] '$1 || CAST($2 as char(20))']('I= ', i());

    FOR selAll(document2, article) ORDER date(document2) DO { // to be pushed
        name(article) <- [FORMULA STRING[20] '$1 || CAST($2 as char(20))']('Article ', quantity(document2, article));
    }

    FOR ADDOBJ Article DO {
        MESSAGE name(added);
    }

}

testPush2 = ACTION(document) {

    FOR date(document2) DO { // to be pushed
        name(article) <- 'NEW' IF article IS Article IF document IS IncomeDocument;
    }

    FOR quantity(document2, article) ORDER date(document2) DO { // to be pushed
        quantity(document2, article) <- 6.0d;
        name(article) <- 'Changed';
    }

    LOCAL i = INTEGER ();
    i() <- 0;
    FOR date(document2) DO
        FOR quantity(document2, article) > 3 DO {
            i() <- i() + 1;
        }
    MESSAGE [FORMULA STRING[20] '$1 || CAST($2 as char(20))']('I= ', i());

    date(document) <- NULL;
}

copy = ACTION(document) {
    FOR quantity(document, article) ADDOBJ Article DO {
        name(added) <- name(article);
        quantity(document, added) <- quantity(document, article);
    }
}

CLASS QuantityString;
@defineAggregation(document, article, QuantityString, quantity);
dateDocumentQuantityString(s) = date(documentQuantityString(s));
storeNameDocumentQuantityString(s) = storeName(documentQuantityString(s));
nameArticleQuantityString(s) = name(articleQuantityString(s));

///////////////CONSTRAINT STATEMENT//////////////
// Syntax:
// CONSTRAINT propertyExpression [CHECKED [BY propertyName1, ..., propertyNameN]] propertyExpression MESSAGE 'message';
CONSTRAINT foo(store, article) > 1000 CHECKED MESSAGE 'ошибка: >1000';


////////////////FOLLOWS STATEMENT////////////////
// Syntax:
// propertyName(param1, ..., paramN) =>
//      propertyExpression1 [RESOLVE (TRUE | FALSE | ALL | NOTHING) [SESSION]],
//      ...
//      propertyExpressionK [RESOLVE (TRUE | FALSE | ALL | NOTHING) [SESSION]];
//foo(store, article) => foo2(store, article) RESOLVE NOTHING;


////////////////WRITEWHEN STATEMENT//////////////
// Syntax:
// propertyName(param1, ..., paramN) <- valuePropertyExpression WHEN changePropertyExpression;

// inQuantity(document, article) <- 15 WHEN CHANGED(foo(store(document), article));


///////////////////EVENT STATEMENT//////////////
// Syntax:
// WHEN expression DO action [ORDER [DESC] expr1, ..., exprN] [SESSION];

constraintAction (store, article) = ACTION (store, article) {
//    EXEC cancel();
    IF foo(store, article) > 300000 THEN {
        MESSAGE name(article);
    }
};

WHEN SESSION foo(store,article)>10000 DO constraintAction(store, article) ORDER name(article);

/////////////GLOBAL EVENT STATEMENT//////////////
// Syntax:
// ON (APPLY | SESSION) action;

globalInt() = DATA INTEGER ();
ON SESSION globalInt() <- globalInt() (+) 1;

///////////////////ASPECT STATEMENT//////////////
// Syntax:
// BEFORE | AFTER propertyName(param1, ..., paramN) DO action;

BEFORE constraintAction(store, article) DO MESSAGE 'Before Aspect';

cancledMessage() = ACTION() {
    MESSAGE 'changes were canceled';
}

appliedMessage() = ACTION() {
    MESSAGE 'form apply message';
}

okMessage() = ACTION() {
    MESSAGE 'Now closing...';
    formClose();
}

//////////////// FORM STATEMENT /////////////////
// Syntax:
// FORM name ['caption'] [TITLE 'title'] [PRINT] [DOCKED | MODAL | FULLSCREEN | DOCKEDMODAL] | EXTEND FORM name
// [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form | list form)]
// ...
// [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form | list form)];
FORM documentArticle 'По документам (caption)' TITLE 'По документам (title)'

// GroupObjects list syntax:
// OBJECTS object definition | [groupAlias=] (object1 definition, ..., objectN definition) [REPORTFILE prop(p1, ..., pK)] [INIT | FIXED] [PANEL | HIDE | GRID] [PAGESIZE <int value>],
//         ...
//         object definition | [groupAlias=] (object1 definition, ..., objectN definition) [REPORTFILE prop(p1, ..., pK)] [INIT | FIXED] [PANEL | HIDE | GRID] [PAGESIZE <int value>]

// Object definition syntax:
// [alias=] className ['<caption>'] [ON CHANGE action]

    OBJECTS document=Document, article=Article

// TreeGroup list syntax:
// TREE [SID] [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>],
//            ...
//            [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>]

// Property list syntax:
// PROPERTIES [commonOptions] [alias1=]propName1(param1, ..., paramN1) [options1], ..., [aliasK=]propNameK(param1, ..., paramNK) [optionsK]
// or
// PROPERTIES(param1, ..., paramN) [commonOptions] [alias1=]propName1 [options1], ..., [aliasK=]propNameK [optionsK]
// Special properties: SELECTION, OBJVALUE, ADDOBJ, ADDFORM, ADDSESSIONFORM, EDITFORM, EDITSESSIONFORM, DELETE, DELETESESSION
// Property option:    [READONLY] [EDITABLE] [SELECTOR] [HINTNOUPDATE] [HINTTABLE] [COLUMNS (<groupObject list>)] [SHOWIF <mappedProperty>] [BACKGROUND <mappedProperty>]
//                     [HEADER <mappedProperty>] [FOOTER <mappedProperty>] [READONLYIF <mappedProperty>] [FORCE PANEL | HIDE | GRID] [TODRAW <groupObject>]
//                     [FOREGROUND <mappedProperty>] [ON (CHANGE | CHANGEWYS | SHORTCUT | EDIT) <mappedAction>] [(BEFORE | AFTER) (propertyAlias | <mappedProperty>)] [EVENTID 'id']

    PROPERTIES(document) documentTypeString, storeName, testPush, testPush2, copy
    PROPERTIES name(article)
    PROPERTIES quantity(document, article)
    PROPERTIES inQuantity(document, article), outQuantity(document, article), documentBalance(document, article), selCur(document, article), selAll(document, article), selArt(article)
    PROPERTIES ADDOBJ(document), ADDOBJ(article), testAbstractAction(document)
    PROPERTIES globalInt()

// Filters list syntax:
// FILTERS propertyExpression1, ..., propertyExpressionK
    FILTERS name(article)

// Events list syntax:
// EVENTS
// ON (INIT | APPLY | OK | CANCEL | CLOSE | DROP | QUERYOK | QUERYCLOSE) action1,
// ...
// ON (INIT | APPLY | OK | CANCEL | CLOSE | DROP | QUERYOK | QUERYCLOSE) actionN
    EVENTS
        ON CANCEL cancledMessage(),
        ON APPLY appliedMessage(),
        ON QUERYOK okMessage()
;

// Hints list syntax:
// HINTNOUPDATE | HINTTABLE propertyName1, ..., propertyNameN

// Order list syntax:
// ORDER BY (propertyAlias1 | <mappedProperty1>), ..., (propertyAliasN | <mappedPropertyN>)

showDocumentArticleModalForm 'Показать модальную "По документам"' = ACTION() NEWSESSION {
    ADDOBJ Article;

    FOR (k == addedObject()) DO {
        name(k) <- 'this is new article';
        BREAK;
    } ELSE
        MESSAGE 'Object wasnt added';

    FORM documentArticle MODAL CHECK;

    IF (formResult() == FormResult.ok) THEN {
        MESSAGE 'You pressed "ok"';
        MESSAGE [FORMULA STRING[100] '\'You have choosen article \' || $1 || \' and store \' || $2'](name(chosenObject('article')), name(store(chosenObject('document'))));

        FOR (k == chosenObject('article')) DO {
            name(k) <- 'THIS article was chosen in modal form';
        };
        FOR (k == store(chosenObject('document'))) DO {
            name(k) <- 'Document for THIS store was chosen in modal form';
        };

        RETURN;
    } ELSE IF (formResult() == FormResult.close) THEN {
        MESSAGE 'You pressed "close"';
    };
};

i() = DATA SESSION INTEGER ();
testAction 'Показать "По документам" 3 раза' = ACTION() {
    i() <- 0;
    WHILE (i() < 3) DO {
        FORM documentArticle MODAL CHECK;
        IF (formResult() == FormResult.ok) THEN {
            MESSAGE 'You pressed "ok"';
        } ELSE IF (formResult() == FormResult.close) THEN {
            MESSAGE 'You pressed "close"';
        };

        i() <- i() + 1;
    };
};

FORM testModalForm 'Тестовая форма'
    OBJECTS article=Article, i=INTEGER 'Новое имя товара ("Товар %N%"):' FIXED PANEL, store=Store, s=STRING[50] 'Новое имя склада:' FIXED PANEL
    PROPERTIES name(article), name(store), OBJVALUE(s), OBJVALUE(i)
;

showTestModalForm 'Показать док-модальную форму' = ACTION() {
    FORM testModalForm NEWSESSION DOCKEDMODAL;
    name(k) <- chosenString('s') WHERE k == chosenObject('store') IF (formResult() == FormResult.ok);
    name(k) <- [FORMULA STRING[30] '$1 || CAST($2 as char(20))']('Товар ', chosenInteger('i')) WHERE k == chosenObject('article') IF (formResult() == FormResult.ok);
};

setDefaultNames 'Задать имена по умолчанию' () = ACTION {
    FOR s IS Store DO {
        name(s) <- [FORMULA STRING[30] '\'Склад \' || CAST($1 as char(20))'](s);
    }
    FOR a IS Article DO {
        name(a) <- [FORMULA STRING[30] '\'Товар \' || CAST($1 as char(20))'](a);
    }
    FOR s IS Store DO {
        staticCaption(s) <- [FORMULA STRING[30] '\'Склад \' || CAST($1 as char(20))'](s);
    }
    FOR a IS Article DO {
        staticCaption(a) <- [FORMULA STRING[30] '\'Товар \' || CAST($1 as char(20))'](a);
    }
};

name(s) <- [FORMULA STRING[30] '\'Склад \' || CAST($1 as char(20))'](s) WHEN ASSIGNED(s IS Store);
staticCaption(s) <- [FORMULA STRING[30] '\'Склад \' || CAST($1 as char(20))'](s) WHEN ASSIGNED(s IS Store);

remindPasswordEmail 'Выслать пароль на этот email' (u, to) = ACTION EMAIL
//    FROM 'luxsoft@adsl.by'
    SUBJECT [FORMULA STRING[60] '\'Напоминание пароля для \' || $1'](emailContact(u))
    TO (to IF to IS STRING[200])
    CC 'some@someserv.net'
//    BCC 'luxsoft@adsl.by'
    INLINE remindUserPass OBJECTS u=(u AS CustomUser)
    ATTACH PDF
           NAME [FORMULA STRING[60] '\'ATTACH: Напоминание пароля для \' || $1'](emailContact(u))
           remindUserPass OBJECTS u=(u AS CustomUser)
    ;

FORM testEmailForm 'Тестирование EMAIL'
    OBJECTS s=STRING[100] 'Email:' FIXED PANEL, u=CustomUser
    PROPERTIES OBJVALUE(s), loginCustomUser(u), passwordCustomUser(u), emailContact(u), ADDOBJ(u), remindPasswordEmail(u, s) TODRAW s
;

stime 'Время' (store) = DATA TIME (Store) IN base;
sdate 'Дата' (store) = DATA DATE (Store) IN base;
sdatetime 'ДатаВремя' (store) = DATA DATETIME (Store) IN base;
sword 'Word' (store) = DATA WORDFILE (Store) IN base;
simage 'Image' (store) = DATA IMAGEFILE (Store) IN base;
spdf 'PDF' (store) = DATA PDFFILE (Store) IN base;
scustom 'Custom file' (store) = DATA CUSTOMFILE (Store) IN base;
sexcel 'Excel' (store) = DATA EXCELFILE (Store) IN base;
scolor 'Color' (store) = DATA COLOR (Store) IN base;

testRequestInput 'Тестирование REQUEST input' = ACTION(s) {
    CONFIRM 'Быть или не быть?';

    IF (confirmed()) THEN {
        REQUEST COLOR {
            REQUEST COLOR INPUT;
            IF (requestedColor() == #FF0000) THEN {
                requestedColor() <- #00FF00;
            }
            scolor(s) <- requestedColor() WHERE s IS Store;
        }
    } ELSE {
        MESSAGE 'Нет... ';
    }
};

loadf(s) = ACTION OPENFILE simage(s);
savef(s) = ACTION LOADFILE simage(s);

//fs = ABSTRACT BOOLEAN (Store);
//countF 'Кол-во фильтр. складов' = GROUP SUM 1 IF fs(s);
//setNameX 'Добавить X к имени' = ACTION () {
//    FOR fs(s) DO
//        name(s) <- 'X' + name(s);
//}

FORM storeArticle 'По складам'
    OBJECTS s=Store, a=Article
    PROPERTIES ssel=SELECTION(s), sname=name(s), obja=OBJVALUE(a), aname=name(a)
    PROPERTIES TODRAW s FORCE PANEL setDefaultNames(), copyStoreNameToArticles(s), copyStoreNameToArticle(s, a), copyStoreNameToArticleError(s, a), createNewStore(), showDocumentArticleModalForm(), showTestModalForm() TOOLBAR, testRequestInput(s) TOOLBAR
//    PROPERTIES() countF, setNameX
    PROPERTIES(s, a) SHOWIF storeIsHuge(s) incomeQuantity2, outcomeQuantity2
    PROPERTIES(s) storeSizeName, ssc1=storeSizeCode, storeIsHuge, stime, sdate, sdatetime, ssi=Features.simage, spdf, scustom, sexcel, testAbstractAction, editActionTest, loadf, savef, tstData, tstDestruct
    PROPERTIES(s, a) incomeQuantity, onlyIncomeQuantity, outcomeQuantity, foo, foo2 SHOWIF storeIsHuge(s), bar, foobar HEADER name(a), bar2, baz, baz2, balanceQuantity, testUnion HEADER name(s), testPartition, testFormula
    FILTERGROUP filters1
        FILTER 'Показывать только огромные склады' 'F10' storeIsHuge(s)
;

//fs(s) += [FILTER storeArticle.s](s);

countF 'Кол-во фильтр. складов' = GROUP SUM 1 IF [FILTER storeArticle.s](s);
orderF 'Порядок в группе объектов' (s) = PARTITION SUM 1 IF [FILTER storeArticle.s](s) ORDER [ORDER storeArticle.s](s), s;
setNameX 'Добавить X к имени' = ACTION () {
    LOCAL k = INTEGER ();
    k() <- 0;
    FOR [FILTER storeArticle.s](s) ORDER [ORDER storeArticle.s](s) DO {
        k() <- k() + 1;
        name(s) <- 'X' + k() + name(s);
    }
}
seekX 'Seek object' = ACTION () {
    REQUEST OBJECT s
        FORM storeArticle MODAL SHOWDROP;
    IF (formResult() == FormResult.ok) THEN {
        SEEK storeArticle.s requestedObject();
    }
    IF (formResult() == FormResult.drop) THEN {
        SEEK storeArticle.s NULL;
    }
}

EXTEND FORM storeArticle
    PROPERTIES() countF, setNameX, seekX
    PROPERTIES OBJVALUE(s)
    PROPERTIES(s) orderF
;

EXTEND FORM storeArticle
    PROPERTIES(s) ssw=sword AFTER ssi
;

EXTEND FORM storeArticle
    PROPERTIES(s) scolor AFTER ssw
;

FORM editStore 'Редактирование склада'
    OBJECTS s=Store FIXED PANEL
    PROPERTIES(s) name, storeSizeName, storeIsHuge, storeIsHuge2
    // To use this form as EDIT\DIALOG\LIST form for some class (for ex. store)
    // Use this syntax:
    //(EDIT | DIALOG | LIST) <className> OBJECT <objectName>
    EDIT Store OBJECT s
;

dateProp(store) = 2007_12_01 AND store IS Store;
dateTimeProp(store) = 2007_12_01_18:00 AND store IS Store;
timeProp(store) = 18:00 AND store IS Store;
variableDateTime(store) = DATA DATETIME (Store);
teststring(store) = '\n\'\\ghhgh\\"' AND store IS Store;

FORM TestDataPropForm 'Тест дат'
    OBJECTS store=Store
    PROPERTIES(store) dateProp, variableDateTime
    PROPERTIES dateTimeProp(store), teststring(store)
    PROPERTIES timeProp(store)
;

colorizeMatchingStoreSize (s, ss) = scolor(s) IF storeSize(s) == ss;
storeSizeString (s, ss) = DATA STRING[10] (Store, StoreSize);
storeSizeHeader (s, ss) = OVERRIDE name(ss) IF s IS Store AND ss IS StoreSize AND ss!=StoreSize.small, storeSizeString(s, ss);

FORM TestColumnGroupObjects 'Тест групп в колонках'
    OBJECTS ss=StoreSize, s=Store
    PROPERTIES name(ss), sizeCode(ss)
    PROPERTIES OBJVALUE(s), name(s), scolor(s), storeSizeCode(s)
    PROPERTIES storeSizeString(s, ss) COLUMNS (ss) HEADER sizeCode(ss) BACKGROUND colorizeMatchingStoreSize(s, ss) HEADER storeSizeHeader(s, ss)
;

colorizeElementWithNumberGreaterFour(element) = #5555ff IF numberNavigatorElement(element) > 4;

FORM TestTree 'Тест дерева (формы)'
    TREE forms e=NavigatorElement PARENT parentNavigatorElement
    PROPERTIES(e) OBJVALUE, captionNavigatorElement, sidNavigatorElement, numberNavigatorElement BACKGROUND colorizeElementWithNumberGreaterFour(e)

    TREE forms2 a=STRING[3], e2=NavigatorElement PARENT parentNavigatorElement
    PROPERTIES(a) OBJVALUE
    PROPERTIES(e2) OBJVALUE, captionNavigatorElement, sidNavigatorElement

    FILTERS stringEqualsAll(a)
;

DESIGN TestTree FROM DEFAULT {
    NEW trees {
        type = CONTAINERH;
        ADD forms.tree.box {
            fillHorizontal = 1;
            fillVertical = 1;
        }
        ADD forms2.tree.box {
            fillHorizontal = 1;
            fillVertical = 1;
        }
    }
}

FORM TestAggr 'Тест агрегаций'
    OBJECTS s=QuantityString
    PROPERTIES dateDocumentQuantityString(s), storeNameDocumentQuantityString(s), nameArticleQuantityString(s), DELETE(s)
;

FORM TestHeaders 'Тест заголовков'
    OBJECTS s=Store, a=Article
    PROPERTIES(s) name, storeSizeCode
    PROPERTIES(a) OBJVALUE, name
    PROPERTIES(s, a) SHOWIF storeIsHuge(s) incomeQuantity2, outcomeQuantity2
    PROPERTIES(s, a) incomeQuantity, outcomeQuantity, foobar HEADER name(a), testUnion HEADER name(s)
    FILTERGROUP filters1
        FILTER 'Показывать только огромные склады' 'F10' storeIsHuge(s)
;

DESIGN TestHeaders FROM DEFAULT {
    main {
        NEW vertical.box BEFORE functions.box {
            type = SPLITH;
            ADD s.box;
            ADD a.box;
        }
    }
}

FORM TestHotkeys 'Тест хоткеев'
    OBJECTS s=Store, a=Article
    PROPERTIES(s) ns=name, storeSizeCode
    PROPERTIES(a) OBJVALUE, na=name
    PROPERTIES(s, a) incomeQuantity, outcomeQuantity, foobar, testUnion
    FILTERGROUP filters1
        FILTER 'Показывать только огромные склады' 'F7' storeIsHuge(s)
    FILTERGROUP filters2
        FILTER 'Показывать только огромные склады' 'F3' storeIsHuge(s)
        FILTER 'Показывать только большие склады' 'F9' storeIsBig(s)
        FILTER 'Показывать только средние склады' 'F10' storeIsMedium(s)
        FILTER 'Показывать только маленькие склады' 'F11' storeIsSmall(s)
;

DESIGN TestHotkeys FROM DEFAULT {
    PROPERTY(ns) {
        editKey = 'F4';
    }

    PROPERTY(na) {
        editKey = 'F5';
    }
}

FORM TestTabs 'Тест табов'
    OBJECTS s=Store, a=Article
    PROPERTIES(s) OBJVALUE, name, storeSizeCode, name, storeSizeCode, name
    PROPERTIES(a) OBJVALUE, name, name, name, name
    PROPERTIES(s, a) incomeQuantity, outcomeQuantity, foobar, testUnion
;

DESIGN TestTabs FROM DEFAULT {
    NEW tabs.box BEFORE functions.box {
        type = TABBED;
        ADD s.box;
        ADD a.box;
    }
}

isEditable 'Включить редактирование' () = DATA SESSION BOOLEAN ();
isReadOnly 'Только чтение' () = TRUE AND NOT isEditable();
FORM TestReadOnlyIf 'Тест read-only'
    PROPERTIES isEditable()
    OBJECTS s=Store, a=Article
    PROPERTIES(s) READONLYIF isReadOnly() OBJVALUE, name, storeSizeCode
    PROPERTIES(a) READONLYIF isReadOnly() OBJVALUE, name
    PROPERTIES(s, a) READONLYIF isReadOnly() incomeQuantity, outcomeQuantity

    TREE elements e=NavigatorElement PARENT parentNavigatorElement
    PROPERTIES(e) READONLYIF isReadOnly() captionNavigatorElement, sidNavigatorElement, numberNavigatorElement, permitNavigatorElement, forbidNavigatorElement;
;

DESIGN TestReadOnlyIf FROM DEFAULT {
    NEW checkBox BEFORE functions.box {
        fillHorizontal = 1;
        caption = 'Включить read-only';

        ADD PROPERTY(isEditable());
    }
    NEW tabsContainer BEFORE functions.box {
        type = TABBED;
        NEW testGrids {
            caption = 'Таблицы';
            ADD s.box;
            ADD a.box;
        }

        NEW testTree {
            caption = 'Дерево';
            ADD elements.tree.box {
                fillHorizontal = 1;
                fillVertical = 1;
            }
        }
    }
}

onChangeStoreName() = ACTION {
    REQUEST INTEGER INPUT;

    i() <- requestedInteger();
    WHILE (i() > 0) DO {
        i() <- i() - 1;
        MESSAGE 'Tick';
    }
}

onEditStoreSizeCode() = ACTION {
    REQUEST INTEGER INPUT;

    i() <- requestedInteger() * 2;
    WHILE (i() > 0) DO {
        i() <- i() - 1;
        MESSAGE 'Tick';
    }
}

FORM SelectStoreSize
    OBJECTS ss=StoreSize
    PROPERTIES(ss) READONLY OBJVALUE, staticName, staticCaption
;

onChangeStoreSizeCode(store) = ACTION {
    REQUEST OBJECT ss
        FORM SelectStoreSize OBJECTS ss=storeSize(store) MODAL SHOWDROP;
    IF (formResult() == FormResult.ok) THEN {
        storeSize(store) <- requestedObject();
    }
    ASYNCUPDATE storeSizeCode(store);
}

onHelloWorld() = ACTION {
    MESSAGE 'Hello world!';
}

FORM TestOnActions 'Тест "ON actions"'
    OBJECTS s=Store
    PROPERTIES(s) OBJVALUE, name ON CHANGE onChangeStoreName(), ssc1=storeSizeCode ON EDIT onEditStoreSizeCode(), DELETE ON SHORTCUT 'Hello world!' onHelloWorld()
    PROPERTIES(s) onChangeStoreSizeCode, ssc2=storeSizeCode ON CHANGE onChangeStoreSizeCode(s)
;

DESIGN TestOnActions FROM DEFAULT {
    PROPERTY(ssc1) {
        caption = 'onEditTest';
    }

    PROPERTY(ssc2) {
        caption= 'onChangeTest';
    }
}

sinteger 'Integer' (store) = DATA INTEGER (Store);
slong 'Long' (store) = DATA LONG (Store);
sdouble 'Double' (store) = DATA DOUBLE (Store);
snumeric 'Numeric' (store) = DATA NUMERIC[14,3] (Store);
sboolean 'Boolean' (store) = DATA BOOLEAN (Store);
stext 'Text' (store) = DATA TEXT (Store);
sstring 'String' (store) = DATA STRING[10] (Store);
svarstring 'VarString (no rtrim)' (store) = DATA VARSTRING[10] (Store);

textToInt 'string->integer' (store) = INTEGER(sstring(store));
longToString 'long->string' (store) = STRING[15](slong(store));

nameDate 'name:date' (store) = name(store) + ':' + sdate(store);

sumDoubleInt 'double+integer' (store) = sdouble(store) + sinteger(store) MINCHARWIDTH 25;
sumDoubleNumeric 'double+numeric' (store) = sdouble(store) + snumeric(store) MINCHARWIDTH 25;
sumNumericInt 'numeric+integer' (store) = snumeric(store) + sinteger(store) MINCHARWIDTH 25;
sumIntLong 'integer+long' (store) = sinteger(store) + slong(store) MINCHARWIDTH 25;
sumStringBoolean 'name:boolean' (store) = name(store) + ':' + sboolean(store) MINCHARWIDTH 25;
sumTextInteger 'text+integer' (store) = stext(store) + sinteger(store) MINCHARWIDTH 25;
sumNameString 'name+string' (store) = name(store) + sstring(store) MINCHARWIDTH 25;

subDoubleInt 'double-integer' (store) = sdouble(store) - sinteger(store) MINCHARWIDTH 25;
subDoubleNumeric 'double-numeric' (store) = sdouble(store) - snumeric(store) MINCHARWIDTH 25;
subNumericInt 'numeric-integer' (store) = snumeric(store) - sinteger(store) MINCHARWIDTH 25;
subIntLong 'integer-long' (store) = sinteger(store) - slong(store) MINCHARWIDTH 25;

multDoubleInt 'double*integer' (store) = sdouble(store) * sinteger(store) MINCHARWIDTH 25;
multDoubleNumeric 'double*numeric' (store) = sdouble(store) * snumeric(store) MINCHARWIDTH 25;
multNumericInt 'numeric*integer' (store) = snumeric(store) * sinteger(store) MINCHARWIDTH 25;
multIntLong 'integer*long' (store) = sinteger(store) * slong(store) MINCHARWIDTH 25;

concatNull(store) = name(store) + ', ' + sstring(store) + ', ' + slong(store);
concatNotNull(store) = CONCAT ', ', name(store), sstring(store), slong(store);
concatToText(store) = CONCAT ', ', stext(store), name(store), sstring(store), slong(store);
concatToVar(store) = CONCAT ', ', name(store), sstring(store), slong(store), '<const>' IF store IS Store;
concatVarNull(store) =  'name: ' + name(store) + '; long: ' + slong(store) + '; string: ' + sstring(store);
concatVarNotNull(store) = CONCAT '', 'name: ' IF store IS Store, name(store), '; long: ' IF store IS Store, slong(store), '; string: ' IF store IS Store, sstring(store);

FORM TestOperators 'Тест операторов CAST, CONCAT, "+-*"'
    OBJECTS s=Store
    PROPERTIES(s) OBJVALUE, name, sdate, sinteger, slong, sdouble, snumeric, sstring, svarstring, sboolean
    PROPERTIES(s) stext
    PROPERTIES(s) FORCE PANEL textToInt, longToString
    PROPERTIES(s) FORCE PANEL sumNameString, nameDate, sumDoubleInt, sumDoubleNumeric, sumNumericInt, sumIntLong, sumStringBoolean, sumTextInteger
    PROPERTIES(s) FORCE PANEL concatNull, concatNotNull, concatVarNull, concatVarNotNull, concatToText, concatToVar
    PROPERTIES(s) FORCE PANEL subDoubleInt, subDoubleNumeric, subNumericInt, subIntLong
    PROPERTIES(s) FORCE PANEL multDoubleInt, multDoubleNumeric, multNumericInt, multIntLong
;

DESIGN TestOperators FROM DEFAULT {
    s.box {
        fillVertical = 1;
    }

    PROPERTY(stext) {
        minimumSize = ( -1, 17);
        preferredSize = ( -1, 17);
        maximumSize = ( -1, 17);
    }

    NEW tabsContainer AFTER s.box {
        type = TABBED;
        fillVertical = 1;

        NEW castTab {
            caption = 'cast, concat';
            ADD PROPERTY(textToInt);
            ADD PROPERTY(longToString);

            ADD PROPERTY(concatNull);
            ADD PROPERTY(concatNotNull);
            ADD PROPERTY(concatVarNull);
            ADD PROPERTY(concatVarNotNull);
            ADD PROPERTY(concatToText);
            ADD PROPERTY(concatToVar);
        }
        NEW sumTab {
            caption = 'sum';
            ADD PROPERTY(sumStringBoolean);
            ADD PROPERTY(sumIntLong);
            ADD PROPERTY(sumNumericInt);
            ADD PROPERTY(sumDoubleNumeric);
            ADD PROPERTY(sumDoubleInt);
            ADD PROPERTY(nameDate);
            ADD PROPERTY(sumNameString);
            ADD PROPERTY(sumTextInteger);
        }

        NEW subTab {
            caption = 'sub';
            ADD PROPERTY(subIntLong);
            ADD PROPERTY(subNumericInt);
            ADD PROPERTY(subDoubleNumeric);
            ADD PROPERTY(subDoubleInt);
        }

        NEW multTab {
            caption = 'mult';
            ADD PROPERTY(multIntLong);
            ADD PROPERTY(multNumericInt);
            ADD PROPERTY(multDoubleNumeric);
            ADD PROPERTY(multDoubleInt);
        }
    }
}

FORM TestLayout 'Тест SimplexLayout'
    OBJECTS s1=Store, s2=Store, a=Article
    PROPERTIES(s1) OBJVALUE, name, storeSizeName, sdate, sinteger, slong, sdouble
    PROPERTIES(s2) OBJVALUE, name, storeSizeName, sdate, sinteger, slong, sdouble
    PROPERTIES(a) OBJVALUE, name
    PROPERTIES(s2, a) incomeQuantity, outcomeQuantity, balanceQuantity
;

DESIGN TestLayout FROM DEFAULT {
    NEW horzSplit BEFORE functions.box {
        type = SPLITH;

        NEW vertSplit {
            type = SPLITV;

            ADD s2.box;
            ADD a.box;
            POSITION a.box TO THE BOTTOM s2.box;
        }

        ADD s1.box;
    }
}

//////////////// INDEX STATEMENT //////////////////
// Syntax:
// INDEX propertyName1 [, ..., propertyNameN];
INDEX quantity;

//////////////// WINDOW STATEMENT /////////////////
// Add new window statement
// Syntax:
// WINDOW (MENU | PANEL | TREE | TOOLBAR) <name> '<caption>' [ option [, option ...] ]
// option ::=   HIDETITLE |
//              HIDESCROLLBARS |
//              DRAWROOT |
//              (VERTICAL | HORIZONTAL) |
//              (LEFT | RIGHT | TOP | BOTTOM) |
//              POSITION(x, y, w, h) |
//              HALIGN( LEFT | CENTER | RIGHT ) |
//              VALIGN( TOP | CENTER | BOTTOM ) |
//              TEXTHALIGN( LEFT | CENTER | RIGHT ) |
//              TEXTVALIGN( TOP | CENTER | BOTTOM )
WINDOW TREE objectsWindow 'Объекты' POSITION(0, 6, 20, 64) DRAWROOT;

//Hide window
HIDE WINDOW System.log;
HIDE WINDOW System.relevantForms;
HIDE WINDOW relevantClassForms;

//////////////// NAVIGATOR STATEMENT /////////////////
//настройка навигатора
NAVIGATOR {
    // чтобы добавить существующий элемент в другой элемент используется команда следующего вида
    // ADD <имя> ['<новый заголовок>'] [IN <имя родителя>] [((AFTER | BEFORE) <имя2>) | FIRST] [TO <новое окно>];
    // при этом по умолчанию он будет добавлен в элемент текущей области видимости
    // (при использовании прямо внутри NAVIGATOR - он будет добавлен в baseElement)
    //
    // для создания нового элемента используется команда:
    // NEW <имя> [ACTION <имя экшена>] '<заголовок>' [IN <имя родителя>] [((AFTER | BEFORE) <имя2>) | FIRST] [TO <имя окна>] [IMAGE <путь к иконке>];

    security {
        NEW element1 'Element 1' AFTER securityPolicy;
        NEW element2 'Element 2' BEFORE securityPolicy;
    }

    ADD storeArticle IN element2;

    NEW outer 'Outer element' IN element1 {
        ADD dictionaries 'Dictionaries' {
            NEW underForm 'under form element';
        }

        ADD element2;
    }

    //при создании элемента можно указать окно для него
    NEW testNavigators '-Тестовые навигаторы-' IN security AFTER securityPolicy TO root;

    // также можно просто настраивать существующий элемент без его перемещения
    testNavigators 'Тестовые навигаторы' {
        ADD element1 {
            //...
        }
        ADD element2;
        ADD underForm;
        ADD editStore;
        ADD testModalForm;

        //если задано имя действия, то создаться элемент для запуска этого действия
        NEW testNavigatorAction ACTION testAction 'Показать "По документам" 3 раза' FIRST;
    }
    // так можно отдельно настроить окно, в которое будет рисоваться элемент
    root TO root;
    testNavigators TO toolbar;
    administration TO toolbar;
    account TO toolbar;
    objects TO objectsWindow;

    ADD dictionaries 'Словари' IN regionalData AFTER daysOffForm;

    NEW tests 'Тесты' TO toolbar {
        ADD TestDataPropForm;
        ADD TestColumnGroupObjects;
        ADD TestTree;
        ADD TestAggr;
        ADD TestHeaders;
        ADD TestHotkeys;
        ADD TestEvalActionForm;
        ADD TestTabs;
        ADD TestReadOnlyIf;
        ADD TestOnActions;
        ADD TestOperators;
        ADD TestLayout;
    }

    ADD storeArticle;
    ADD documentArticle;
}

//////////////// DESIGN STATEMENT /////////////////
//При создании дизайна по умолчанию создаётся набор контейнеров и компонентов с определёнными именами
//
//Соответсвие между вызовами в Java и именами доступными в настройке дизайна показаны ниже
//(также указан тип объекта - контейнер или компонент):
//
//getMainContainer => CONTAINER main
//
//getTreeContainer => CONTAINER treeName.tree.box
//get(TreeGroupEntity) => COMPONENT treeName.tree
//
//getGroupObjectContainer => CONTAINER groupName.box
//getPanelContainer => CONTAINER groupName.panel
//get(GroupObjectEntity)
//    .grid => COMPONENT groupName.grid
//    .showType => COMPONENT groupName.showType
//getGridContainer => CONTAINER groupName.grid.box
//getControlsContainer => CONTAINER groupName.controls
//getFilterContainer => CONTAINER groupName.filters
//
//getGroupPropertyContainer(PropertyGroup)
//     для групп данного модуля =>  CONTAINER groupName.propGroupName
//     для групп других модулей =>  CONTAINER groupName.moduleName_propGroupName
//
//get(ObjectEntity)
//    .classChooser => COMPONENT objectName.classChooser
//
//getRegularFilterGroup => COMPONENT filters.filterName
//
//get*Function => COMPONENT functions.*
//getFormButtonContainer=> CONTAINER functions.box
//
//get(PropertyDrawEntity) => COMPONENT PROPERTY(propSelector(...))


DESIGN storeArticle FROM DEFAULT {
    // Чтобы добавить контейнер в другой контейнер используется команда '(ADD | NEW ) <имя> [IN <имя2>] [((AFTER | BEFORE) <имя3>) | FIRST]'.
    // При использовании NEW контейнер будет создан, если компонент с таким именем уже существовал, то будет ошибка.
    // При этом по умолчанию он будет добавлен в контейнер текущей области видимости
    // (при использовании прямо внутри DESIGN - он будет добавлен в main контейнер)
    NEW newContainer {
        // будет добавлен в newContainer, т.к. находится в его области видимости
        NEW child1 {
            // будет добавлен в child1, т.к. находится в его области видимости
            NEW child11;
        }

        // будет добавлен в child11, т.к. явно указано куда добавлять
        NEW child2 IN child11;

        // будет добавлен в child1, перед child11, т.к. это явно указано
        NEW child3 IN child1 BEFORE child11;

        // будет добавлен в child1, после child11, т.к. это явно указано
        NEW child4 IN child1 AFTER child11;

        NEW child5;

        // для задания intersections используется конструкция вида:
        // POSITION <имя1> (TO THE LEFT | TO THE RIGHT | TO THE BOTTOM | TO THE RIGHTBOTTOM | TO NOT INTERSECT) [<имя2>]
        // например следующая команда добавит intersection для расположения child1 слева от child5;
        POSITION child1 TO THE LEFT child5;

        // при этом компоненты должны быть в одном контейнере, т.е. следующая команда выдаст ошибку:
        // POSITION child2 TO THE LEFT child3;

        ADD child5 {
            // если второе имя емя не указано, то будет использован компонент из данной области видимости
            // т.е. в данном месте команда 'POSITION child1 TO NOT INTERSECT child5' равносильна просто:
            POSITION child1 TO NOT INTERSECT;
        }
    }
    // для удаления компонента используется команда REMOVE <имя> [CASCADE];
    // если CASCADE не указано, то удалится только сам контейнер,
    // а вложенные контейнеры будут доступны для дальнейшей вставки в другие места обычным образом
    // если же CASCADE указано, то удалится сам контейнер со всем вложенными

    // REMOVE newContainer;
    REMOVE newContainer CASCADE;

    // для настройки свойств используется конструкция вида
    //  <имя свойства> = <значение>;
    // при этом будет изменено свойство объекта в текущей области видимости
    // для верхней области видимости будет изменяться сама форма
    //
    // все названия доступных свойств объектов совпадают с таковыми в Java
    // кроме того вложенные свойства constraints.* и component.design.* доступны напрямую
    // например в Java: design.overridePageWidth = 3000;
    // соотвествует
    overridePageWidth = 3000;

    // для формы есть одно исключение для единообразия с другими объектами - вместо caption используется title
    // т.е. в Java: richDesign.caption = "Справочник складов"; соотвествует
    title = 'Справочник складов';


    // для того, чтобы просто настроить свойства объекта без добавления его в текущий контейнер,
    // используется следующая конструкция
    main {
        title = 'Главный контейнер';

        ADD functions.box BEFORE s.box;

        a.box {
            title = 'Артикль';
            fillHorizontal = 2.5;
        }

        s.box {
            // в Java: someComponent.constraints.fillVertical = 0.3; соответсвует
            fillVertical = 0.2;

            //здесь всё так же можно применять команды ADD, POSITION и т.д.
            NEW child1 {
                // так контейнер будет отображаться в виде табов
                // соответсвует в Java: container.type = ContainerType.TABBED_PANE;
                type = TABBED;
                // а так - в виде SplitPane'а: type = SPLITV
                //                             type = SPLITH

                NEW child2;

                // настраивать объекты можно в любой области видимости - это ни на что не повлияет
                s.box {
                    fillVertical = 0;
                }
            }
            REMOVE child1 CASCADE;
        }
    }

    //для настройки GroupObjectView используется следующая конструкция
    GROUP(s) {
        tableRowsCount = 10;
        needVerticalScroll = FALSE;
    }


    //для доступа к компоненту свойства (PropertyDrawView) используется следующая конструкция
    //здесь просто выберется 1й компонент для конкретного свойства
    PROPERTY(bar) { caption = 'Барр'; }

    //здесь - компонент для свойства с определённым мэппингом
    PROPERTY(storeSizeName(s)) { caption = 'Имя размера склада'; }

    PROPERTY(foo(s, a)) {
        focusable = FALSE;
        panelLabelAbove = TRUE;
        caption = 'This is foo\'s caption!';
    }

    // настройка некоторых других свойств
//    PROPERTY(name(a)) {
    PROPERTY(aname) {
        // настройка свойств, соответсвующих клавишам
        showEditKey = TRUE;
        editKey = 'ctrl F6';
        caption = 'Имя (a)';

        // шрифт
        headerFont = 'Tahoma bold italic 15';
        headerFont = 'Tahoma bold 13';
        headerFont = 'Tahoma 12';
    }

    NEW setupEx {
        // Dimension
        minimumSize = (100, 200);

        // constraints.childConstraints
        childConstraints = TO THE LEFT;
        childConstraints = TO THE RIGHT;
        childConstraints = TO NOT INTERSECT;

        //Insets
        insetsInside = ( -100, -200, 300, 400);
    }
    REMOVE setupEx;

    s.toolbar {
//        visible = FALSE;
        showPrintGroupButton = FALSE;
        showPrintGroupXlsButton = FALSE;
    }
}

//////////////// METACODE STATEMENT /////////////
// Syntax:
// META codeName([param1, ..., paramN]) metacode END
//
// Metacode usage syntax:
// @codeName([[param1], ..., [paramN]]);
//
// concatenation operator: ##
// concatenation capitalize operator: ###

META metaCodeSample(name)
    CLASS name##Class;
    GROUP name ### group;
END

META metaCodeSample(name, name2)
    CLASS name##Class##name2;
END

@metaCodeSample(TestName1);
@metaCodeSample(TestName2);

@metaCodeSample(TestName1, TestName2);

//////////////// TABLE STATEMENT ////////////////
// Syntax:
// TABLE name(className1, ..., classNameN);
TABLE documentArticle(Document, Article);

fib(i, to) = GROUP MAX f IF (RECURSION i==1 AND f==0 AND f1==1 AND to IS INTEGER
                STEP i==$i+1 AND f==$f+0+$f1 AND f1==$f AND i<to) BY i, to;

//fib(i, to) = RECURSION 1 IF (i==0 OR i==1) AND to IS INTEGER STEP 1 IF (i==$i+1 OR i==$i+2) AND i<to;
FORM fibForm 'Числа фибоначи'
OBJECTS to = INTEGER FIXED PANEL, i=INTEGER
PROPERTIES OBJVALUE(to), OBJVALUE(i), fib(i, to)
FILTERS fib(i, to)
;

CLASS Newtest;
newtf = DATA INTEGER (Newtest);
ottf = DATA INTEGER (Newtest);
divtf(a) = newtf(a) / ottf(a) PERSISTENT;

FORM newTestForm 'Test Exception'
 OBJECTS x = Newtest
 PROPERTIES(x) ADDOBJ, newtf, ottf
;


NAVIGATOR {
    ADD fibForm;
    ADD caseTest;
    ADD newTestForm;
    ADD testChangeClass;
    ADD testAddObject;
}