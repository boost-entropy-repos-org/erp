<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Документ без названия</title>
<style type="text/css"> 
body  {
	font: 100% Verdana, Arial, Helvetica, sans-serif;
	background: #666666;
	margin: 0;
	padding: 0;
	text-align: left; 
	color: #000000;
	background: #FFFFFF;
}

.floatright {
    float: right;  /*Обтекание по правому краю*/
}

.samplecode {
	background-color: #CCCCCC;
}

.article {
	margin-left: 15px;
}

.clearfloat {
	clear:both;
}
</style>

</head>

<body>
<div class="article">
  <h1>Развитие средств разработки</h1>
		<div class="article">
        <h2>Императивность и декларативность</h2>
        <p>	Исторически, разработка приложений эволюционировала путем увеличения уровня абстрагирования, на котором строились приложения. Каждое новое поколение языков скрывает детали и сложность всех уровней используемых внутри. В этом смысле разработка приложений развивается от <i>императивных</i> подходов, когда разработчик полностью описывает, как решать поставленную задачу, к <i>декларативным</i>, когда разработчик описывает задачу в некоторой модели, а уже система сама определяет, как эффективно ее решить. </p>
        <p>Очевидно что по всем нефункциональным требованиям декларативные подходы намного превосходят императивные. Исключение составляет разве что производительность, в силу того что в некоторых случаях человек может учитывая особенности использования внутренних уровней, реализовать решение задачи быстрее. Однако если это различие не составляет порядки (что бывает в 99% случаев), общая эффективность системы (как соотношение результата к затраченным усилиям) использующих декларативные подходы все равно будет существенно выше. </p>
    <p>Стоит отметить, что, естественно, сложность создания декларативных средств разработки несравнимо выше. Как с точки зрения создания модели описания задачи, которая обязательно должна обладать свойствы полноты, так и с точки зрения реализации алгоритмов, решающих задачи в созданной модели.	Однако эта сложность ложится на плечи разработчиков платформы, тогда как в противном случае она оказалась бы на разработчиках конкретных систем.</p>
    	</div>
		<div class="article">
        <h2>Эволюция</h2>
        <p><img src="evolution.jpg" /> </p>
        <div class="article">
        <h3>1-е и 2-е поколения языков</h3>
        <p>Первыми императивными языками были <i>машинные языки</i>. Эти языки были крайне просты, что снижало нагрузку на компьютеры, однако затрудняло написание крупных программ. </p>
        <p>Следующим поколением языков можно считать <i>языки ассемблера</i>. В отличие от языка машинных кодов, позволяет использовать более удобные для человека мнемонические (символьные) обозначения команд. </p>
        </div>
        <div class="article">
        <h3>Структурное программирование</h3>
        <p><i>Структурное программирование</i> стало третьим и достаточно революционным поколением в эволюции разработки приложений. Ключевые нововведения:</p>
		  <ul>
			<li>Появление в нем элементов декларативного (функционального) программирования - процедур и функций</li>
			<li>Более четкая формализация потока выполнения команд  в виде ветвлений и циклов</li>
			<li>Возможность использования структур данных</li>
		  </ul>
          <p>Отметим, что появление структур данных (пользовательских типов) де-факто можно считать появлением классов.</p>        
        </div>
        <div class="article">
        <h3>Объектно-ориентированное программирование</h3>
  <p>Последней в этой ветке и соответственно самой современной на данный момент парадигмой является объектно-ориентированная программирование (ООП). Несмотря на сложившийся стереотип о ней как о некоторой концептуально новой парадигме, ООП по большому счету является “всего лишь” надстройкой над структурным программированием, привнося в него такие понятия как безопасность и, что более важно, наследование. Ценность последнего, безусловно, сложно переоценить, однако то, в каком виде оно используется в ООП, вызывает немало вопросов. </p>
		<div class="article">
        <h4>Привязка атрибутов к одному объекту</h4>
  <p>Так одной из главных ошибок при создании ООП была <b>привязка атрибутов к одному объекту</b>. Если в структурном программировании (как впрочем, и в математике) в понятии функции все параметры абсолютно равноправны, методология предложенная ООП требует выделить среди них один “главный” и присвоить функцию классу именно этого параметра. Как следствие это приводит сразу к нескольким проблемам: </p>
  <h5>Неоднозначное определение класса для метода</h5>
  <p>Определение &quot;главного&quot; параметра не всегда является таким уж однозначным процессом. Есть конечно очевидные случаи: когда один объект - изменяемый (mutable), а остальные - нет (во всяком случае в контексте функции), или же только один параметр относится к модулю, к которому относится реализуемая функция, но иногда решение приходится принимать чуть ли не жребием. Так например, если необходимо реализовать функцию остаток(Товар, Склад), то сделать это можно двумя абсолютно одинаковыми способами: </p>
        <pre class="samplecode">
        
        	class Товар {
            	Кол-во остаток(Склад склад);
            };
            
            или
            
            class Склад {
            	Кол-во остаток(Товар товар);
            };
        </pre>
        <h5>Невозможность множественного полиморфизма</h5>
  <p>Также перед разработчиком может стоять более сложная задача - обеспечить полиморфизм сразу от двух параметров функции. В этом случае в ООП приходится (опять таки аналогично первой проблеме) определять в каком порядке пойдет полиморфизм - например сначала по 1-му параметру, затем по 2-му. Потом в классе 2-го параметра приходится создавать вспомогательные методы реализующие требуемый функционал в зависимости от классов 1-го параметра, а соответственно в основном методе 1-го класса полиморфно определять какой именно вспомогательный метод необходимо вызвать. Так &quot;классический&quot; пример столкновения астероида с космическим кораблем в ООП будет выглядеть следующим образом:</p>
  <pre class="samplecode">
            abstract class Thing {
                 abstract void collide(Thing thing);
                 
                 abstract void collideAsteroid(Asteroid asteroid);
                 abstract void collideSpaceShip(SpaceShip spaceShip);
            };
            class Asteroid extends Thing {
                 void collide(Thing thing) {
                      thing.collideAsteroid(this);
                 }
                 void collideAsteroid(Asteroid asteroid) {
                      System.out.println(&quot;Asteroid 2 hits asteroid 1&quot;);
                 }
                 void collideSpaceShip(SpaceShip spaceShip) {
                      System.out.println(&quot;Asteroid 2 hits spaceShip 1&quot;);
                 }
            };
            class SpaceShip extends Thing {
                 void collide(Thing thing) {
                      thing.collideSpaceShip(this);
                 }
                 void collideAsteroid(Asteroid asteroid) {
                      System.out.println(&quot;SpaceShip 2 hits asteroid 1&quot;);
                 }
                 void collideSpaceShip(SpaceShip spaceShip) {
                      System.out.println(&quot;SpaceShip 2 hits spaceShip 1&quot;);
                 }
            };       	
        </pre>
        <p>P.S.: Этот же пример можно конечно реализовать через if и instanceof, однако использование последнего оператора нарушает принципы ООП, кроме того принципиально проблему не решает.</p>
  <p>Отметим, что если количество классов или параметров относительно которых необходимо обеспечить полиморфизм становится больше, то увеличивается и количество вспомогательных методов, причем происходит это в геометрической прогрессии.</p>
  <h5>Нарушение модульности</h5>
        <p>В большинстве современных реализаций ООП, в модули объединяются классы, а не методы. Соответственно реализовать функцию полиморфную от параметра из другого модуля, не нарушая модульность, невозможно.</p>
        <p>P.S.:Аналогичные проблемы возникают и в отсутствие полиморфизма, но их в определенной степени можно решать при помощи static методов. </p>
  <p>Очевидно, что эта ошибка является следствием аналогичной ошибки для полей данных, которые еще со времен структурного программирования принадлежали одной структуре. Там это в свою очередь было обусловлено особенностями реализации, но мы не акцентировали внимание на этой проблеме, потому как структурное программирование рассматривалось как переходный этап, несовершенный по определению. Однако ООП унаследовало эту особенность, не предложив никакого решения. В итоге с полями данных ситуация еще хуже чем с методами – их &quot;множественность&quot; вообще не предусмотрена в ООП, и для того чтобы реализовать поле скажем от двух объектов, приходится использовать вспомогательный прикладной интерфейс Map. Так в случае с остатком, если рассмотреть его как поле (первичные данные), реализовать это можно следующими двумя (опять-таки одинаковыми) способами: </p>
  <pre class="samplecode"> 
        	class Товар { 
            	Map&lt;Склад,Кол-во&gt; остаток;
            };
            
            или 
            
            class Склад {
            	Map&lt;Товар,Кол-во&gt; остаток;
            };
	</pre>
    <p>Соответственно для полей от трех объектов, необходимо создавать Map'ы, значения которых будут другие Map'ы и так далее. Заметим, что при таком подходе на разработчика ложится ответственность как за определение порядка Map (в частности &quot;главного&quot; класса), так и за выбор конкретных реализаций этого интерфейса. </p>
  <p>P.S.: Существуют библиотеки сторонних разработчиков (например для Java - MultiKeyMap), которые позволяют делать Map'ы для нескольких ключей и отчасти решать описанную проблему, однако они (как и Map) не входят не то что в ООП, а даже и в стандартные технологии.</p>
  	</div>
	<div class="article">
    <h4>Разделение методов и полей данных</h4>
    <p>Также немаловажен сам факт <b>разделения атрибутов на методы и поля данных</b>. Строго говоря, с точки зрения субьекта, ему все равно хранится необходимая ему информация как поле в объекте(ах) или рассчитывается по какому-нибудь алгоритму, однако с точки зрения ООП это различие является существенным.</p>
    </div>
    <div class="article">
    <h4>Статическая классификация</h4>
  <p>Также одним из ограничений ООП является то, что класс объекта определяется при его создании и не может изменяться в дальнейшем. В жизни же свойства объекта существуют только относительно субъекта, который с ним взаимодействует. Так например, когда у человека в руках появляется некоторый объект то, что с ним можно делать он узнает не сразу, а в процессе его изучения, выясняя все новые и новые возможности. В бизнес-решениях в качестве примера такой ситуации можно рассмотреть статусность - бизнес-процесс, в котором объект (документ, товар) проходит через несколько “рук”, обрастая все новой и новой информацией.</p>    
  	</div>
    <div class="article">
    <h4>Выводы</h4>
    <p>Подытоживая все вышесказанное, ирония в том, что главная проблема объектно-ориентированного программирования в его “объектно-ориентированности”. Функциональное программирование с добавлением в него возможностей наследования выглядит в этом смысле гораздо интереснее. Основным (и одним из немногих) примером такого подхода является язык Common Lisp. Логика классов в нем представлена в виде технологии CLOS, в которой методы отвязаны от классов (представляя из себя обычные функции), а полиморфизм обеспечивается при помощи специальной конструкции defgeneric, позволяющей объединять несколько методов в один. При этом в процессе выполнения в зависимости от конкретных классов параметров виртуальная машина сама определяет какой именно из &quot;объединенных&quot; методов вызывать. Такой механизм принято называть <i>множественной диспетчеризацией</i> (в противовес одиночной диспетчеризации ООП). </p>
    <p>Заметим, что при множественной диспетчеризации может возникать проблема неоднозначного выбора конкретного метода. Абсолютно аналогичная проблема возникает и при множественном наследовании, которая в большинстве случаев решается или отказом от него (Java, C#) или необходимостью задавать реализацию в явном виде (C++). В CLOS же используется более простое и возможно более элегантное решение - учитывать в каком именно порядке идет &quot;перегрузка&quot; методов и наследование классов (аналогичное решение применяется и в Python, Perl, OCaml, но именно для наследования, так как множественную диспетчеризацию они не поддерживают).</p>
    <p> Стоит сказать, что во многих современных объектно-ориентированных языках наметилась тенденция к включению поддержки множественной диспетчеризации в саму спецификацию языка (а не в виде расширений существующих уже давно). Так это касается разрабатываемых версий Perl и C# (6 и 4.0 соответственно). Также поддержка этого механизма была реализована в Groovy, по сути являющемся расширением Java. Однако надо понимать, что множественная диспетчеризация противоречит самим принципам &quot;традиционного&quot; ООП, поэтому его поддержка в наиболее популярных на сегодняшний день языках носила и будет носить &quot;инородный&quot; характер, и соответственно при создании вспомогательных технологий (как например ORM) никогда не будет приниматься во внимание. Поэтому если говорить о дальнейшем развитии, то более перспективными можно считать уже упомянутые функциональные языки с объектно-ориентированными расширениями, такие как  Common Lisp. Однако их недружелюбность в плане синтаксиса, описания и дополнительных возможностей, а также некоторое другие особенности (как например каррирование) препятствует их популяризации и, как следствие, развитию. </p>
  <p>Кроме того множественная диспетчеризация не панацея, она не решает вторую и никак не связана с третьей проблемой. При этом как раз их решение лежит на поверхности. Так вторую проблему можно было бы легко решить, сделав поле частным случаем функции, у которой вместо реализации стояла бы &quot;опция&quot; initial, что означало бы, что ее значение хранится в памяти и соответственно эту функцию можно присваивать в процессе выполнения программы при помощи оператора =. Проблема классификации же решается простым обобщением операции добавления (и отчасти удаления) до операции изменения класса (этот подход более подробно будет раскрыт в описании самой платформы). Но это все лирика - даже реализовав бы такой язык, мы бы не устранили еще один из основных недостатков ООП - его высокую императивность, которая в частности привела к появлению SQL.  </p>
  </div>
  </div>
  <div class="article">
  <h3>SQL</h3>
  <p>Одним из важных следствий низкой декларативности ООП является отсутствие постоянно хранимых реализаций. Если представить что все объекты будут храниться, скажем, не в оперативной памяти, а сразу на жестком диске, скорость доступа к которому отличается на несколько порядков, время выполнения такой программы будет катастрофически большим.  Таким образом, если виртуальная машина по какой-то причине закроется, все накопленные данные будет утеряны. Для решения  этой проблемы было неизбежным появление специальных систем работы с постоянно хранимыми данными, с другими более декларативными подходами в разработке. Это и произошло в 80-х годах с появлением SQL и первых СУБД его поддерживающих. Однако он пришел не на смену ООП, а лишь как его дополнение, для реализации конкретных функций работы с хранимыми данных, обладая при этом массой недостатков :</p>
  <ul>
  <li>SQL  оперирует не объектами и их свойствами, а чисто математическими понятиями матриц (таблиц и строк), и уже даже по этой причине не может использоваться сам по себе. Как следствие в нем естественно отсутствует понятие наследования (не путать с наследованием таблиц), допускаются повторяющиеся строки и т.п.</li>
  <li>Высокая избыточность самого SQL, в частности:
  		<ul>
          <li>Неоднозначное определение ключа:
            <pre class="samplecode"> 
                    SELECT A.key FROM A JOIN B ON A.key = B.key
                    
                    SELECT B.key FROM B JOIN A ON B.key = A.key
		    	</pre>
               	<p>Два верхних запроса абсолютно эквивалентны, хотя и написаны по-разному. В SQL (как и в ООП) приходится определять “главные” таблицы, ключи которых будут ключами запроса, а затем связывать их с остальными таблицами, хотя семантически все они абсолютно равноправны. Более однозначной в этом смысле была бы логика, когда ключи запроса создавались бы вместе с запросом, а затем уже использовались для связывания таблиц. Так следующий запрос симметричен относительно таблиц A и B: </p>
                <pre class="samplecode"> 
					SELECT {key1} JOIN A ON A.key = key1 JOIN B ON B.key = key1
		    	</pre>
          </li>
            <li>Разделение логики отборов на условия WHERE и типы JOIN:                        
            <p>В SQL то, какие данные попадут в выборку, определяется сразу двумя конструкциями : оператором WHERE  и типами JOIN. Объяснить это разделение можно разве что ленью разработчиков первых реализаций СУБД и соответственно SQL, потому как более простое и элегантное решение лежит на поверхности: ввести условие вхождения в Join (IN JOIN) и соответственно использовать его в логике Where.  Продемонстируем это на примере, возьмем следующие эквивалентные запросы:</p>
                <pre class="samplecode"> 
					SELECT A.key,D.field FROM A LEFT JOIN (SELECT COALESCE(B.key,C.key) AS key, B.field+C.field AS field FROM B 
                    										FULL JOIN C ON B.key=C.key) D ON A.key=D.key
                                                            
					SELECT A.key,B.field+C.field FROM A LEFT JOIN B ON A.key=B.key LEFT JOIN C ON A.key=C.key 
		    	</pre>
                В “идеальной” логике этот запрос выглядел бы следующим образом :
                <pre class="samplecode"> 
	                SELECT A.key,B.field+C.field FROM A JOIN B ON A.key=B.key JOIN C ON A.key=C.key WHERE IN JOIN A
				</pre>                
          </li>
            <li>Трехзначная булева логика:
            <p>Расширение булевой логики значением Unknown также сложно назвать таким уж однозначным. Логика Unknown (как может True, а может False) является следствием логики NULL, которая подразумевает, что значение пока не задано и может быть впоследствии изменено на любое. Поэтому, по мнению SQL, если сравнить  это значение с любым другим, то оно может оказаться как False, так и True – то есть Unknown. Однако проблема в том, что поля в таблице, как правило, можно изменять не на любые значения, а только на предусмотренные самой бизнес-логикой, и соответственно, когда мы например сравниваем код склада документа и код покупателя, один из которых NULL, то результат должен быть все же False, а не Unknown. Кроме того значение NULL в SQL может появляться не только как результат “отложенного” ввода, но и как результат денормализации (или в более общем случае внешнего связывания (OUTER JOIN)). Соответственно сравнение таких значений NULL также должно давать не Unknown, а именно False.</p>
            <p>Объяснить такое поведение можно первоначальной задумкой SQL как самодостаточного языка для пользователя, которая впрочем изначально была обречена на провал. В то же время для программиста логика Unknown только вносит дополнительную путаницу, в особенности при выполнении операций NOT</p>
	      </li>
        </ul>
  </li>
  <li>Недостаточная оптимизация выполнения запросов во всех существующих СУБД. 
  	<p>Так ни одна из них не анализирует булевую логику на предмет следствий, исключающих условий, оптимизации подзапросов в зависимости от условий самого запроса и т.п. Точно также в следствие избыточности в примере из предыдущего пункта[ссылка на разделение] ни один из серверов просто теоретически не догадается, что первый запрос нужно выполнять как второй.</p>
  </li>
  <li>Отсутствие объектной модели задания запросов. 
  <p>В том случае если логика программы определяется динамически, перед разработчиком ставится дополнительная задача конструирования (трансляции) текстовых запросов к базе в соответствующем синтаксисе. Также отсутствие единых стандартов приводит к невозможности переносить созданные решения с одной СУБД на другую.</p>
  </li>
  </ul>
  </div>
  <div class="article">
  <h3>Пользовательский интерфейс</h3>
    <p>Вместе с развитием языков программирования и баз данных не стояли на месте и интерфейсы взаимодействия с пользователем. Так начиная от консольных приложений включающих только операции ввода \ вывода строк, интерфейсы постепенно эволюционировали в многооконные фреймовые графические интерфейсы.  На данном этапе можно говорить об отдельной парадигме программирования пользовательских интерфейсов. Она наименее формализована, и поэтому описать ее можно весьма схематично. Среди основных элементов можно выделить такие понятия как:</p>
  <ul>
   	<li>элементы оформления:
        	<ul>
            	<li>надписи (label)</li>
                <li>изображения (image)</li>
            </ul>
    </li>
        <li>элементы расположения:
        	<ul>
            	<li>формы (form)</li>
                <li>контейнеры (container)</li>
            </ul>
        </li>
    <li>элементы редактирования:
        	<ul>
	          <li>поля ввода:
    	    		<ul>
        	    		<li>текстовые (textbox)</li>
	        	        <li>счетчики (spinnerbox)</li>
	           	    	<li>переключатели (checkbox)</li>
    	       		</ul>
        	  </li>
		        <li>поля выбора:
    	    		<ul>
        	    		<li>текстовые (textbox)</li>
	        	        <li>счетчики (spinnerbox)</li>
	           	    	<li>переключатели (checkbox)</li>
    	       		</ul>
	        	</li>
            </ul>
    </li>
        <li>элементы работы со списками:
        	<ul>
            	<li>таблицы (grid)</li>
                <li>списки (list)</li>
            </ul>
        </li>
        <li>элементы управления:
        	<ul>
            	<li>кнопки (button)</li>
            </ul>
        </li>
  </ul>    
    Все эти элементы имеют некоторые интерфейсы заполнения и события по изменению своего состояния.
    
    ущербность событийной модели
 </div>
 </div>
 <div class="article">
<h3>Семантические разрывы</h3>
<p>Если взглянуть на описанную эволюцию &quot;сверху&quot;, то можно заметить что после 3-го поколения (когда к системам начали предъявляться серьезные требования) средства перестали развиваться в глубину, и начали расширяться в ширину. Это привело к тому, что разработка современных приложений идет сразу в 3-х парадигмах : SQL, ООП и UI, что создает дополнительные затраты в разработке и потенциальные ошибки. Так, например, если ставится задача добавить объекту бизнес-приложения некоторое свойство разработчику приходится добавлять его на все 3 уровня – в таблицу добавить поле, в бизнес-логику добавить интерфейсы по его получению, изменению, в пользовательский интерфейс добавить соответствующий элемент редактирования.</p>
СЕМАНТИЧЕСКИЙ РАЗРЫВ МЕЖДУ ПОЛЬЗОВАТЕЛЕМ И РАЗРАБОТЧИКОМ
  </div>
  <div class="article">
<h3>Резюме</h3>
<p>Подводя итог, в современных средствах разработки можно насчитать, не менее десятка недостатков различной степени сложности. Каждый из них создает дополнительное препятствие в движении всех трех парадигм навстречу друг другу, с перспективой создания единой высоко-декларативной модели создания бизнес-решений. Однако главная проблема не в самих парадигмах (в конечном итоге они создавались больше 30 лет назад и естественно не лишены ошибок), а в их чрезмерной популяризации. При создании современных фреймворков\платформ их принято принимать за аксиому, изначально не допуская мысли что-нибудь в них исправить. Иногда эта вера доходит до маразма, например при создании ORM, перед которой стояла задача устранить разрыв между SQL и ООП, ни в одном источнике главная ошибка ООП даже не обозначена, а ведь уже даже из-за нее одной следует их принципиальная несовместимость. </p>
<p>В результате почти все существующие фреймворки (коих насчитывается тысячи если не десятки тысяч), образно говоря, предлагают строить дом на кривом фундаменте. А при неизбежном появлении дыр, предлагают специальные инструменты, которые помогают их заделывать. Также (что для них является самым важным) они дают гарантию, что если кто-то ошибется, то обвалится только его участок, а не весь дом. Благодаря этому дом в конце концов построить можно, вопрос только с какими затратами (впрочем при не fixed price это никого не волнует).</p> 
<p>
На сегодняшний день можно выделить фреймворки:
	Фреймворки : (развивались от ООП)
		J2EE, Spring, .Net - представляет из себя набор технологий, главная цель которых не ускорить разработку, а обеспечить масштабируемость (как в плане разработки, так и в плане эксплуатации), надежность(целостность), портируемость и интегрируемость полученных решений. Единственная технология, задача которой выходит за рамки этих  требований, это ORM-технологии. 
        Также стоит отметить, что все эти фреймворки\платформы получились настолько запутанными и сложными, что написание даже элементарных приложений, занимает существенно больше ресурсов, чем скажем аналогичная разработка например на Visual Basic (естественно с на порядок меньшими нефункциональными требованиями). 
    Пост-реляционные субд: (развивались от SQL в сторону ООП, ну то есть не совсем в сторону, скорее просто добавляя возможности)    	
    	D4, Cache - 
	ERP-платформы : в отличие от первых двух предполагаются быть самодостаточными - акцентированными на бизнес-приложения, ушли не дальше:
		SAP - наиболее древняя, накопившая очень большой функционал и как следствие наиболее тяжело поддающееся описанию. Естественно при таком пути развития ожидать от нее прорывов в вопросах совершенствования изначально не стоит
    	Axapta - есть много синтаксического сахара, объектной модель запросов, возможность писать SQL запросы в общей программе, в рамках MorphX возможность протаскивать поля таблиц через все 3 уровня.
    	1С - надо отдать должное в создании регистров, и документно-ориентированной модели построения бизнес-приложений (что впрочем очень часто бывает скорее минусом чем плюсом).      
    
	Ближе всех все же подошли к решению проблемы языки Common Lisp, им не хватает как раз initial функций и defgroup (вместо циклов) - им бы оставался очень маленький шажок до возможности интеграции с SQL , если быть точном, то идеальным вариантом был бы &quot;постоянно хранимый&quot; язык Common Lisp или даже Haskell с возможностями оптимизации (использованию индексов) не уступающими SQL.</p>
 </div>
</div>
<div class="article">
<h1>Архитектура платформы</h1>
<p><img src="architecture.jpg" /> </p>
<p>Архитектуру платформы можно образно представить в виде стека из нескольких уровней. Каждый уровень использует все выше его по стеку и соответственно не использует все ниже. Теоретически можно использовать платформу начиная с любого уровня, однако исходя из полноты предлагаемой парадигмы, делать это не имеет особого смысла.</p>
<p>Все четные  (второй, четвертый и шестой) уровни - технические, то есть не являются частью модели платформы, а представлены здесь скорее, для демонстрации того, как платформа функционирует и какие возможности предоставляет. </p>
<ul>
	<li>Самый базовый уровень это общая логика объектов и классов</li>
    <li>Уровень таблиц и запросов является своего рода обобщением SQL, устраняя все его недостатки</li>
	<li>Свойства и ограничения можно считать центральным уровнем в платформе. На нем задаются все правила, по которым должна функционировать система. Вместе с первым уровнем образуют бизнес-логику</li>
    <li>На уровне сессий изменений отражена динамика изменений системы во времени</li>
	<li>Формы и навигаторы отвечают за взаимодействие системы с внешним миром – пользователями и другими системами. Вместе с бизнес-логикой образуют бизнес-приложение</li>
	<li>Клиент отвечает за непосредственно отображение \ ввод информации пользователем. </li>
</ul>
<div class="article">
<h2>Объекты и классы</h2>
<p>Самым базовым элементом в системе является объект. Каждый объект принадлежит некоторому классу, который определяет качества присущие этому объекту. Будем говорить, что класс A наследует класс B, если все объекты класса A обладают качествами класса B. В отличие от многих реализаций ООП в платформе нет разделения на интерфейсы и классы, и класс может наследовать сразу несколько классов. Таким образом логику наследования можно представить в виде обычной логики направленных графов: </p>
<p><img src="classes.jpg" /> </p>
<p>Также [ссылка на статическую классификацию] в отличие от ООП допускается изменение классов существующих объектов. В этом смысле добавление и удаление - частные случаи этой операции. Так добавление это изменение класса объекта с неизвестного на заданный и наоборот удаление  - изменение с текущего на неизвестный. </p>
<p> Как и в ООП различают конкретные и абстрактные классы. Объекты могут принадлежать только конкретным классам, соответственно запрещено изменять класс объекта на абстрактный. </p>
 (интерфейсы, пример)
</div>
<!--
Особенности реализации
	Объект ассоциирован с его идентификатором и лежит в таблице objects. Для их генерации есть общий счетчик идентификаторов, который синхронно увеличивается при каждой потребности в новом объекте.<!-->
<div class="article">
<h2>Таблицы и запросы</h2>
<p>Таблицы и запросы - модуль, отвечающий за работу с табличными данными.  Ключевыми элементами являются Таблица (Table), Запрос (Query), Join, Выражение (Expr) и Условие (Where). Общий принцип использования следующий: </p>
<ul>
	<li>Создание запроса
	    <p>При создании запроса указывается коллекция ключей (Collection&lt;K&gt;). Для них автоматически создаются ключевые выражения, которые можно получить из созданного Query при помощи поля Map&lt;K,KeyExpr&gt; mapKeys. </p>
    </li>
   	<li>Создание условий и выражений
	    <p>Используя ключевые выражения запроса и таблицы базы, конструируем новые условия и выражения, при помощи интерфейсов:</p>
        <ul>
        	<li>Table
            	<ul>
                	<li>Join join(Map&lt;KeyField,Expr&gt; implement) – создать Join</li>
                </ul>
            </li>
           	<li>Join
            	<ul>
                	<li>Where getWhere() – получить условие вхождения в Join</li>
                   	<li>Expr getExpr(PropertyField field) – получить выражение для поля</li>
                </ul>
            </li>
           	<li>Where
            	<ul>
                	<li>Where and(Where where) – И</li>
                   	<li>Where or(Where where) - Или</li>
                   	<li>Where not() - Не</li>
                </ul>
            </li>
           	<li>Expr
            	<ul>
                	<li>Where getWhere() – получить условие определенности выражения</li>
                   	<li>Where compare(Expr expr, Compare compare) – сравнить с другим выражением</li>
                   	<li>Expr sum(Expr expr) – суммирует с другим выражением</li>
                    <li>static Expr formula(String formula, ConcreteValueClass value,Map&lt;String,Expr&gt; params) – создать выражение–формулу</li>
                    <li>Expr ifElse(Where where, Expr expr) – если where то это выражение, иначе – expr. Частные случаи:
                    	<ul>
		                    <li>Expr nvl(Expr expr) – если не определено, то expr</li>
							<li>Expr and(Where where) – только если условие where</li>
							<li>Expr max(Expr expr) – максимум из этого выражения и expr</li>
						</ul>
                    </li>
                    <li>Where isClass(ConcreteClass isClass) – получить условие, что выражение класса isClass</li>
                    <li>Expr groupBy(Map&lt;Expr,Expr&gt; group,boolean max) – сгруппировать по group.keys подставив group.values, если max – то вычислить максимум, иначе сумму</li>
                </ul>
            </li>
        </ul>        
    </li>
   	<li>Заполнение запроса
	    <p>Запрос (Query) заполняется при помощи интерфейсов:</p>
        <ul>
        	<li>and(Where where) – добавить условие</li>
			<li>add(V property,Expr expr) – добавить свойство запроса V с выражением expr</li>
		</ul>        
	</li>
    <li>Выполнение запроса
    	<p>Когда запрос (Query) построен, его можно выполнить при помощи интерфейса:</p>
        <ul>
        	<li>OrderedMap&lt;Map&lt;K,Integer&gt;,Map&lt;V,Object&gt;&gt; execute(SQLSession session) – выполняет запрос в заданной сессии.</li>
        </ul>
    </li>
</ul>
<div class="article">
<h3>Выполнение</h3>
	<p>Прежде чем запрос отправится на SQL сервер для выполнения, он сначала оптимизируется<a href="#optimizequery">*</a> , затем компилируется. Полученный после этой обработки результат кэшируется.</p>
    <div class="article">
    <h4>Оптимизация</h4>
    <p>В современных СУБД подразумевается, что запрос пишется разработчиком и именно он ответственен за его оптимизации. В случае же если запросы генерируются автоматически, они могут быть далеко не идеальны и выполнение их “как есть” (as is) приведет к критическому падению производительности системы.</p>
    <ul>
    <li>Оптимизация условий
	    <p>Как известно задача оптимизации условий даже в базовой постановке является NP-полной. Для ее решения существуют несколько подходов:</p>
        <ul>
        <li>ДНФ и КНФ. Самый классический  подход, однако в нем отсутствует важное свойство декомпозируемости. Так (A ИЛИ B ИЛИ C) AND (D ИЛИ E ИЛИ F) в ДНФ будет состоять из 9 элементов.  Добавив еще одну такую скобку получим 27 элементов и т.п.</li>
		<li>BDD. Независимо от своих преимуществ обладает главным недостатком, что SQL работает с НФ, поэтому в конечном итоге необходимо все равно выполнять преобразование условий из BDD в оптимизированные НФ, а эта задача по сложности не уступает исходной</li>
		<li>DNNF,d-DNNF и т.п. Обобщенные ДНФ и КНФ, создавались для баз знаний, задач ИИ, то есть под требования....</li>
        </ul>		
        <p>Кроме того в задачах оптимизации выражений помимо стандартных операций И, Или, Не, необходимо уметь эффективно выполнять  операцию “упростить, если условие заведомо ложно” (followFalse). И последний “штрих”, который окончательно делает невозможным использование любого из существующих подходов, необходимость учитывать логику выражений, классов, сравнений и т.п. Поэтому для оптимизации условий была разработана специальная архитектура,  построенная как раз на операции followFalse. Не будем здесь полностью описывать классы и алгоритмы используемые в ней, лишь перечислим задачи, которая она решает:</p>
		<ul>
        	<li>Устранение избыточных условий:
            	<ul>
            		<li>Отрицаний: W И !W == FALSE</li>
                    <li>Следствий: Дата (Приход) И !Приход == FALSE. Более общий случай отрицаний – использует логику выражений. Так если есть выражение формулы или Join и известно, что оно определено, то и все использованные выражения также определены</li>
                    <li>По классам: Покупатель (Приход) == FALSE. Так как таблицы и запросы идет выше по стеку, чем классовая логика, это дает возможность проверять классы выражений и условий на противоречивость. В частности, например, если добавляется новый объект, эта оптимизация позаботится о том, чтобы данные с его участием никогда не связывались с базой, потому как в ней этого объекта заведомо нет</li>
                    <li>Сравнений: A &gt; B И B &gt; C И C &gt;= A == FALSE. Использует правила транзитивности</li>
              </ul>
            </li>
            <li>Выделение скобок, решений (decisions). Если при выполнении операций И\Или обнаруживаются одинаковые условия ((A И B) ИЛИ (A И C)), то они выносятся за скобки (A ИЛИ (B И С)). Также если есть два решения с одинаковыми условиями (ЕСЛИ A,B,C) и (ЕСЛИ A,X,Y), то их также можно объединить в одно (КСЛИ A,B И X,C И Y).</li>
            <li>Перестановка следствий. Используя факт: (X ИЛИ (Y И Z)) и X=&gt;Y =&gt; (Y И (X ИЛИ Z)) оптимизатор пытается переставлять элементы в НФ (в случае если это уменьшает кол-во условий). Эффективно помогает при большом количестве сравнений. </li>
        </ul>
        <p>Во многом реализованные в этой архитектуре алгоритмы эвристичны (что исходя из NP-полноты задачи неизбежно), однако главной их целью было в рамках задач платформы обеспечить максимальную компактность условий, с чем они успешно справляется.</p>
      </li>
     <li>Оптимизация выражений с учетом условий, при которых они используются
       	<ul>
        	<li>Упаковка группирующих выражений. “Проталкивание” классовой логики внутрь группировок.</li>
            <li>Упаковка условных выражений. При построении Сase'ов упрощение условий и выражений с учетом того, что все верхние условия ложны.</li>
        </ul>
     </li>
     <li>Также в связи с особенностями SQL по использованию индексов задача оптимизатора не допускать в запросах:
     <ul>
     	<li>FULL JOIN в группирующих подзапросах</li>
        <li>условных выражений (CASE WHEN)  в: (вытаскивать логику условий case’ы над логикой выражений)
        	<ul>
		        <li>ключах группирующих подзапросов</li>
				<li>максимизирующихся выражениях группирующих подзапросов</li>
				<li>в подстановках Join'ов и группирующих подзапросов</li>
            </ul>
		</li>
     </ul>
     </li>		
  </ul>
  </div>
  <div class="article">
   <h4>Компиляция</h4>
		<p>Компиляцию можно условно разбить на несколько этапов:</p>
        <ul>
			<li>Упаковка выражений по общему условию запроса. Эта стадия кэшируется отдельно.</li>
			<li>Определение типов Join - разбиение на FULL JOIN или UNION ALL (в зависимости от адаптера) и INNER\LEFT JOIN’ы.</li>
			<li>Объединение группирующих выражений. Если у группирующих выражений совпадают условия и ключи, то выражения будут выполняться вместе одним вложенным запросом. Также здесь объединяются и все Join'ы.</li>
			<li>Трансляция в конкретный синтаксис. При помощи интерфейса адаптера SQLSyntax осуществляется конструирование запроса с учетом особенностей используемого SQL сервера.</li>
        </ul>
   </div>
   <div class="article">
   <h4>Кэширование</h4>
       <p>Многие алгоритмы, используемые при выполнении запроса, могут быть достаточно трудоемкими, поэтому результаты их выполнения желательно сохранять для повторного использования. Задача осложняется тем, что, во-первых, ключевые выражения запросов как правило генерируются автоматически (при [ссылка]создании), во-вторых, для запроса не принципиальны конкретные значения статичных выражений. Поэтому перед сравнением выполняется предварительное отображение ключей и значений выполняемого запроса на ключи и значения предыдущих запросов. Естественно если запрос окажется в кэше, для соответствующего результата выполняется обратное отображение.</p>
       <p>Хранение сформированных SQL запросов также может иметь дополнительную функцию - давать разработчику корректировать их под особенность конкретных SQL серверов. Однако нужно понимать, что, во-первых, количество создаваемых запросов очень большое, чтобы заниматься оптимизацией каждого в отдельности, а во-вторых при изменении логики также изменятся и все связанные запросы, соответственно придется все заново переоптимизировать. Поэтому предполагаемая политика оптимизации такова, чтобы выявлять “глюки” конкретных SQL серверов в общем случае и соответственно обходить их (например при помощи hints), а не пытаться бороться с каждым запросом по одному.</p>
       <p id="optimizequery">* На данном этапе запрос оптимизируется в процессе создания выражений и условий, а не в момент выполнения. По результатам тестирования с учетом кэшированиях смежных уровней реализовывать отдельно архитектуру создания и оптимизации (для того чтобы отдельно ее потом кэшировать) представляется нецелесообразным. Хотя если появится необходимость, то этот процесс все же будет реализован отдельно</p>
   </div>
</div>
</div>
<div class="article">
<h3>Свойства и ограничения</h3>
	<p>Основным понятием в системе можно считать понятие <i>свойства</i>. Это понятие не менее абстрактно чем объект, поэтому дать  его четкое определение также сложно. Будем говорить что свойство – это  некоторая абстракция, которая ставит в соответствие одному или нескольким объектам единственное значение - другой объект. Как видно из определения это понятие схоже с понятием функции, однако в отличие от нее может быть не только вычисляемой, но и хранимой (первичной как поле). Кроме того в отличие от функции в императивном программировании, &quot;вычисление&quot; свойства не приводит к побочным эффектам (изменению данных, созданию исключений, операциям ввода\вывода и т.п.). Как следствие на период отсутствия изменений в системе обладает детерменированностью - то есть при одинаковых объектах на входе возвращает один и тот же результат. Таким образом можно говорить что свойство обладает качествами <i>чистой функции</i>, у которой одним из параметров является состояние базы данных. </p>
    <p id="definedinv">Также как и во всех основных парадигмах программирования, в качестве значения может выступать не только объект, но и специальное значение null (не определено). Для всех свойств (за исключением свойства Если не) действует <i>инвариант определенности</i> - при подстановке значения null на вход свойства, результатом также является null.</p>
    <p>Каждое свойство имеет постоянное ограниченное число входов (будем в дальнейшем называть их <i>интерфейсами</i> свойства). Свойство может принимать на вход объекты любых классов. Предполагается, что если класс некоторого объекта не устраивает свойство, то, в отличие от ООП, оно не создает исключение, а просто возвращает null (не определено). Однако говорить о динамической типизации для свойств также не совсем корректно, потому как благодаря высокой декларативности система в состоянии сама определить исходя из семантики свойства для каких классов интерфейсов его значение может быть определено и какого класса оно может быть. Таким образом можно говорить о смешанной типизации - с одной стороны устраняется избыточность явного задания классов (как в Java,C# и т.п.), с другой стороны существует возможность определять заведомо избыточные вызовы до их непосредственного выполнения (в отличие от Perl, CLISP и т.п).</p>
    <p id="definitions">Перед тем как приступить к описанию классов свойств, введем несколько вспомогательных понятий. <i>Подстановкой</i> множества A – назовем свойство и отображение его интерфейсов на элементы из множества A. <i>Реализация</i> множества A – выбор одного из элементов A или подстановка A. </p>
    <p>Для описания свойств будем использовать следующую графическую интерпретацию: </p>
    <img src = "propertyvisual.jpg" />
    <div class="article">
    <h4>Базовые свойства</h4>
		<p>Создание свойств представляет из себя итеративный процесс. В модель платформы заложено семь базовых классов свойств, позволяющее строить новые свойства, на основе уже имеющихся: </p>
        <ul> 
        	<li><a href="#dataproperty">Первичное (Data)</a></li>
           	<li><a href="#classproperty">Классовое (Class)</a></li>
            <li>Формулы (Formula):
	            <ul>
                	<li><a href="#stringformulaproperty">Строковая формула (String)</a></li>
                    <li><a href="#andformulaproperty">Если (And)</a></li>
                    <li><a href="#compareformulaproperty">Сравнение (Compare)</a></li>
    	        </ul>
            </li>
           	<li><a href="#joinproperty">Реляционное (Join)</a></li>
           	<li><a href="#groupproperty">Группирующее (Group)</a></li>
            <li><a href="#unionproperty">Объединяющее (Union)</a></li>
        </ul>
        <div id="dataproperty" class="article">
        	<h5>Первичное (Data)</h5>
            <p>Графическое представление:</p>
            <img class="floatright" src="dataproperty.jpg" />
            <p>Общее описание: свойство, которое вводится \ поступает в систему извне (от пользователя / других систем). </p>
            <p>Определяется: для каких классов объектов оно может быть задано и какого класса объект должен быть на выходе.</p>
            <p>Принцип работы: для переданных объектов выполняется чтение значения из поля таблицы базы данных, в котором хранится это свойство.</p>
            <p>Замечания: это единственное не агрегированное свойство, то есть которое не может быть “вычислено”, и соответственно всегда является постоянно хранимым</p>
            <div class="clearfloat" />            
        </div>
        <div id="classproperty" class="article">
        	<h5>Классовое (Class)</h5>
            <div class="floatright">
            <p>Графическое представление:</p>
            <img src="classproperty.jpg" />
            </div>
            <p>Общее описание: свойство, которое отражает классовую принадлежность объектов. </p>
            <p>Определяется: для каких классов объектов действует и какое значение имеет на выходе.</p>
            <p>Принцип работы: если переданные объекты наследуют требуемые классы, то возвращает значение, иначе возвращает null.</p>
			<p>Замечания: как правило, используется вместе с реляционным свойством для выделения какого-то одного подкласса и дальнейшего отбора по нему</p>
            <div class="clearfloat" />            
        </div>
        <div class="article">
        <h5>Формулы:</h5>
        <div id="stringformulaproperty" class="article">
        	<h5>Строковая формула (String)</h5>
            <div class="floatright">
            <p>Графическое представление:</p>
            <img src="stringformulaproperty.jpg" />
            </div>
            <p>Общее описание: применяет к переданным объектам формулу. </p>
            <p>Определяется: формула в виде строки. Ссылаться на интерфейс с номером i можно при помощи идентификатора prmI.</p>
            <p>Принцип работы: вычисляет формулу, заменяя prmI на соответствующие переданные объекты.</p>
            <p>Замечания: Это свойство также должно удовлетворять <a href="#definedinv">инварианту определенности</a>, поэтому важно, что строка должна давать на выход null, если один из входов null. Например, <i>prm1*prm2</i> удовлетворяет этому условию. В то же время запрещено использовать <i>prm1</i> или <i>NVL(prm1,prm2)</i>. Вместо них должны использоваться <a href="#andformulaproperty">условное (Если)</a> и <a href="#unionproperty">объединяющее</a> свойства соответственно.</p>
            <div class="clearfloat" />            
        </div>
        <div id="andformulaproperty" class="article">
        	<h5>Если (And)</h5>
            <div class="floatright">
            <p>Графическое представление:</p>
            <img src="andformulaproperty.jpg" />
            </div>
            <p>Общее описание: выбирает объект, в зависимости от определенности остальных переданных значений.</p>
            <p>Определяется: количество условий и для каждого условия - выполнять прямую проверку (что определено) или обратную (что не определено).</p>
            <p>Принцип работы: если все переданные объекты удовлетворяют условиям, то возвращает основной объект, иначе null. </p>
            <p>Замечания: если одно из условий выполняет обратную проверку, то это свойство нарушает <a href="#defineinv">инвариант определенности</a></p>
            <div class="clearfloat" />            
        </div>
        <div id="compareformulaproperty" class="article">
        	<h5>Сравнение (Compare)</h5>
            <div class="floatright">
            <p>Графическое представление:</p>
            <img src="compareformulaproperty.jpg" />
            </div>
            <p>Общее описание: сравнивает два объекта</p>
            <p>Определяется: один из операторов сравнения: =,&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;</p>
            <p>Принцип работы: если объекты определены и удовлетворяют заданному условию, то возвращает значение Истина иначе null. </p>
            <div class="clearfloat" />
        </div>
		</div>
        <div id="joinproperty" class="article">
        	<h5>Реляционное (Join)</h5>
            <div class="floatright">
            <p>Графическое представление:</p>
            <img src="joinproperty.jpg" />
            </div>
            <p>Общее описание: свойство, которое на вход одному свойству подставляет другие свойства</p>
            <p>Определяется: кол-во интерфейсов и <a href="#definitions">подстановка</a> <a href="#definitions">реализаций</a> этих интерфейсов</p>
            <p>Принцип работы: для переданных объектов вычисляются значения реализаций интерфейсов, после чего вычисляется значение самой подстановки, которое и является значением свойства</p>
            <div class="clearfloat" />
        </div>
        <div id="groupproperty" class="article">
        	<h5>Группирующее (Group)</h5>
            <div class="floatright">
            <p>Графическое представление:</p>
            <img src="groupproperty.jpg" />
            </div>
            <p>Общее описание: получает сумму (Sum) или максимум (Max) свойства в разрезе других свойств</p>
            <p>Определяется: основное свойство, кол-во интерфейсов и отображение этих интерфейсов на <a href="#definitions">реализации</a> интерфейсов основного свойства</p>
            <p>Принцип работы: определяем множество всех объектов, для которых значения реализаций интерфейсов основного свойства совпадают с переданными объектами, после чего вычисляем на этом множестве заданную агрегирующую функцию (Sum или Max) от значений основного свойства</p>
            <div class="clearfloat" />
        </div>
        <div id="unionproperty" class="article">
        	<h5>Объединяющее (Union)</h5>
            <div class="floatright">
            <p>Графическое представление:</p>
            <img src="unionproperty.jpg" />
            </div>
            <p>Общее описание: &quot;объединяет&quot; несколько свойств в одно, при помощи одной из 3 операций:</p>
            	<ul>
                	<li>сумма - суммирует свойства</li>
                    <li>максимум - выбирает наибольшее</li>
                    <li>перегрузка - для списка выбирает первое определенное</li>
                </ul>
            <p>Определяется: количество интерфейсов, множество <a href="#definitions">подстановок</a> этих интерфейсов, операция объединения и в зависимости от этой операции:</p>
	            <ul>
                	<li>сумма - коэффициент для каждой подстановки</li>
                    <li>перегрузка - порядок подстановок</li>
    	        </ul>
            <p>Принцип работы: вычисляем значение подстановок для переданных объектов, после чего применяем к ним заданную операцию.</p>
            <p>Замечания: может сложиться впечатление, что это свойство избыточно, и ту же сумму можно реализовать через <a href="#stringformulaproperty">строковую формулу</a> и <a href="#joinproperty">реляционное</a> свойства, однако тогда в случае если одно из суммируемых свойств будет не определено, то и свойство реализованное через формулу (в отличие от объединяющего) также будет не определено. В этом смысле объединяющее свойство единственное, которое реализует логику ИЛИ, в то время как все остальные свойства – логику И.</p>
            <p>Аналогии: defgeneric в Common Lisp - как замена полиморфизму</p>
            <div class="clearfloat" />
        </div>
        <div id="recursiveproperty" class="article">
        	<h5>Рекурсивное (Recursive)</h5>
            <div class="floatright">
            <p>Графическое представление:</p>
            <img src="recursiveproperty.jpg" /></div>
            <p>Общее описание: свойство, рекурсивно выполняющее другое свойство</p>
            <p>Определяется: количество интерфейсов, начальное значение - реализация интерфейсов, рекурсия - подстановка интерфейсов, предыдущего значения и номера итерации.</p>
            <p>Принцип работы: для переданных объектов вычисляется начальное значение, после чего переданное количество раз вычисляет свойство рекурсии, подставляя каждый раз значение полученное на предыдущем шаге, соответственно возвращает последнее значение</p>
            <p>Это свойство не такое простое как остальные. Дело в том что реляционная алгебра лежащая в основе SQL и как следствие таблиц и запросов рекурсию не поддерживает. Однако в 1999 в стандарт SQL было включено понятие CTE (по сути именованных локальнох подзапросов), и в частности возможность их рекурсивного использования.</p>
            <p>Аналоги: оператор примитивной рекурсии, WITH RECURSIVE (CTE)</p>
        </div>
        <div class="article">
	        <h5>Универсальность базовых свойств</h5>
               	<p>Одной из самых важных характеристикой любой модели программирования является множество задач, которые на ней можно реализовать. В качестве науки изучающей формальные модели программирования является теория алгоритмов (вычислений). Разделом который изучает интересующую нас характеристику является теория вычислимости. В ней любую задачу ассоциируют с функцией, параметрами которой является информация, которая нам известна, и соответственно результатом ее вычисления, является информация, которую мы хотим получить. Исполнитель (множество вычисляемых элементов) называется тьюринг-полным, если на нем можно реализовать любую вычислимую функцию. Одним из тьюринг-полных формализмов (единственным декларативным и соответственно наиболее близким к предложенному) являются частично-рекурсивные функции. Покажем что любой из операторов можно реализовать при помощи базовых классов свойств. Так очевидно, что функцию следования можно реализовать при помощи строковой формулы, функцию выбора и оператор подстановки - реляционного свойства, оператор минимизации аргумента - максимизирующего группирующего свойство, а оператор примитивной рекурсии - рекурсивного свойства.</p>
                <p>Заметим, что при определении базового класса свойств не ставилось целью сделать это множество минимальным (таким множеством и были бы частично-рекурсивные функции). Например, суммирующее свойство можно теоретически реализовать при помощи сравнения, максимизирующего и рекурсивного свойства, а объединяющее (на сумму и максимум) через Если, строковую формулу и опять же объединяющее но уже на перегрузку. Целью было найти оптимальный баланс, определить все основные относительно простые задачи возникающие при разработке бизнес-решений. </p>
                <p>Нельзя также сказать что этот класс определялся только возможностями SQL серверов, так Order свойство также реализуется SQL сервером (в виде Window функций), а в базовые не входит (входит в производные).</p>
        </div>
   </div>
   <div class="article">
   <h4>Ограничения</h4>
   <p>Очень часто целостность системы не ограничивается только логикой классов в первичных свойствах. Для создания более сложных связей в платформе существует такое понятие как ограничения. Под <i>ограничением</i> понимается свойство, значение которого всегда должно быть null (не определено). Несмотря на кажущуюся простоту позволяет решать обширный класс задач: </p>
   <ul>
   		<li>
	        <h5>Численное ограничение</h5>
            <p>Необходимо: свойство A всегда должно быть меньше (не больше) свойства B</p>
            <p>Ограничение: обратное сравнение свойств A и B - не больше (меньше).</p>
        </li>
        <li>
        	<h5>Определенность</h5>
            <p>Необходимо: обязать пользователя всегда задавать первичное свойство</p>
            <p>Ограничение: для входных классов первичного свойство создаем классовое свойство, и при помощи его и свойства Если не, создаем свойство, показывающее когда требуемое свойство не задано, оно и будет ограничением</p>
          <p>Замечания: у первичного свойства для удобства задания есть специальный интерфейс setNotNull</p>
        </li>
        <li>
        	<h5>Агрегация</h5>
            <p>Необходимо: реализовать связь внутри объекта (<i>контекста</i>)</p>
            <p>Ограничение: свойство, проверяющее на неравенство контекстов учавствующих в связи объектов</p>
        </li>
        <li>
        	<h5>Уникальность</h5>
            <p>Необходимо: реализовать связь один-к-одному</p>
            <p>Ограничение: свойство, которое определяет для каких объектов совпадают значения свойства, но не совпадают сами объекты</p>
            <p>Замечания: обычно, когда требуется уникальность, возникает и необходимость в использовании и вводе &quot;обратных&quot; свойств, поэтому в явную такое ограничение обычно не используется, а вместо него используются производные цикличные свойства.</p>
        </li>
   </ul>
   <p>Отметим, что определение входных и выходных классов в первичных свойствах, также является частным случаем ограничений. Так по аналогии с определенностью можно создать ограничение на свойство показывающее, когда первичное свойство задано и один из его интерфейсов не того класса, который нам надо. Однако надо понимать, что именно по причине универсальности ограничений их использование нельзя считать абсолютно прозрачным для разработчика. Прежде всего речь идет об оптимизации запросов с учетом заданных ограничений. Если в частных случаях (например для определенности и упомянутой логики классов первичных свойств) оптимизация идет в полном объеме, то в общем случае система из-за большой алгоритмической сложности не всегда в состоянии выделить все заведомо ложные элементы и устранить их. Кроме того, так как ограничения надо учитывать при организации ввода, это само по себе создает дополнительную нагрузку на сервер приложений. Поэтому как и в традиционном программировании желательно по максимуму все решать логикой классов, и только потом аккуратно прибегать к использованию ограничений.</p>   
   </div>
   <div class="article">
   <h4>Производные свойства</h4>
   <p>Как было показано раньше базовые свойства являются тьюринг-полными, то есть позволяют решить любую поставленную задачу. Однако есть некоторое количество типовых задач, реализовывать которые каждый раз через базовые свойства не очень удобно. Поэтому в платформе реализована надстройка в виде производных свойств, своего рода шаблонов:</p>
   <div class="article">
   <h5>Группирующие</h5>
   		<p>Классы позволяющие расширить возможности стандартных группирующих свойств</p>
        <div class="article">
        <h5>Многоуровневое группирующее</h5>
            <p>Вступление: одна из задач максимизирующих свойств – упорядочивание данных. Так в частности эти свойства используется для поиска последнего элемента в списке. Однако бывают случаи, когда этот порядок определяется не одним, а сразу несколькими свойствами. Кроме того как правило нужны не сами максимумы, а объекты, при которых они достигаются, поэтому коды этих объектов также придется добавлять в “хвост” максимизации. </p>
            <p>Общее описание: максимизирует сразу по нескольким свойствам в разрезе других свойств</p>
            <p>Определяется: то же самое что в максимизирующих группирующих свойствах, а также список дополнительных реализаций, которые надо максимизировать.</p>
            <p>Принцип работы: определяется максимум первой реализации, отбираются только те объекты, при которых достигается этот максимум, после чего аналогичная операция выпоняется для всех последующих реализаций.</p>
	   </div>
       <div class="article">
       <h5>Первичные группирующие</h5>
       	   <p>Классы позволяющие создавать группирующие свойства, которые можно вводить. В общем-то они не превносят новой семантики, их задача - улучшить эргономичность системы.</p>
           <div class="article">
                <h5>Распределяющее</h5>
                <p>Общее описание: при вводе значения пользователем, изменяет суммируемое свойство, таким образом, чтобы получающееся в результате значение группирующего свойства совпадало с заданным. Естественно это можно сделать разными способами, но наиболее традиционным является подход, в котором определяется порядок и ограничение сверху</p>
                <p>Определяется: тоже самое что в группирующем, а также порядок и ограничение сверху - как реализации интерфейсов основного свойства</p>
                <p>Принцип работы: при изменении бежит в заданном порядке по объектам, и заполняем суммируемое свойство, в остальном также как группирующее</p>
                <p>Замечания: Это свойство может работать во втором режиме, когда само суммирующее свойство первично, а распределяющее свойство вычисляется на текущий момент</p>
           </div>
           <div class="article">
                <h5>Цикличное</h5>
                <p>Общее описание: при вводе значения пользователем, изменяет свойства, таким образом, чтобы получающееся в результате значение группирующего свойства совпадало с заданным.</p>
                <p>Определяется: тоже самое что в группирующем, а также какое первичное свойство, которое необходимо изменять</p>
                <p>Принцип работы: автоматически создает ограничение, что максимизируемое свойство в рамках группы всегда [ссылка на униакльность]уникально. При изменении сначала пытается изменить первичное свойство на null, так чтобы сделать максимизируемое свойство null, если оно раньше имело старое значение, затем пытается изменить первичное свойство таким образом чтобы значение хоть одного максимизируемого свойства совпадало с заданным. В остальном ведет себя как группирующее</p>                
           </div>
       </div>
   </div>
   <div class="article">
   <h5>Упорядочивающее</h5>
   		<p>Общее описание: позволяет получать накапливующуюся сумму (Sum) или предыдущее свойство (Previous) в заданном порядке</p>
        <p>Определяется: группируемое свойство, порядок и разбиения - как списки реализаций интерфейсов этого свойства</p>
        <p>Принцип работы: бежит по объектам в заданном порядке, расчитывая соответствующую агрегируемую функцию. По аналогии с группирующим свойством выполняет эту операцию в разрезе разбиений.</p>
        <p>Аналогии: Window функции в SQL </p>
   </div>
   <p>Стоит отметить что это множество классов свойств, в отличие от базового, еще может (будет) расширяться при появлении новых типов задач.</p>   </div>
<div class="article">
	<h5>Физическая модель</h5>
	<p>Описанная модель позволяет задать бизнес-логику в некоторой модели, абсолютно абстрагировано от того, как она будет выполняться на “физическом” уровне. Однако естественно перед тем как запустить ее в промышленную эксплуатацию необходимо выполнить некоторую оптимизацию выполнения, которую в силу недостатка статистики и алгоритмической сложности система выполнить не в состоянии. Соответственно “рычагами” которыми может управлять разработчик\администратор являются:</p>
    <ul>
    	 <li><h6>Постоянно хранимые свойства</h6>
         <p>В случае если количество операций чтения свойства существенно превышает количество операций его изменения, для ускорения работы имеет смысл уведомить систему, что такое свойство лучше хранить постоянно, и соответственно изменять сразу при изменении других свойств, влияющих на значение этого свойства. Так, например, рассчитывать остаток или последнюю цену при каждой (достаточно частой) необходимости просто перегрузит сервер базы данных. Включив же эти свойства в список постоянно хранимых, можно, с одной стороны конечно немного увеличив время применения изменений, с другой стороны значительно уменьшить время доступа, тем самым, сбалансировав общую нагрузку.</p>
         <p>Отметим что первичные свойства всегда являются постоянно хранимыми.</p>
         <p>Также постоянно хранимым свойствам всегда желательно задавать символьный идентификатор в явную, потому как в противном случае (если он генерируется) при добавлении новых постоянно хранимых свойств, может сбиться их привязка к колонкам в таблицах</p>
         </li>
    	<li><h6>Таблицы по классам</h6>
        <p>Для постоянно хранимых свойств необходимо определить в каких таблицах они будут хранится. Делать это для каждого свойства в отдельности достаточно неудобно, поэтому был использован другой подход. Разработчик задает, для каких множеств классов создавать таблицы. Соответственно для хранения свойства выбирается таблица, множество классов которой, наиболее близко к множеству классов этого свойства. Чем больше таблиц задано, тем больше будет выполняться операций связывания (Join), с другой стороны тем уже будут записи, для каждого хранимого свойства будет меньше записей со значением null, и общая база будет занимать меньше места.</p>
        </li>
        <li><h6>Индексы</h6>
		<p>В том случае если по свойству часто идут операция связывания (Join), группировки (Group) или отбора, для их оптимизации желательно иметь индексы, которые позволят выполнять эти операции не за линейное, а за логарифмическое время. Этот механизм используется только в СУБД (и хорошо там описан), система лишь своего рода “транслирует” список свойств в список полей, из которых потом оформляет индекс, поэтому останавливаться подробно на этом механизме не имеет особого смысла.</p>
        </li>
    </ul>
    <p>Отметим что все эти параметры можно изменять на уже существующей базе данных, правда пока не во время работы сервера приложений, а в момент его старта. </p>
    <p>Фактически функция оптимизации это больше функция администрирования, нежели разработки. При этом если в классических системах администратор управляет только построением индексов (3-й пункт), то в описанной модели его возможности гораздо шире. Соответственно большинство вопросов скорости работы системы он может и должен решать без привлечения разработчика.</p>
</div>
</div>
<div class="article">
<h3>Сессии изменений</h3>
	<p>В общем случае сессию изменений можно рассматривать как множество действий, которые переводят базу данных из одного состояния в другое. В отличие от транзакции, сессия изменений предполагает существование в течении достаточно продолжительного времени. Изменения данных включают в себя изменения класса объекта, и изменения первичных свойств. Также существует возможность изменять агрегированные свойства (однако в результате все равно любое такое действие, ”сохраняется” в сессии как изменение соответствующих первичных свойств):</p>
    <ul>
    	<li>Именованных свойств. Если редактированию подвергается реляционное свойство у которого основное свойство имеет ровно один интерфейс (например) имя, то изменяется свойство которое идет ему на вход.</li>
        <li>Сравнимых свойств. Если свойство является сравнением на равенство двух свойств, то сессия попробует выбрать одно из свойств редактируемым и если это удастся, то при изменении на null, изменит и это свойство на null, а при редактировании на Истина – подставит значение другого свойства.</li>
        <li>Объединяющих свойств. Если свойство работает на перегрузку, то сессия пытается изменить объединяемые свойства во</li>
        <li>Распределяющих и цикличных свойств - в соответствие с их [ссылка]описаниями.</li>
    </ul>
    <p>После того как все изменения сделаны можно применить их в базу, или же наоборот в любой момент очистить сессию и начать все делать заново. При применении идет проверка, что не нарушены ограничения, и инкрементно изменяются постоянно хранимые свойства.</p>
    <p>Одной из важных возможностей сессии является возможность обращаться к базе с учетом изменений до того как они применены. Таким образом, можно строить очень эргономичные интерфейсы, в которых пользователь может видеть агрегированные данные в том виде в каком они будут в базе, после того как он подтвердит сделанные изменения</p>
    <p>Также сессия, реализуя принцип “модель – вид”, позволяет объектам подписываться на изменения, и в случае когда им надо обновится, имеют возможность запрашивать какие новые изменения произошли с момента их прошлого обновления. Таким образом например можно организовывать работу форм с общими сессиями данных</p>
    <p>Если свойство участвует в каких-нибудь ограничениях, очевидно что изменять его можно не на любое значение, а лишь на то, которые не нарушат эти ограничения.  Соответственно когда вызывается диалог, желательно иметь возможность видеть только те объекты, на которые действительно можно изменить редактируемое свойство. Сессии изменений реализуют такую возможность при помощи системного изменяющего свойства. Это свойство определяет какое будет максимальное значение одного свойства, если отредактировать другое первичное свойство для заданных объектов на заданное значение. Таким образом, например если в диалоге поставить фильтр что максимальное значение всех ограничений должно быть не определено, мы получим только те объекты на которые можно изменять редактируемое первичное свойство. Особенно важна эта возможность при ограничениях [ссылка]агрегации.</p>
    <div class="article">
      	<h4>Производные изменения</h4>
        <p>Графическое представление:</p>
        <p>Описание: позволяет одним изменениям автоматически порождать другие</p>
        <p>Определяется: изменяемое свойство, а также значение и дополнительные условия - как подстановка реализаций и список подстановок интерфейсов этого свойства соответственно</p>
        <p>Принцип работы: автоматически замещает свойство на заданное значение, когда изменяется одна из реализаций последнего или одно из дополнительным условий, и все дополнительные условия определены.</p>
    	 <p>Произодные изменения в основном используются для реализации двух следующих возможностей:</p>
         <ul>
         <li><h5>Значения по умолчанию</h5>
         <p>В некоторых ситуациях значение свойства предполагается должно совпадать с значением другого свойства, но при этом может отличаться в некоторых позициях. Например очень часто такая задача возникает на стыке задач планирования и учета, когда скажем есть заказанное количество прихода, а есть реальное, которое было доставлено поставщиком. В таких случаях можно создать производное изменение, так чтобы изменяемым свойством и свойством значения были бы основное свойство (кол-во прихода) и свойство по умолчанию (кол-во заказа) соответственно, а реализациями значения - свойства отвечающие за их &quot;связывание&quot; (заказ). </p>
         </li>
         <li><h5>Транзакционные свойства</h5>
         <p>Описанная модель (как впрочем ООП и SQL) рассматривает систему в статичном состоянии. Однако на практике система в процессе применения транзакций изменяется, и зачастую эти транзакции сами выступают элементами бизнес-логики (как правило называются документами).  Соответственно они могут обращаться к данным актуальным на момент их выполнения. Чистый способ решения этой проблемы - добавлять в интерфейс всех свойств транзакцию, и соответственно при их описании для всех используемых свойств добавлять условия, что их транзакция должна быть раньше транзакции рассчитываемого свойства. Однако SQL (все его реализации) не предназначены для такой “интенсивной” работы с базой, поэтому де-факто в таких случаях используют другой способ: на момент проведения транзакции (изменения ее значимых свойств) текущие значения свойств “фиксируются” и становятся первичными (пример НДС или цена по товару). Этот подход гораздо эффективнее в случае отсутствия изменений задним числом, однако в обратном случае нарушается “временная целостность”, что впрочем, как правило, не настолько критично.</p>
         </li>
         </ul>
         <p>Дополнительные условия очевидно избыточны, сделаны для удобства задания транзакционных свойств</p>
         <p>Отметим возможность организации чего-то похожего при помощи объединяющего свойства на перегрузку. Однако в этом случае результирующее свойство будет изменятся всегда когда изменяется свойство значения, а это ни в первом ни во втором случае неприемлимо. Если условно сравнить значения по умолчанию, объединяющие свойства, транзакционные свойства, то первые предполагают изменения всех позиций, вторые для отдельных, а третьи вообще не предполагают изменений</p>
	</div>
</div>
</div>
<div class = "article">
<h3>Формы и навигаторы</h3>
	<div class = "article">
    <h4>Форма</h4>
    	<p>Бизнес-логика в определенном смысле является “вещью в себе”. Самым простым интерфейсом ее отображения была бы возможность просмотреть список объектов и изменить их классы, а также просмотреть каждое свойство в отдельности, и если оно первично, задать. Естественно такой интерфейс сложно было бы назвать эргономичным, поэтому в платформу заложено понятие формы, позволяющей объединять информацию и операции по ее изменению в одном представлении. Каждая форма состоит из групп объектов, представлений свойств, параметров их отображения, а также фильтров и порядков.</p>
  <div class = "article">
        	<h5>Группа объектов</h5>
            <p>Ключевым понятием в форме, как и в бизнес-логике, является объект. Чтобы не путать это понятие с аналогичным в бизнес-логике, далее последнее будем называть бизнес-объектом. В процессе работы формы для каждого ее объекта пользователь при помощи элементов навигации может выбирать необходимые ему бизнес-объекты. Соответственно именно для них будут отображаться все свойства и к ним же применяются все операции. Для каждого объекта формы задается базовый класс, который определяет с бизнес-объектами какого класса он работает. Пользователь также может конкретизировать этот класс в процессе работы при помощи соответствующего интерфейса.</p>
            <p>Несколько объектов могут быть объединены в группы, если необходимо отображать их в одной таблице. Группы выстраиваются в порядке, который используется для определения параметров их отображения, а также к какой группе по умолчанию будут относится [ссылка]представления свойств. </p>
            <p>PS: Базовый класс это частный случай фильтра, однако в отличие от последнего используется\необходим при добавлении групп свойств на форму, а также определения текушего [ссылка]вида свойства </p>
        </div>
        <div class = "article">
        	<h5>Представление свойства</h5>
            <p>Представление свойства - подстановка множества объектов формы. По умолчанию представление будет отображаться в самой нижней группе объектов, которые оно использует, однако есть возможность задать эту группу в явную.</p>
            <p>Представление в каждый момент может быть в объектном и классовом виде. В объектном виде оно находится если для текущих классов объектов, есть такие конкретные классы для которых оно заведомо не определено, и соответственно в классовом виде в обратном случае. Также есть возможность &quot;заставить&quot; представление быть всегда в классовом виде. Соответственно если представление в классовом виде, то оно отображается в таблице, в противном случае - в виде панели. Естественно если группа отображается в виде панели, то независимо от вида представление всегда отображается в виде панели. </p>
            <p>В дальнейшем, чтобы не плодить терминологию, будем ассоциировать свойство с его представлением.</p>
		</div>
        <div class = "article">
        	<h5>Расположение</h5>
            <p>Так как интерфейс является динамичным, может изменяться в процессе изменения бизнес-логики, в следствие политики безопасности, изменения [ссылка]вида представления свойства и т.п. использовать абсолютное позиционирование невозможно. Поэтому был использован более общий подход, в котором для всех визуальных элементов на форме задаются параметры дизайна : минимальный и максимальный размеры, оптимальных пропорции и взаимное расположения (слева,справа,сверху,снизу,внутри). В каждый момент обращения к расположению клиент, зная какие элементы видимы и в каком виде, при помощи симплекс-метода (используются и целочисленные переменной, то есть косвенно и метод ветвей и границ) определяет точные координаты расположения на форме.</p>
        </div>
        <div class = "article">
        	<h5>Фильтры</h5>
            <p>В каждой группе объектов отбора только по классам может быть недостаточно. Для решения этой задачи в форме существует понятие фильтров, включающее в себя:</p>
            <ul>
            <li><p>Фильтры для свойств:</p>
            <ul>
            	<li>Сравнение - сравнивает свойство с значениями, объектами или другими свойствами</li>
                <li>Определенность - проверяет свойство, на то что оно определено</li>
                <li>Классовость - проверяет что свойство заданного класса</li>
            </ul>
            </li>
            <li>Логические операторы (И, Или, Не)</li>
            </ul>
            <p>Также как и представления свойств, фильтры применяются ко всей форме, а конкретные группы объектов определяются по самому нижнему используемому фильтром объекту.</p>
            <p>Фильтры могут быть заданы несколькими способами:</p>
            <ul>
            	<li>Фиксированные. Задаются разработчиком и не могут изменяться в процессе работы формы.</li>
                <li>Стандартные. Представляет из себя группу фильтров созданных разработчиком, из которых пользователь может выбрать один текущий или убрать совсем.</li>
                <li>Пользовательские. При помощи соответствующего интерфейса, пользователь может создавать свои фильтры.</li>
            </ul>
        </div>
        <div class = "article">
        	<h5>Порядки</h5>
            <p>Так как таблица на форме представляет из себя список, а не множество, возникает вопрос в каком порядке отображать объекты в ней. Порядок в форме задается как список свойств и объектов, для каждого элемента которого в свою очередь задается направление сортировки – по возрастанию, по убыванию. Разработчик, может задать какой порядок будет при создании формы (по умолчанию коды участвующих в группе объектов), а в процессе работы пользователь при помощи соответствующих интерфейсов может его изменять. Порядки как и фильтры применяются к форме, и группа объектов определяется [ссылка] аналогично.</p>
        </div>
        <div class = "article">
        	<h5>Экспорт</h5>
            <p>Для любой формы есть возможность не только работать в интерактивном режиме, но и получить всю информацию на клиента, где тот в свою очередь может преобразовать ее в один из внешних форматов : </p>
            <ul>
            	<li>
                	<h6>Печатная форма</h6>
                    <p>Для отображения данных формы в графическом виде необходимо использовать печатные формы. Также этот формат необходимо использовать если требуется вывести данные на печать. В качестве технологии реализуюшей эту возможность использована LGPL технология - JasperReports. Дизайн формы представлен в виде jrxml файла, который можно настраивать например при помощи программы iReport. Также для любой формы есть возможность сгенерировать некоторый дизайн по умолчанию.</p>
                </li>
                <li>Структурные форматы такие как DBF, XML. Как правило используются для интеграции (выгрузки) с внешними системами.</li>            </ul>
      </div>
    </div>
    <div class = "article">
    	<h4>Навигатор</h4>
        <p>Для управления процессом создания форм в пользовательском интерфейсе существует так называемый навигатор. Он состоит из трех видов. Главный вид отображает все заданные разработчиком формы в виде иерархического представления. Любая форма, созданная при помощи него, имеет свою собственную сессию изменений. Следующий вид отображает так называемые связанные формы, которые могут задаваться разработчиком для каждой конкретной формы. В нем обычно отображаются формы, наиболее часто используемые с заданной. В случае если разработчик указал, что форма является печатной, то при ее открытии через вид связанные формы, она сразу будет выведена в печатном виде. Кроме того, все такие формы будут работать с той же сессией изменений, что и форма из которой ее вызвали. Последний, третий, вид работает относительно текущего выбранного объекта на форме и показывает все его классовые формы. По умолчанию, система для каждого класса в системе создает свою собственную форму, куда помещает все его базовые свойства и делает ее в качестве классовой для него. Классовые формы предоставляют возможность пользователю быстро и удобно просматривать всю информацию по объекту. Это достигается за счет того, что при создании любой формы система сама делает активными, последние выбранные объекты в рамках всего сеанса работы пользователя. Таким образом, если объект определенного класса присутствует на нескольких формах, то при переключении между ним он будет оставаться одним и тем же. Классовые формы, как и связанные, работают в той же сессии изменений, что и основные формы.</p>
    </div>
</div>
<div class = "article">
<h3>Клиент</h3>
	<p>Клиент представляет из себя браузер, то есть вообще ничего не знает о логике самой системы. Когда пользователь совершает какое-либо действие (переходит с одного объекта на другой, пытается изменить или изменяет какое-либо свойство, жмет любую кнопку и т.д.), клиент уведомляет сервер приложений об этом действии, а он, в свою очередь, передает клиенту все то, что он должна изменить у себя в представлении. При этом интерфейс взаимодействия между ними четко формализован, и передаются лишь те данные, которые отображаются\изменяются, предварительно проходя максимальную архивацию, за счет чего достигается минимально возможное общение сервера приложений с клиентом (ультратонкий клиент). </p>
    <p>В платформе предполагается использование двух типов клиентов - Desktop и Web:</p>
    <ul>
    	<li>Desktop - представляет из себя стандартное “оконное” приложение. Обладает большей эргономичностью по сравнению с Web интерфейсами, однако требует наличие на компьютере пользователя runtime библиотек (JRE), а также самой программы LS Fusion Client. При помощи LGPL технологии DockingFrames реализует фреймовый интерфейс, разбивающий рабочее пространство на взаимно непересекающиеся прямоугольные области, в противоположность традиционным менеджерам окон, которые создают области покоординатно и послойно. Помимо полного использования всего видимого пространства, подход фреймовых окон позволяет минимизировать использование мыши в операциях с окнами, повышая тем самым эффективность работы. Открытые формы, а также их расположения внутри основного окна, можно сохранять в автоматизированные рабочие места (АРМ'ы) и соответственно затем восстанавливать по требованию пользователя. Также существует возможность изменять стили оформления окон и всех элементов интерфейса.</li>
        <li>Web - в разработке...</li>
    </ul>
</div>
</body>
</html>